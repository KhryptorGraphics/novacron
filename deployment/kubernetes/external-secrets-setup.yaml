---
# This file provides instructions for setting up External Secrets Operator and cert-manager
# for production-grade secret management and TLS certificate automation

# Prerequisites:
# 1. Install External Secrets Operator:
#    helm repo add external-secrets https://charts.external-secrets.io
#    helm install external-secrets \
#      external-secrets/external-secrets \
#      -n external-secrets-system \
#      --create-namespace
#
# 2. Install cert-manager:
#    kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.13.0/cert-manager.yaml
#
# 3. Configure your secret backend (Vault, AWS Secrets Manager, Azure Key Vault, etc.)
#    Example for HashiCorp Vault is provided in production-manifests.yaml

---
# Example: AWS Secrets Manager SecretStore
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: aws-secrets-backend
  namespace: novacron
spec:
  provider:
    aws:
      service: SecretsManager
      region: us-west-2
      auth:
        secretRef:
          accessKeyIDSecretRef:
            name: aws-credentials
            key: access-key-id
          secretAccessKeySecretRef:
            name: aws-credentials
            key: secret-access-key

---
# Example: Azure Key Vault SecretStore
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: azure-keyvault-backend
  namespace: novacron
spec:
  provider:
    azurekv:
      vaultUrl: "https://novacron-kv.vault.azure.net"
      authType: ManagedIdentity
      identityId: "client-id-of-managed-identity"

---
# Example: Google Secret Manager SecretStore
apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: gcpsm-backend
  namespace: novacron
spec:
  provider:
    gcpsm:
      projectID: "novacron-project"
      auth:
        workloadIdentity:
          clusterLocation: us-central1
          clusterName: novacron-cluster
          serviceAccountRef:
            name: novacron-sa

---
# Instructions for populating secrets in your chosen backend:
#
# For Vault:
# vault kv put novacron/database postgres-password=<your-password>
# vault kv put novacron/cache redis-password=<your-password>
# vault kv put novacron/auth jwt-secret=<your-secret>
# vault kv put novacron/security encryption-key=<your-key>
#
# For AWS Secrets Manager:
# aws secretsmanager create-secret --name novacron/database --secret-string '{"postgres-password":"<your-password>"}'
# aws secretsmanager create-secret --name novacron/cache --secret-string '{"redis-password":"<your-password>"}'
# aws secretsmanager create-secret --name novacron/auth --secret-string '{"jwt-secret":"<your-secret>"}'
# aws secretsmanager create-secret --name novacron/security --secret-string '{"encryption-key":"<your-key>"}'
#
# For Azure Key Vault:
# az keyvault secret set --vault-name novacron-kv --name postgres-password --value <your-password>
# az keyvault secret set --vault-name novacron-kv --name redis-password --value <your-password>
# az keyvault secret set --vault-name novacron-kv --name jwt-secret --value <your-secret>
# az keyvault secret set --vault-name novacron-kv --name encryption-key --value <your-key>

---
# CI/CD Integration Notes:
#
# 1. Never commit actual secrets to the repository
# 2. Use environment-specific secret stores (dev, staging, prod)
# 3. Implement secret rotation policies
# 4. Use RBAC to limit secret access
# 5. Enable audit logging for secret access
# 6. Consider using sealed-secrets for GitOps workflows
#
# Example GitOps workflow with Sealed Secrets:
# kubectl create secret generic novacron-secrets \
#   --from-literal=postgres-password=<password> \
#   --dry-run=client -o yaml | \
#   kubeseal -o yaml > sealed-secrets.yaml