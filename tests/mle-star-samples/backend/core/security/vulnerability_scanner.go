package security

import (
	"bufio"
	"context"
	"encoding/json"
	"fmt"
	"io/fs"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"strings"
	"time"
)

// VulnerabilityScanner performs comprehensive vulnerability scanning
type VulnerabilityScanner struct {
	config *AuditConfig
	tools  map[string]ScanTool
}

// ScanTool represents a vulnerability scanning tool
type ScanTool interface {
	Name() string
	Version() string
	Scan(ctx context.Context, target string) (*ScanResult, error)
	IsAvailable() bool
}

// ScanResult represents the result of a vulnerability scan
type ScanResult struct {
	Tool            string                 `json:"tool"`
	Target          string                 `json:"target"`
	StartTime       time.Time             `json:"start_time"`
	EndTime         time.Time             `json:"end_time"`
	Duration        time.Duration         `json:"duration"`
	Vulnerabilities []Vulnerability       `json:"vulnerabilities"`
	Summary         ScanSummary           `json:"summary"`
	Metadata        map[string]interface{} `json:"metadata"`
}

// Vulnerability represents a security vulnerability
type Vulnerability struct {
	ID              string            `json:"id"`
	Title           string            `json:"title"`
	Description     string            `json:"description"`
	Severity        VulnSeverity      `json:"severity"`
	CVSS            float64           `json:"cvss"`
	CVE             string            `json:"cve,omitempty"`
	CWE             string            `json:"cwe,omitempty"`
	Category        string            `json:"category"`
	File            string            `json:"file,omitempty"`
	Line            int               `json:"line,omitempty"`
	Function        string            `json:"function,omitempty"`
	Evidence        string            `json:"evidence,omitempty"`
	Recommendation  string            `json:"recommendation"`
	References      []string          `json:"references"`
	FirstSeen       time.Time         `json:"first_seen"`
	LastSeen        time.Time         `json:"last_seen"`
	Status          VulnStatus        `json:"status"`
	Metadata        map[string]string `json:"metadata"`
}

// VulnSeverity defines vulnerability severity levels
type VulnSeverity string

const (
	SeverityInfo     VulnSeverity = "info"
	SeverityLow      VulnSeverity = "low"
	SeverityMedium   VulnSeverity = "medium"
	SeverityHigh     VulnSeverity = "high"
	SeverityCritical VulnSeverity = "critical"
)

// VulnStatus defines vulnerability status
type VulnStatus string

const (
	StatusNew        VulnStatus = "new"
	StatusConfirmed  VulnStatus = "confirmed"
	StatusFalsePositive VulnStatus = "false_positive"
	StatusFixed      VulnStatus = "fixed"
	StatusAccepted   VulnStatus = "accepted"
)

// ScanSummary provides a summary of scan results
type ScanSummary struct {
	Total     int `json:"total"`
	Critical  int `json:"critical"`
	High      int `json:"high"`
	Medium    int `json:"medium"`
	Low       int `json:"low"`
	Info      int `json:"info"`
}

// VulnerabilityResults aggregates all vulnerability scanning results
type VulnerabilityResults struct {
	CodeVulns         int                        `json:"code_vulnerabilities"`
	DependencyVulns   int                        `json:"dependency_vulnerabilities"`
	ContainerVulns    int                        `json:"container_vulnerabilities"`
	InfraVulns        int                        `json:"infrastructure_vulnerabilities"`
	NetworkVulns      int                        `json:"network_vulnerabilities"`
	DatabaseVulns     int                        `json:"database_vulnerabilities"`
	Critical          int                        `json:"critical"`
	High              int                        `json:"high"`
	Medium            int                        `json:"medium"`
	Low               int                        `json:"low"`
	Total             int                        `json:"total"`
	ScanResults       map[string]*ScanResult     `json:"scan_results"`
	TopVulnerabilities []Vulnerability           `json:"top_vulnerabilities"`
	ScanDuration      time.Duration              `json:"scan_duration"`
	LastScanTime      time.Time                  `json:"last_scan_time"`
}

// NewVulnerabilityScanner creates a new vulnerability scanner
func NewVulnerabilityScanner(config *AuditConfig) *VulnerabilityScanner {
	scanner := &VulnerabilityScanner{
		config: config,
		tools:  make(map[string]ScanTool),
	}
	
	// Initialize scanning tools
	scanner.initializeTools()
	
	return scanner
}

// initializeTools initializes available scanning tools
func (vs *VulnerabilityScanner) initializeTools() {
	tools := []ScanTool{
		&StaticAnalysisTool{},
		&DependencyScanner{},
		&ContainerScanner{},
		&NetworkScanner{},
		&DatabaseScanner{},
		&SecretScanner{},
	}
	
	for _, tool := range tools {
		if tool.IsAvailable() {
			vs.tools[tool.Name()] = tool
			log.Printf("Initialized scanning tool: %s v%s", tool.Name(), tool.Version())
		} else {
			log.Printf("Scanning tool not available: %s", tool.Name())
		}
	}
}

// Scan performs comprehensive vulnerability scanning
func (vs *VulnerabilityScanner) Scan(ctx context.Context, level AuditLevel, environment string) (*VulnerabilityResults, error) {
	startTime := time.Now()
	results := &VulnerabilityResults{
		ScanResults:  make(map[string]*ScanResult),
		LastScanTime: startTime,
	}
	
	// Determine scan targets based on level and environment
	targets := vs.getScanTargets(level, environment)
	
	// Run scans in parallel for efficiency
	scanChan := make(chan *ScanResult, len(vs.tools)*len(targets))
	errorChan := make(chan error, len(vs.tools)*len(targets))
	
	var scanCount int
	for toolName, tool := range vs.tools {
		if vs.shouldRunTool(toolName, level) {
			for _, target := range targets {
				scanCount++
				go func(t ScanTool, tgt string) {
					result, err := t.Scan(ctx, tgt)
					if err != nil {
						errorChan <- fmt.Errorf("tool %s failed on target %s: %w", t.Name(), tgt, err)
						return
					}
					scanChan <- result
				}(tool, target)
			}
		}
	}
	
	// Collect results
	var scanErrors []error
	for i := 0; i < scanCount; i++ {
		select {
		case result := <-scanChan:
			results.ScanResults[fmt.Sprintf("%s_%s", result.Tool, result.Target)] = result
			vs.aggregateResults(results, result)
		case err := <-errorChan:
			scanErrors = append(scanErrors, err)
			log.Printf("Scan error: %v", err)
		case <-ctx.Done():
			return nil, fmt.Errorf("scan cancelled: %w", ctx.Err())
		}
	}
	
	// Calculate final metrics
	results.ScanDuration = time.Since(startTime)
	results.TopVulnerabilities = vs.getTopVulnerabilities(results.ScanResults, 10)
	
	if len(scanErrors) > 0 {
		log.Printf("Scan completed with %d errors", len(scanErrors))
	}
	
	return results, nil
}

// getScanTargets determines what to scan based on level and environment
func (vs *VulnerabilityScanner) getScanTargets(level AuditLevel, environment string) []string {
	targets := []string{"."}
	
	switch level {
	case AuditLevelBasic:
		targets = []string{"./src", "./backend"}
	case AuditLevelStandard:
		targets = []string{".", "./docker", "./config"}
	case AuditLevelEnhanced:
		targets = []string{".", "./docker", "./config", "./scripts", "./infra"}
	case AuditLevelEnterprise:
		// Scan everything
		if dirs, err := vs.getAllDirectories("."); err == nil {
			targets = dirs
		}
	}
	
	return targets
}

// shouldRunTool determines if a tool should run based on audit level
func (vs *VulnerabilityScanner) shouldRunTool(toolName string, level AuditLevel) bool {
	switch level {
	case AuditLevelBasic:
		return toolName == "static_analysis" || toolName == "dependency_scanner"
	case AuditLevelStandard:
		return toolName != "network_scanner"
	case AuditLevelEnhanced, AuditLevelEnterprise:
		return true
	default:
		return false
	}
}

// aggregateResults combines individual scan results
func (vs *VulnerabilityScanner) aggregateResults(results *VulnerabilityResults, scanResult *ScanResult) {
	for _, vuln := range scanResult.Vulnerabilities {
		results.Total++
		
		switch vuln.Severity {
		case SeverityCritical:
			results.Critical++
		case SeverityHigh:
			results.High++
		case SeverityMedium:
			results.Medium++
		case SeverityLow:
			results.Low++
		}
		
		// Categorize by scan type
		switch scanResult.Tool {
		case "static_analysis":
			results.CodeVulns++
		case "dependency_scanner":
			results.DependencyVulns++
		case "container_scanner":
			results.ContainerVulns++
		case "network_scanner":
			results.NetworkVulns++
		case "database_scanner":
			results.DatabaseVulns++
		}
	}
}

// getTopVulnerabilities returns the most critical vulnerabilities
func (vs *VulnerabilityScanner) getTopVulnerabilities(scanResults map[string]*ScanResult, limit int) []Vulnerability {
	var allVulns []Vulnerability
	
	for _, result := range scanResults {
		allVulns = append(allVulns, result.Vulnerabilities...)
	}
	
	// Sort by severity and CVSS score
	// Implementation would sort vulnerabilities by priority
	
	if len(allVulns) > limit {
		return allVulns[:limit]
	}
	return allVulns
}

// getAllDirectories recursively finds all directories
func (vs *VulnerabilityScanner) getAllDirectories(root string) ([]string, error) {
	var dirs []string
	
	err := filepath.WalkDir(root, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		if d.IsDir() && !strings.HasPrefix(d.Name(), ".") {
			dirs = append(dirs, path)
		}
		return nil
	})
	
	return dirs, err
}

// StaticAnalysisTool performs static code analysis
type StaticAnalysisTool struct{}

func (s *StaticAnalysisTool) Name() string { return "static_analysis" }
func (s *StaticAnalysisTool) Version() string { return "1.0.0" }
func (s *StaticAnalysisTool) IsAvailable() bool { return true }

func (s *StaticAnalysisTool) Scan(ctx context.Context, target string) (*ScanResult, error) {
	startTime := time.Now()
	
	result := &ScanResult{
		Tool:      s.Name(),
		Target:    target,
		StartTime: startTime,
		Metadata:  make(map[string]interface{}),
	}
	
	vulnerabilities, err := s.scanForVulnerabilities(target)
	if err != nil {
		return nil, err
	}
	
	result.Vulnerabilities = vulnerabilities
	result.EndTime = time.Now()
	result.Duration = result.EndTime.Sub(startTime)
	result.Summary = s.generateSummary(vulnerabilities)
	
	return result, nil
}

func (s *StaticAnalysisTool) scanForVulnerabilities(target string) ([]Vulnerability, error) {
	var vulnerabilities []Vulnerability
	
	// Scan for common security patterns
	patterns := map[string]VulnerabilityPattern{
		"sql_injection": {
			Regex:       regexp.MustCompile(`(?i)(query|exec|prepare).*\+.*\$|string.*interpolation`),
			Severity:    SeverityHigh,
			Category:    "injection",
			Description: "Potential SQL injection vulnerability",
		},
		"xss": {
			Regex:       regexp.MustCompile(`(?i)innerHTML|outerHTML|document\.write`),
			Severity:    SeverityMedium,
			Category:    "xss",
			Description: "Potential XSS vulnerability",
		},
		"hardcoded_secrets": {
			Regex:       regexp.MustCompile(`(?i)(password|secret|key|token)\s*[:=]\s*["'][^"']{8,}`),
			Severity:    SeverityCritical,
			Category:    "secrets",
			Description: "Hardcoded secrets detected",
		},
		"insecure_random": {
			Regex:       regexp.MustCompile(`(?i)math\.random|rand\(\)`),
			Severity:    SeverityLow,
			Category:    "cryptography",
			Description: "Insecure random number generation",
		},
	}
	
	err := filepath.WalkDir(target, func(path string, d fs.DirEntry, err error) error {
		if err != nil {
			return err
		}
		
		if d.IsDir() || !s.isScannable(path) {
			return nil
		}
		
		fileVulns, scanErr := s.scanFile(path, patterns)
		if scanErr != nil {
			log.Printf("Error scanning file %s: %v", path, scanErr)
			return nil
		}
		
		vulnerabilities = append(vulnerabilities, fileVulns...)
		return nil
	})
	
	return vulnerabilities, err
}

func (s *StaticAnalysisTool) isScannable(path string) bool {
	ext := strings.ToLower(filepath.Ext(path))
	scannableExts := []string{".go", ".js", ".ts", ".py", ".java", ".php", ".rb", ".cs"}
	
	for _, validExt := range scannableExts {
		if ext == validExt {
			return true
		}
	}
	return false
}

func (s *StaticAnalysisTool) scanFile(path string, patterns map[string]VulnerabilityPattern) ([]Vulnerability, error) {
	var vulnerabilities []Vulnerability
	
	file, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	defer file.Close()
	
	scanner := bufio.NewScanner(file)
	lineNum := 0
	
	for scanner.Scan() {
		lineNum++
		line := scanner.Text()
		
		for patternName, pattern := range patterns {
			if pattern.Regex.MatchString(line) {
				vuln := Vulnerability{
					ID:             fmt.Sprintf("%s_%s_%d", patternName, filepath.Base(path), lineNum),
					Title:          fmt.Sprintf("%s in %s", pattern.Description, filepath.Base(path)),
					Description:    pattern.Description,
					Severity:       pattern.Severity,
					Category:       pattern.Category,
					File:           path,
					Line:           lineNum,
					Evidence:       strings.TrimSpace(line),
					Recommendation: s.getRecommendation(patternName),
					FirstSeen:      time.Now(),
					LastSeen:       time.Now(),
					Status:         StatusNew,
					Metadata:       make(map[string]string),
				}
				vulnerabilities = append(vulnerabilities, vuln)
			}
		}
	}
	
	return vulnerabilities, scanner.Err()
}

func (s *StaticAnalysisTool) getRecommendation(patternName string) string {
	recommendations := map[string]string{
		"sql_injection":     "Use parameterized queries or prepared statements",
		"xss":              "Sanitize user input and use safe DOM manipulation methods",
		"hardcoded_secrets": "Use environment variables or secure secret management",
		"insecure_random":   "Use cryptographically secure random number generators",
	}
	
	if rec, exists := recommendations[patternName]; exists {
		return rec
	}
	return "Review and remediate the identified security issue"
}

func (s *StaticAnalysisTool) generateSummary(vulnerabilities []Vulnerability) ScanSummary {
	summary := ScanSummary{Total: len(vulnerabilities)}
	
	for _, vuln := range vulnerabilities {
		switch vuln.Severity {
		case SeverityCritical:
			summary.Critical++
		case SeverityHigh:
			summary.High++
		case SeverityMedium:
			summary.Medium++
		case SeverityLow:
			summary.Low++
		case SeverityInfo:
			summary.Info++
		}
	}
	
	return summary
}

// VulnerabilityPattern defines a vulnerability detection pattern
type VulnerabilityPattern struct {
	Regex       *regexp.Regexp
	Severity    VulnSeverity
	Category    string
	Description string
}

// DependencyScanner scans for vulnerable dependencies
type DependencyScanner struct{}

func (d *DependencyScanner) Name() string { return "dependency_scanner" }
func (d *DependencyScanner) Version() string { return "1.0.0" }
func (d *DependencyScanner) IsAvailable() bool {
	// Check if npm audit or similar tools are available
	_, err := exec.LookPath("npm")
	return err == nil
}

func (d *DependencyScanner) Scan(ctx context.Context, target string) (*ScanResult, error) {
	startTime := time.Now()
	
	result := &ScanResult{
		Tool:      d.Name(),
		Target:    target,
		StartTime: startTime,
		Metadata:  make(map[string]interface{}),
	}
	
	// Scan npm dependencies
	npmVulns, err := d.scanNpmDependencies(ctx, target)
	if err != nil {
		log.Printf("NPM dependency scan failed: %v", err)
	}
	
	result.Vulnerabilities = append(result.Vulnerabilities, npmVulns...)
	result.EndTime = time.Now()
	result.Duration = result.EndTime.Sub(startTime)
	result.Summary = d.generateSummary(result.Vulnerabilities)
	
	return result, nil
}

func (d *DependencyScanner) scanNpmDependencies(ctx context.Context, target string) ([]Vulnerability, error) {
	var vulnerabilities []Vulnerability
	
	// Check for package.json
	packageJSONPath := filepath.Join(target, "package.json")
	if _, err := os.Stat(packageJSONPath); os.IsNotExist(err) {
		return vulnerabilities, nil
	}
	
	// Run npm audit
	cmd := exec.CommandContext(ctx, "npm", "audit", "--json")
	cmd.Dir = target
	
	output, err := cmd.Output()
	if err != nil {
		// npm audit returns non-zero exit code when vulnerabilities are found
		if exitError, ok := err.(*exec.ExitError); ok {
			output = exitError.Stderr
		}
	}
	
	// Parse npm audit output
	var auditResult struct {
		Vulnerabilities map[string]struct {
			Name     string `json:"name"`
			Severity string `json:"severity"`
			Title    string `json:"title"`
			URL      string `json:"url"`
			Range    string `json:"range"`
		} `json:"vulnerabilities"`
	}
	
	if err := json.Unmarshal(output, &auditResult); err != nil {
		return vulnerabilities, fmt.Errorf("failed to parse npm audit output: %w", err)
	}
	
	// Convert to vulnerability format
	for _, vuln := range auditResult.Vulnerabilities {
		severity := d.mapNpmSeverity(vuln.Severity)
		
		vulnerability := Vulnerability{
			ID:             fmt.Sprintf("npm_%s", vuln.Name),
			Title:          vuln.Title,
			Description:    fmt.Sprintf("Vulnerable npm package: %s", vuln.Name),
			Severity:       severity,
			Category:       "dependency",
			File:           packageJSONPath,
			Evidence:       vuln.Range,
			Recommendation: "Update to a secure version of the package",
			References:     []string{vuln.URL},
			FirstSeen:      time.Now(),
			LastSeen:       time.Now(),
			Status:         StatusNew,
			Metadata:       map[string]string{"package": vuln.Name, "range": vuln.Range},
		}
		
		vulnerabilities = append(vulnerabilities, vulnerability)
	}
	
	return vulnerabilities, nil
}

func (d *DependencyScanner) mapNpmSeverity(npmSeverity string) VulnSeverity {
	switch strings.ToLower(npmSeverity) {
	case "critical":
		return SeverityCritical
	case "high":
		return SeverityHigh
	case "moderate":
		return SeverityMedium
	case "low":
		return SeverityLow
	default:
		return SeverityLow
	}
}

func (d *DependencyScanner) generateSummary(vulnerabilities []Vulnerability) ScanSummary {
	summary := ScanSummary{Total: len(vulnerabilities)}
	
	for _, vuln := range vulnerabilities {
		switch vuln.Severity {
		case SeverityCritical:
			summary.Critical++
		case SeverityHigh:
			summary.High++
		case SeverityMedium:
			summary.Medium++
		case SeverityLow:
			summary.Low++
		case SeverityInfo:
			summary.Info++
		}
	}
	
	return summary
}

// ContainerScanner scans container images for vulnerabilities
type ContainerScanner struct{}

func (c *ContainerScanner) Name() string { return "container_scanner" }
func (c *ContainerScanner) Version() string { return "1.0.0" }
func (c *ContainerScanner) IsAvailable() bool {
	_, err := exec.LookPath("docker")
	return err == nil
}

func (c *ContainerScanner) Scan(ctx context.Context, target string) (*ScanResult, error) {
	// Implementation would use tools like Trivy, Clair, or Docker Scout
	// This is a simplified implementation
	return &ScanResult{
		Tool:            c.Name(),
		Target:          target,
		StartTime:       time.Now(),
		EndTime:         time.Now(),
		Vulnerabilities: []Vulnerability{},
		Summary:         ScanSummary{},
		Metadata:        make(map[string]interface{}),
	}, nil
}

// NetworkScanner scans for network vulnerabilities
type NetworkScanner struct{}

func (n *NetworkScanner) Name() string { return "network_scanner" }
func (n *NetworkScanner) Version() string { return "1.0.0" }
func (n *NetworkScanner) IsAvailable() bool { return true }

func (n *NetworkScanner) Scan(ctx context.Context, target string) (*ScanResult, error) {
	// Implementation would use tools like nmap, OpenVAS, etc.
	// This is a simplified implementation
	return &ScanResult{
		Tool:            n.Name(),
		Target:          target,
		StartTime:       time.Now(),
		EndTime:         time.Now(),
		Vulnerabilities: []Vulnerability{},
		Summary:         ScanSummary{},
		Metadata:        make(map[string]interface{}),
	}, nil
}

// DatabaseScanner scans for database security issues
type DatabaseScanner struct{}

func (d *DatabaseScanner) Name() string { return "database_scanner" }
func (d *DatabaseScanner) Version() string { return "1.0.0" }
func (d *DatabaseScanner) IsAvailable() bool { return true }

func (d *DatabaseScanner) Scan(ctx context.Context, target string) (*ScanResult, error) {
	// Implementation would check database configurations, access controls, etc.
	// This is a simplified implementation
	return &ScanResult{
		Tool:            d.Name(),
		Target:          target,
		StartTime:       time.Now(),
		EndTime:         time.Now(),
		Vulnerabilities: []Vulnerability{},
		Summary:         ScanSummary{},
		Metadata:        make(map[string]interface{}),
	}, nil
}

// SecretScanner scans for exposed secrets and credentials
type SecretScanner struct{}

func (s *SecretScanner) Name() string { return "secret_scanner" }
func (s *SecretScanner) Version() string { return "1.0.0" }
func (s *SecretScanner) IsAvailable() bool { return true }

func (s *SecretScanner) Scan(ctx context.Context, target string) (*ScanResult, error) {
	// Implementation would use tools like truffleHog, GitLeaks, etc.
	// This is a simplified implementation focusing on common secret patterns
	return &ScanResult{
		Tool:            s.Name(),
		Target:          target,
		StartTime:       time.Now(),
		EndTime:         time.Now(),
		Vulnerabilities: []Vulnerability{},
		Summary:         ScanSummary{},
		Metadata:        make(map[string]interface{}),
	}, nil
}