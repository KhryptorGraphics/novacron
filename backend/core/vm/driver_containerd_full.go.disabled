package vm

import (
	"context"
	"fmt"
	"log"
	"strconv"
	"strings"
	"time"

	"github.com/containerd/containerd"
	"github.com/containerd/containerd/cio"
	"github.com/containerd/containerd/namespaces"
	"github.com/containerd/containerd/oci"
	"github.com/opencontainers/runtime-spec/specs-go"
)

// ContainerdDriverFull implements the VMDriver interface for containerd-based containers
// This replaces the stub implementation with a full containerd client integration
type ContainerdDriverFull struct {
	nodeID      string
	client      *containerd.Client
	namespace   string
	containers  map[string]containerd.Container
}

// NewContainerdDriver creates a new containerd driver with full implementation
func NewContainerdDriver(config map[string]interface{}) (VMDriver, error) {
	nodeID := ""
	if id, ok := config["node_id"].(string); ok {
		nodeID = id
	}

	address := "/run/containerd/containerd.sock"
	if addr, ok := config["address"].(string); ok {
		address = addr
	}

	namespace := "novacron"
	if ns, ok := config["namespace"].(string); ok {
		namespace = ns
	}

	// Create containerd client
	client, err := containerd.New(address)
	if err != nil {
		return nil, fmt.Errorf("failed to create containerd client: %w", err)
	}

	log.Printf("Created containerd driver for node %s with namespace %s", nodeID, namespace)

	return &ContainerdDriverFull{
		nodeID:     nodeID,
		client:     client,
		namespace:  namespace,
		containers: make(map[string]containerd.Container),
	}, nil
}

// Create creates a new containerd container
func (d *ContainerdDriverFull) Create(ctx context.Context, config VMConfig) (string, error) {
	log.Printf("Creating containerd container %s", config.Name)

	// Set namespace context
	ctx = namespaces.WithNamespace(ctx, d.namespace)

	// Generate container ID
	containerID := fmt.Sprintf("novacron-%s-%d", config.Name, time.Now().UnixNano())

	// Determine image
	image := config.RootFS
	if image == "" {
		image = "docker.io/library/alpine:latest"
	}

	// Pull image if needed
	log.Printf("Pulling image %s", image)
	img, err := d.client.Pull(ctx, image, containerd.WithPullUnpack)
	if err != nil {
		return "", fmt.Errorf("failed to pull image: %w", err)
	}

	// Build container specification
	spec := d.buildContainerSpec(config)

	// Create container
	container, err := d.client.NewContainer(
		ctx,
		containerID,
		containerd.WithImage(img),
		containerd.WithNewSnapshot(containerID+"-snapshot", img),
		containerd.WithSpec(spec),
	)
	if err != nil {
		return "", fmt.Errorf("failed to create container: %w", err)
	}

	// Store container reference
	d.containers[containerID] = container

	log.Printf("Successfully created containerd container %s", containerID)
	return containerID, nil
}

// buildContainerSpec builds OCI runtime specification for the container
func (d *ContainerdDriverFull) buildContainerSpec(config VMConfig) *specs.Spec {
	spec := oci.GenerateSpec(containerd.DefaultSnapshotter, containerd.WithImageConfig(&config))

	// Set resource limits
	if config.MemoryMB > 0 {
		memoryLimit := int64(config.MemoryMB * 1024 * 1024)
		spec.Linux.Resources.Memory = &specs.LinuxMemory{
			Limit: &memoryLimit,
		}
	}

	if config.CPUShares > 0 {
		cpuShares := uint64(config.CPUShares)
		spec.Linux.Resources.CPU = &specs.LinuxCPU{
			Shares: &cpuShares,
		}
	}

	// Set environment variables
	if len(config.Env) > 0 {
		env := make([]string, 0, len(config.Env))
		for k, v := range config.Env {
			env = append(env, fmt.Sprintf("%s=%s", k, v))
		}
		spec.Process.Env = append(spec.Process.Env, env...)
	}

	// Set command and arguments
	if config.Command != "" {
		spec.Process.Args = []string{config.Command}
		spec.Process.Args = append(spec.Process.Args, config.Args...)
	}

	// Set working directory
	if config.WorkDir != "" {
		spec.Process.Cwd = config.WorkDir
	}

	return spec
}

// Start starts a containerd container
func (d *ContainerdDriverFull) Start(ctx context.Context, vmID string) error {
	log.Printf("Starting containerd container %s", vmID)

	ctx = namespaces.WithNamespace(ctx, d.namespace)

	container, exists := d.containers[vmID]
	if !exists {
		// Try to get container from containerd
		var err error
		container, err = d.client.LoadContainer(ctx, vmID)
		if err != nil {
			return fmt.Errorf("container %s not found: %w", vmID, err)
		}
		d.containers[vmID] = container
	}

	// Create task
	task, err := container.NewTask(ctx, cio.NewCreator(cio.WithStdio))
	if err != nil {
		return fmt.Errorf("failed to create task: %w", err)
	}

	// Start task
	if err := task.Start(ctx); err != nil {
		return fmt.Errorf("failed to start task: %w", err)
	}

	log.Printf("Successfully started containerd container %s", vmID)
	return nil
}

// Stop stops a containerd container
func (d *ContainerdDriverFull) Stop(ctx context.Context, vmID string) error {
	log.Printf("Stopping containerd container %s", vmID)

	ctx = namespaces.WithNamespace(ctx, d.namespace)

	container, exists := d.containers[vmID]
	if !exists {
		var err error
		container, err = d.client.LoadContainer(ctx, vmID)
		if err != nil {
			return fmt.Errorf("container %s not found: %w", vmID, err)
		}
	}

	// Get task
	task, err := container.Task(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to get task: %w", err)
	}

	// Kill task
	if err := task.Kill(ctx, containerd.SIGTERM); err != nil {
		log.Printf("Failed to send SIGTERM, trying SIGKILL: %v", err)
		if err := task.Kill(ctx, containerd.SIGKILL); err != nil {
			return fmt.Errorf("failed to kill task: %w", err)
		}
	}

	// Wait for task to exit
	statusC, err := task.Wait(ctx)
	if err != nil {
		return fmt.Errorf("failed to wait for task: %w", err)
	}

	select {
	case <-statusC:
		// Task exited
	case <-time.After(30 * time.Second):
		// Force kill
		task.Kill(ctx, containerd.SIGKILL)
		<-statusC
	}

	// Delete task
	if _, err := task.Delete(ctx); err != nil {
		log.Printf("Warning: failed to delete task: %v", err)
	}

	log.Printf("Successfully stopped containerd container %s", vmID)
	return nil
}

// Delete deletes a containerd container
func (d *ContainerdDriverFull) Delete(ctx context.Context, vmID string) error {
	log.Printf("Deleting containerd container %s", vmID)

	ctx = namespaces.WithNamespace(ctx, d.namespace)

	// Stop container first
	_ = d.Stop(ctx, vmID)

	container, exists := d.containers[vmID]
	if !exists {
		var err error
		container, err = d.client.LoadContainer(ctx, vmID)
		if err != nil {
			// Container doesn't exist, consider it deleted
			return nil
		}
	}

	// Delete container
	if err := container.Delete(ctx, containerd.WithSnapshotCleanup); err != nil {
		return fmt.Errorf("failed to delete container: %w", err)
	}

	// Remove from local cache
	delete(d.containers, vmID)

	log.Printf("Successfully deleted containerd container %s", vmID)
	return nil
}

// GetStatus gets the status of a containerd container
func (d *ContainerdDriverFull) GetStatus(ctx context.Context, vmID string) (State, error) {
	ctx = namespaces.WithNamespace(ctx, d.namespace)

	container, exists := d.containers[vmID]
	if !exists {
		var err error
		container, err = d.client.LoadContainer(ctx, vmID)
		if err != nil {
			return StateUnknown, fmt.Errorf("container %s not found: %w", vmID, err)
		}
		d.containers[vmID] = container
	}

	// Get task
	task, err := container.Task(ctx, nil)
	if err != nil {
		// No task means container is created but not started
		return StateCreated, nil
	}

	// Get task status
	status, err := task.Status(ctx)
	if err != nil {
		return StateUnknown, fmt.Errorf("failed to get task status: %w", err)
	}

	switch status.Status {
	case containerd.Running:
		return StateRunning, nil
	case containerd.Stopped:
		return StateStopped, nil
	case containerd.Paused:
		return StatePaused, nil
	case containerd.Created:
		return StateCreated, nil
	default:
		return StateUnknown, nil
	}
}

// GetInfo gets information about a containerd container
func (d *ContainerdDriverFull) GetInfo(ctx context.Context, vmID string) (*VMInfo, error) {
	ctx = namespaces.WithNamespace(ctx, d.namespace)

	container, exists := d.containers[vmID]
	if !exists {
		var err error
		container, err = d.client.LoadContainer(ctx, vmID)
		if err != nil {
			return nil, fmt.Errorf("container %s not found: %w", vmID, err)
		}
		d.containers[vmID] = container
	}

	// Get container info
	info, err := container.Info(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to get container info: %w", err)
	}

	// Get status
	status, err := d.GetStatus(ctx, vmID)
	if err != nil {
		status = StateUnknown
	}

	vmInfo := &VMInfo{
		ID:        vmID,
		Name:      info.Labels["name"],
		State:     status,
		CreatedAt: info.CreatedAt,
		NodeID:    d.nodeID,
	}

	// Get task metrics if running
	if status == StateRunning {
		task, err := container.Task(ctx, nil)
		if err == nil {
			if metrics, err := task.Metrics(ctx); err == nil {
				// Parse metrics (this would be more complex in a real implementation)
				vmInfo.MemoryUsage = int64(metrics.GetMemory().GetUsage().GetUsage())
			}
		}
	}

	return vmInfo, nil
}

// GetMetrics gets metrics for a containerd container
func (d *ContainerdDriverFull) GetMetrics(ctx context.Context, vmID string) (*VMInfo, error) {
	return d.GetInfo(ctx, vmID)
}

// ListVMs lists all containerd containers in the namespace
func (d *ContainerdDriverFull) ListVMs(ctx context.Context) ([]VMInfo, error) {
	ctx = namespaces.WithNamespace(ctx, d.namespace)

	containers, err := d.client.Containers(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to list containers: %w", err)
	}

	var vms []VMInfo
	for _, container := range containers {
		info, err := container.Info(ctx)
		if err != nil {
			log.Printf("Warning: failed to get info for container %s: %v", container.ID(), err)
			continue
		}

		status, _ := d.GetStatus(ctx, container.ID())

		vms = append(vms, VMInfo{
			ID:        container.ID(),
			Name:      info.Labels["name"],
			State:     status,
			CreatedAt: info.CreatedAt,
			NodeID:    d.nodeID,
		})
	}

	return vms, nil
}

// SupportsPause returns whether the driver supports pausing VMs
func (d *ContainerdDriverFull) SupportsPause() bool {
	return true
}

// SupportsResume returns whether the driver supports resuming VMs
func (d *ContainerdDriverFull) SupportsResume() bool {
	return true
}

// SupportsSnapshot returns whether the driver supports snapshots
func (d *ContainerdDriverFull) SupportsSnapshot() bool {
	return false // Basic containerd doesn't support snapshots
}

// SupportsMigrate returns whether the driver supports migration
func (d *ContainerdDriverFull) SupportsMigrate() bool {
	return false // Basic containerd doesn't support migration
}

// Pause pauses a containerd container
func (d *ContainerdDriverFull) Pause(ctx context.Context, vmID string) error {
	log.Printf("Pausing containerd container %s", vmID)

	ctx = namespaces.WithNamespace(ctx, d.namespace)

	container, exists := d.containers[vmID]
	if !exists {
		var err error
		container, err = d.client.LoadContainer(ctx, vmID)
		if err != nil {
			return fmt.Errorf("container %s not found: %w", vmID, err)
		}
	}

	task, err := container.Task(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to get task: %w", err)
	}

	if err := task.Pause(ctx); err != nil {
		return fmt.Errorf("failed to pause task: %w", err)
	}

	return nil
}

// Resume resumes a containerd container
func (d *ContainerdDriverFull) Resume(ctx context.Context, vmID string) error {
	log.Printf("Resuming containerd container %s", vmID)

	ctx = namespaces.WithNamespace(ctx, d.namespace)

	container, exists := d.containers[vmID]
	if !exists {
		var err error
		container, err = d.client.LoadContainer(ctx, vmID)
		if err != nil {
			return fmt.Errorf("container %s not found: %w", vmID, err)
		}
	}

	task, err := container.Task(ctx, nil)
	if err != nil {
		return fmt.Errorf("failed to get task: %w", err)
	}

	if err := task.Resume(ctx); err != nil {
		return fmt.Errorf("failed to resume task: %w", err)
	}

	return nil
}

// Snapshot creates a snapshot of a containerd container (not supported)
func (d *ContainerdDriverFull) Snapshot(ctx context.Context, vmID, name string, params map[string]string) (string, error) {
	return "", fmt.Errorf("snapshots not supported by containerd driver")
}

// Migrate migrates a containerd container (not supported)
func (d *ContainerdDriverFull) Migrate(ctx context.Context, vmID, target string, params map[string]string) error {
	return fmt.Errorf("migration not supported by containerd driver")
}