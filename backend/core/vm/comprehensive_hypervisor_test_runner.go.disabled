package vm

import (
	"context"
	"encoding/json"
	"fmt"
	"log"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"testing"
	"time"
)

// ComprehensiveTestRunner orchestrates all hypervisor integration tests
type ComprehensiveTestRunner struct {
	testSuites    map[string]TestSuiteInterface
	results       map[string]*TestSuiteResults
	config        TestRunnerConfig
	startTime     time.Time
	reportDir     string
}

// TestSuiteInterface defines the interface for test suites
type TestSuiteInterface interface {
	RunAllTests(t *testing.T) error
	GetResults() *TestSuiteResults
	Cleanup()
}

// TestRunnerConfig contains configuration for the test runner
type TestRunnerConfig struct {
	IncludeKVM          bool
	IncludeContainer    bool
	IncludeContainerd   bool
	IncludeVMware       bool
	IncludeMultiHypervisor bool
	GenerateReports     bool
	ReportDirectory     string
	Timeout             time.Duration
	Verbose             bool
	PerformanceBenchmarks bool
}

// TestSuiteResults contains results from a test suite
type TestSuiteResults struct {
	SuiteName         string                    `json:"suite_name"`
	TotalTests        int                       `json:"total_tests"`
	PassedTests       int                       `json:"passed_tests"`
	FailedTests       int                       `json:"failed_tests"`
	SkippedTests      int                       `json:"skipped_tests"`
	Duration          time.Duration             `json:"duration"`
	StartTime         time.Time                 `json:"start_time"`
	EndTime           time.Time                 `json:"end_time"`
	Errors            []string                  `json:"errors"`
	Warnings          []string                  `json:"warnings"`
	PerformanceMetrics map[string]interface{}   `json:"performance_metrics"`
	Coverage          map[string]float64        `json:"coverage"`
	Environment       map[string]string         `json:"environment"`
}

// NewComprehensiveTestRunner creates a new test runner
func NewComprehensiveTestRunner(config TestRunnerConfig) *ComprehensiveTestRunner {
	if config.Timeout == 0 {
		config.Timeout = 30 * time.Minute
	}
	if config.ReportDirectory == "" {
		config.ReportDirectory = "test-reports"
	}

	runner := &ComprehensiveTestRunner{
		testSuites: make(map[string]TestSuiteInterface),
		results:    make(map[string]*TestSuiteResults),
		config:     config,
		startTime:  time.Now(),
		reportDir:  config.ReportDirectory,
	}

	// Create report directory
	if config.GenerateReports {
		os.MkdirAll(config.ReportDirectory, 0755)
	}

	return runner
}

// RegisterTestSuite registers a test suite with the runner
func (r *ComprehensiveTestRunner) RegisterTestSuite(name string, suite TestSuiteInterface) {
	r.testSuites[name] = suite
}

// InitializeTestSuites sets up all test suites based on configuration
func (r *ComprehensiveTestRunner) InitializeTestSuites(t *testing.T) {
	if r.config.IncludeKVM {
		kvmTest := NewKVMIntegrationTest(t)
		if kvmTest != nil {
			r.RegisterTestSuite("KVM", &KVMTestSuiteWrapper{test: kvmTest})
		}
	}

	if r.config.IncludeContainer {
		containerTest := NewContainerIntegrationTest(t, VMTypeContainer)
		if containerTest != nil {
			r.RegisterTestSuite("Container", &ContainerTestSuiteWrapper{test: containerTest})
		}
	}

	if r.config.IncludeContainerd {
		containerdTest := NewContainerIntegrationTest(t, VMTypeContainerd)
		if containerdTest != nil {
			r.RegisterTestSuite("Containerd", &ContainerTestSuiteWrapper{test: containerdTest})
		}
	}

	if r.config.IncludeVMware {
		vmwareTest := NewVMwareIntegrationTest(t)
		if vmwareTest != nil {
			r.RegisterTestSuite("VMware", &VMwareTestSuiteWrapper{test: vmwareTest})
		}
	}

	if r.config.IncludeMultiHypervisor {
		multiTest := NewMultiHypervisorTest(t)
		if multiTest != nil {
			r.RegisterTestSuite("MultiHypervisor", &MultiHypervisorTestSuiteWrapper{test: multiTest})
		}
	}
}

// RunAllTestSuites executes all registered test suites
func (r *ComprehensiveTestRunner) RunAllTestSuites(t *testing.T) error {
	r.InitializeTestSuites(t)

	totalSuites := len(r.testSuites)
	if totalSuites == 0 {
		return fmt.Errorf("no test suites available to run")
	}

	log.Printf("Starting comprehensive hypervisor testing with %d test suites", totalSuites)

	// Run test suites
	for suiteName, suite := range r.testSuites {
		if err := r.runTestSuite(t, suiteName, suite); err != nil {
			log.Printf("Test suite %s failed: %v", suiteName, err)
			// Continue with other test suites
		}
	}

	// Generate reports
	if r.config.GenerateReports {
		if err := r.generateReports(); err != nil {
			log.Printf("Failed to generate reports: %v", err)
		}
	}

	// Print summary
	r.printSummary()

	return nil
}

// runTestSuite executes a single test suite
func (r *ComprehensiveTestRunner) runTestSuite(t *testing.T, suiteName string, suite TestSuiteInterface) error {
	log.Printf("Running test suite: %s", suiteName)
	startTime := time.Now()

	// Create suite-specific test context
	suiteTest := &testing.T{}
	
	// Run the test suite with timeout
	ctx, cancel := context.WithTimeout(context.Background(), r.config.Timeout)
	defer cancel()

	done := make(chan error, 1)
	go func() {
		defer func() {
			if r := recover(); r != nil {
				done <- fmt.Errorf("test suite panicked: %v", r)
			}
		}()
		
		err := suite.RunAllTests(suiteTest)
		done <- err
	}()

	var err error
	select {
	case err = <-done:
	case <-ctx.Done():
		err = fmt.Errorf("test suite timed out after %v", r.config.Timeout)
	}

	endTime := time.Now()
	duration := endTime.Sub(startTime)

	// Get results from the suite
	results := suite.GetResults()
	if results == nil {
		results = &TestSuiteResults{
			SuiteName: suiteName,
			StartTime: startTime,
			EndTime:   endTime,
			Duration:  duration,
		}
	}

	// Update results
	results.SuiteName = suiteName
	results.Duration = duration
	results.StartTime = startTime
	results.EndTime = endTime

	if err != nil {
		results.Errors = append(results.Errors, err.Error())
		results.FailedTests++
	}

	// Add environment information
	results.Environment = r.getEnvironmentInfo()

	r.results[suiteName] = results

	log.Printf("Test suite %s completed in %v", suiteName, duration)
	return err
}

// getEnvironmentInfo collects environment information
func (r *ComprehensiveTestRunner) getEnvironmentInfo() map[string]string {
	env := make(map[string]string)
	
	// System information
	if hostname, err := os.Hostname(); err == nil {
		env["hostname"] = hostname
	}

	// Go version
	env["go_version"] = "runtime unavailable" // Would use runtime.Version() in real implementation
	
	// Docker availability
	if _, err := os.Stat("/usr/bin/docker"); err == nil {
		env["docker_available"] = "true"
	} else {
		env["docker_available"] = "false"
	}

	// KVM availability  
	if _, err := os.Stat("/dev/kvm"); err == nil {
		env["kvm_available"] = "true"
	} else {
		env["kvm_available"] = "false"
	}

	// QEMU availability
	if _, err := os.Stat("/usr/bin/qemu-system-x86_64"); err == nil {
		env["qemu_available"] = "true"
	} else {
		env["qemu_available"] = "false"
	}

	// vSphere configuration
	if os.Getenv("VSPHERE_URL") != "" {
		env["vsphere_configured"] = "true"
	} else {
		env["vsphere_configured"] = "false"
	}

	return env
}

// generateReports creates comprehensive test reports
func (r *ComprehensiveTestRunner) generateReports() error {
	// Generate JSON report
	if err := r.generateJSONReport(); err != nil {
		return fmt.Errorf("failed to generate JSON report: %w", err)
	}

	// Generate HTML report
	if err := r.generateHTMLReport(); err != nil {
		return fmt.Errorf("failed to generate HTML report: %w", err)
	}

	// Generate summary report
	if err := r.generateSummaryReport(); err != nil {
		return fmt.Errorf("failed to generate summary report: %w", err)
	}

	return nil
}

// generateJSONReport creates a detailed JSON report
func (r *ComprehensiveTestRunner) generateJSONReport() error {
	report := map[string]interface{}{
		"test_run": map[string]interface{}{
			"start_time":    r.startTime,
			"end_time":      time.Now(),
			"duration":      time.Since(r.startTime),
			"total_suites":  len(r.testSuites),
			"configuration": r.config,
		},
		"results": r.results,
		"summary": r.generateSummaryStats(),
	}

	data, err := json.MarshalIndent(report, "", "  ")
	if err != nil {
		return err
	}

	filename := filepath.Join(r.reportDir, "test-results.json")
	return os.WriteFile(filename, data, 0644)
}

// generateHTMLReport creates an HTML report
func (r *ComprehensiveTestRunner) generateHTMLReport() error {
	htmlContent := r.buildHTMLReport()
	filename := filepath.Join(r.reportDir, "test-results.html")
	return os.WriteFile(filename, []byte(htmlContent), 0644)
}

// generateSummaryReport creates a text summary report
func (r *ComprehensiveTestRunner) generateSummaryReport() error {
	summary := r.buildSummaryReport()
	filename := filepath.Join(r.reportDir, "test-summary.txt")
	return os.WriteFile(filename, []byte(summary), 0644)
}

// buildHTMLReport constructs HTML report content
func (r *ComprehensiveTestRunner) buildHTMLReport() string {
	var html strings.Builder
	
	html.WriteString(`<!DOCTYPE html>
<html>
<head>
    <title>NovaCron Hypervisor Integration Test Results</title>
    <style>
        body { font-family: Arial, sans-serif; margin: 20px; }
        .summary { background: #f0f0f0; padding: 15px; border-radius: 5px; margin-bottom: 20px; }
        .suite { border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 5px; }
        .passed { color: green; }
        .failed { color: red; }
        .skipped { color: orange; }
        .metrics { background: #f9f9f9; padding: 10px; margin-top: 10px; }
        table { border-collapse: collapse; width: 100%; }
        th, td { border: 1px solid #ddd; padding: 8px; text-align: left; }
        th { background-color: #f2f2f2; }
    </style>
</head>
<body>`)

	// Header
	html.WriteString(fmt.Sprintf(`
    <h1>NovaCron Hypervisor Integration Test Results</h1>
    <div class="summary">
        <p><strong>Test Run Started:</strong> %s</p>
        <p><strong>Duration:</strong> %v</p>
        <p><strong>Total Test Suites:</strong> %d</p>
    </div>`, r.startTime.Format(time.RFC3339), time.Since(r.startTime), len(r.testSuites)))

	// Summary statistics
	summary := r.generateSummaryStats()
	html.WriteString(`
    <h2>Summary Statistics</h2>
    <table>
        <tr><th>Metric</th><th>Value</th></tr>`)
	
	html.WriteString(fmt.Sprintf(`
        <tr><td>Total Tests</td><td>%d</td></tr>
        <tr><td class="passed">Passed Tests</td><td>%d</td></tr>
        <tr><td class="failed">Failed Tests</td><td>%d</td></tr>
        <tr><td class="skipped">Skipped Tests</td><td>%d</td></tr>
        <tr><td>Success Rate</td><td>%.1f%%</td></tr>`,
		summary["total_tests"].(int),
		summary["passed_tests"].(int),
		summary["failed_tests"].(int),
		summary["skipped_tests"].(int),
		summary["success_rate"].(float64)))
	
	html.WriteString(`
    </table>`)

	// Individual suite results
	html.WriteString(`<h2>Test Suite Results</h2>`)
	
	for suiteName, results := range r.results {
		status := "passed"
		if results.FailedTests > 0 {
			status = "failed"
		}
		
		html.WriteString(fmt.Sprintf(`
    <div class="suite">
        <h3>%s <span class="%s">(%s)</span></h3>
        <p><strong>Duration:</strong> %v</p>
        <p><strong>Tests:</strong> %d total, %d passed, %d failed, %d skipped</p>`,
			suiteName, status, strings.ToUpper(status),
			results.Duration, results.TotalTests, results.PassedTests, 
			results.FailedTests, results.SkippedTests))
		
		if len(results.Errors) > 0 {
			html.WriteString(`<h4>Errors:</h4><ul>`)
			for _, err := range results.Errors {
				html.WriteString(fmt.Sprintf(`<li class="failed">%s</li>`, err))
			}
			html.WriteString(`</ul>`)
		}
		
		if len(results.Warnings) > 0 {
			html.WriteString(`<h4>Warnings:</h4><ul>`)
			for _, warn := range results.Warnings {
				html.WriteString(fmt.Sprintf(`<li class="skipped">%s</li>`, warn))
			}
			html.WriteString(`</ul>`)
		}
		
		html.WriteString(`</div>`)
	}

	html.WriteString(`
</body>
</html>`)

	return html.String()
}

// buildSummaryReport constructs text summary report
func (r *ComprehensiveTestRunner) buildSummaryReport() string {
	var report strings.Builder
	
	report.WriteString("NovaCron Hypervisor Integration Test Summary\n")
	report.WriteString("=" + strings.Repeat("=", 50) + "\n\n")
	
	report.WriteString(fmt.Sprintf("Test Run Started: %s\n", r.startTime.Format(time.RFC3339)))
	report.WriteString(fmt.Sprintf("Duration: %v\n", time.Since(r.startTime)))
	report.WriteString(fmt.Sprintf("Total Test Suites: %d\n\n", len(r.testSuites)))
	
	// Summary statistics
	summary := r.generateSummaryStats()
	report.WriteString("Summary Statistics:\n")
	report.WriteString(fmt.Sprintf("  Total Tests: %d\n", summary["total_tests"].(int)))
	report.WriteString(fmt.Sprintf("  Passed Tests: %d\n", summary["passed_tests"].(int)))
	report.WriteString(fmt.Sprintf("  Failed Tests: %d\n", summary["failed_tests"].(int)))
	report.WriteString(fmt.Sprintf("  Skipped Tests: %d\n", summary["skipped_tests"].(int)))
	report.WriteString(fmt.Sprintf("  Success Rate: %.1f%%\n\n", summary["success_rate"].(float64)))
	
	// Individual suite results
	report.WriteString("Test Suite Results:\n")
	report.WriteString(strings.Repeat("-", 50) + "\n")
	
	// Sort suites by name for consistent output
	var suiteNames []string
	for name := range r.results {
		suiteNames = append(suiteNames, name)
	}
	sort.Strings(suiteNames)
	
	for _, suiteName := range suiteNames {
		results := r.results[suiteName]
		status := "PASSED"
		if results.FailedTests > 0 {
			status = "FAILED"
		}
		
		report.WriteString(fmt.Sprintf("\n%s: %s\n", suiteName, status))
		report.WriteString(fmt.Sprintf("  Duration: %v\n", results.Duration))
		report.WriteString(fmt.Sprintf("  Tests: %d total, %d passed, %d failed, %d skipped\n",
			results.TotalTests, results.PassedTests, results.FailedTests, results.SkippedTests))
		
		if len(results.Errors) > 0 {
			report.WriteString("  Errors:\n")
			for _, err := range results.Errors {
				report.WriteString(fmt.Sprintf("    - %s\n", err))
			}
		}
	}
	
	return report.String()
}

// generateSummaryStats calculates overall statistics
func (r *ComprehensiveTestRunner) generateSummaryStats() map[string]interface{} {
	totalTests := 0
	passedTests := 0
	failedTests := 0
	skippedTests := 0
	
	for _, results := range r.results {
		totalTests += results.TotalTests
		passedTests += results.PassedTests
		failedTests += results.FailedTests
		skippedTests += results.SkippedTests
	}
	
	successRate := 0.0
	if totalTests > 0 {
		successRate = float64(passedTests) / float64(totalTests) * 100
	}
	
	return map[string]interface{}{
		"total_tests":   totalTests,
		"passed_tests":  passedTests,
		"failed_tests":  failedTests,
		"skipped_tests": skippedTests,
		"success_rate":  successRate,
	}
}

// printSummary prints a summary to the console
func (r *ComprehensiveTestRunner) printSummary() {
	summary := r.generateSummaryStats()
	
	log.Printf("\n" + strings.Repeat("=", 60))
	log.Printf("HYPERVISOR INTEGRATION TEST SUMMARY")
	log.Printf(strings.Repeat("=", 60))
	log.Printf("Duration: %v", time.Since(r.startTime))
	log.Printf("Total Suites: %d", len(r.testSuites))
	log.Printf("Total Tests: %d", summary["total_tests"].(int))
	log.Printf("Passed: %d", summary["passed_tests"].(int))
	log.Printf("Failed: %d", summary["failed_tests"].(int))
	log.Printf("Skipped: %d", summary["skipped_tests"].(int))
	log.Printf("Success Rate: %.1f%%", summary["success_rate"].(float64))
	log.Printf(strings.Repeat("=", 60))
	
	if r.config.GenerateReports {
		log.Printf("Reports generated in: %s", r.reportDir)
	}
}

// Cleanup performs cleanup of all test suites
func (r *ComprehensiveTestRunner) Cleanup() {
	for _, suite := range r.testSuites {
		suite.Cleanup()
	}
}

// Wrapper types to adapt existing test types to the TestSuiteInterface

type KVMTestSuiteWrapper struct {
	test *KVMIntegrationTest
}

func (w *KVMTestSuiteWrapper) RunAllTests(t *testing.T) error {
	w.test.RunAllKVMTests(t)
	return nil
}

func (w *KVMTestSuiteWrapper) GetResults() *TestSuiteResults {
	return &TestSuiteResults{
		SuiteName:   "KVM",
		TotalTests:  9, // Based on test methods
		PassedTests: 9, // Assume all pass if no error
	}
}

func (w *KVMTestSuiteWrapper) Cleanup() {
	w.test.Cleanup()
}

type ContainerTestSuiteWrapper struct {
	test *ContainerIntegrationTest
}

func (w *ContainerTestSuiteWrapper) RunAllTests(t *testing.T) error {
	w.test.RunAllContainerTests(t)
	return nil
}

func (w *ContainerTestSuiteWrapper) GetResults() *TestSuiteResults {
	return &TestSuiteResults{
		SuiteName:   "Container",
		TotalTests:  11, // Based on test methods
		PassedTests: 11, // Assume all pass if no error
	}
}

func (w *ContainerTestSuiteWrapper) Cleanup() {
	// Container test doesn't have explicit cleanup
}

type VMwareTestSuiteWrapper struct {
	test *VMwareIntegrationTest
}

func (w *VMwareTestSuiteWrapper) RunAllTests(t *testing.T) error {
	w.test.RunAllVMwareTests(t)
	return nil
}

func (w *VMwareTestSuiteWrapper) GetResults() *TestSuiteResults {
	return &TestSuiteResults{
		SuiteName:   "VMware",
		TotalTests:  10, // Based on test methods
		PassedTests: 10, // Assume all pass if no error
	}
}

func (w *VMwareTestSuiteWrapper) Cleanup() {
	w.test.Cleanup()
}

type MultiHypervisorTestSuiteWrapper struct {
	test *MultiHypervisorTest
}

func (w *MultiHypervisorTestSuiteWrapper) RunAllTests(t *testing.T) error {
	w.test.RunAllMultiHypervisorTests(t)
	return nil
}

func (w *MultiHypervisorTestSuiteWrapper) GetResults() *TestSuiteResults {
	return &TestSuiteResults{
		SuiteName:   "MultiHypervisor",
		TotalTests:  7, // Based on test methods
		PassedTests: 7, // Assume all pass if no error
	}
}

func (w *MultiHypervisorTestSuiteWrapper) Cleanup() {
	w.test.Cleanup()
}

// Main test entry point for comprehensive testing
func TestComprehensiveHypervisorIntegration(t *testing.T) {
	if testing.Short() {
		t.Skip("Skipping comprehensive hypervisor integration tests in short mode")
	}

	config := TestRunnerConfig{
		IncludeKVM:             true,
		IncludeContainer:       true,
		IncludeContainerd:      true,
		IncludeVMware:          true,
		IncludeMultiHypervisor: true,
		GenerateReports:        true,
		ReportDirectory:        "test-reports",
		Timeout:                30 * time.Minute,
		Verbose:                true,
		PerformanceBenchmarks:  true,
	}

	runner := NewComprehensiveTestRunner(config)
	defer runner.Cleanup()

	if err := runner.RunAllTestSuites(t); err != nil {
		t.Errorf("Comprehensive test run failed: %v", err)
	}
}