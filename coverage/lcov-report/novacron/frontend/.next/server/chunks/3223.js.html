
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for novacron/frontend/.next/server/chunks/3223.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../../../index.html">All files</a> / <a href="index.html">novacron/frontend/.next/server/chunks</a> 3223.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/4338</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/3983</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/1225</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/1</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">"use strict";<span class="cstat-no" title="statement not covered" >exports.id=3223,exports.ids=[3223],exports.modules={622:<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{function <span class="fstat-no" title="function not covered" >s(</span>t){<span class="cstat-no" title="statement not covered" >return t+.5|0}<span class="cstat-no" title="statement not covered" ></span>i.d(e,{qi:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >On,</span>vn:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Ji,</span>ZL:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Xn,</span>uw:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >zo,</span>kL:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Mn,</span>jI:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Gi,</span>Gu:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >uo,</span>De:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >xo,</span>ST:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Zi,</span>jn:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Bn,</span>f$:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Ho,</span>tt:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Qi,</span>od:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Hn,</span>Dx:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >bo,</span>u:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Io}</span>);c</span>onst n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >Math.max(Math.min(t,i),e);</span></span>function <span class="fstat-no" title="function not covered" >o(</span>t){<span class="cstat-no" title="statement not covered" >return n(s(2.55*t),0,255)}</span>function <span class="fstat-no" title="function not covered" >r(</span>t){<span class="cstat-no" title="statement not covered" >return n(s(255*t),0,255)}</span>function <span class="fstat-no" title="function not covered" >a(</span>t){<span class="cstat-no" title="statement not covered" >return n(s(t/2.55)/100,0,1)}</span>function <span class="fstat-no" title="function not covered" >h(</span>t){<span class="cstat-no" title="statement not covered" >return n(s(100*t),0,100)}</span>const l=<span class="cstat-no" title="statement not covered" >{0:0,1:1,2:2,3:3,4:4,5:5,6:6,7:7,8:8,9:9,A:10,B:11,C:12,D:13,E:14,F:15,a:10,b:11,c:12,d:13,e:14,f:15},</span>c=<span class="cstat-no" title="statement not covered" >[..."0123456789ABCDEF"],</span>d=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >c[15&amp;t],</span></span>u=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >c[(240&amp;t)&gt;&gt;4]+c[15&amp;t],</span></span>f=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(240&amp;t)&gt;&gt;4===(15&amp;t);</span></span>function <span class="fstat-no" title="function not covered" >g(</span>t){var e=<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >f(t.r)&amp;&amp;f(t.g)&amp;&amp;f(t.b)&amp;&amp;f(t.a))</span>(t)?d:u;<span class="cstat-no" title="statement not covered" ></span>return t?"#"+e(t.r)+e(t.g)+e(t.b)+(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t&lt;255?e(t):"")</span>(t.a,e):void 0}</span>const p=<span class="cstat-no" title="statement not covered" >/^(hsla?|hwb|hsv)\(\s*([-+.e\d]+)(?:deg)?[\s,]+([-+.e\d]+)%[\s,]+([-+.e\d]+)%(?:[\s,]+([-+.e\d]+)(%)?)?\s*\)$/;</span>function <span class="fstat-no" title="function not covered" >x(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >e*Math.min(i,1-i),</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,n=<span class="branch-0 cbranch-no" title="branch not covered" >(e+t/30)%12)</span>=&gt;<span class="cstat-no" title="statement not covered" >i-s*Math.max(Math.min(n-3,9-n,1),-1);<span class="cstat-no" title="statement not covered" ></span></span>return[n(0),n(8),n(4)]}</span>function <span class="fstat-no" title="function not covered" >m(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(s</span>,n=<span class="branch-0 cbranch-no" title="branch not covered" >(s+t/60)%6)</span>=&gt;<span class="cstat-no" title="statement not covered" >i-i*e*Math.max(Math.min(n,4-n,1),0);<span class="cstat-no" title="statement not covered" ></span></span>return[s(5),s(3),s(1)]}</span>function <span class="fstat-no" title="function not covered" >b(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >x(t,1,.5);</span>let n;<span class="cstat-no" title="statement not covered" >for(e+i&gt;1&amp;&amp;(n=1/(e+i),e*=n,i*=n),n=0;n&lt;3;n++)<span class="cstat-no" title="statement not covered" >s[n]*=1-e-i,s[n]+=e;<span class="cstat-no" title="statement not covered" >r</span></span>eturn s}</span>function <span class="fstat-no" title="function not covered" >_(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.r/255,</span>i=<span class="cstat-no" title="statement not covered" >t.g/255,</span>s=<span class="cstat-no" title="statement not covered" >t.b/255,</span>n=<span class="cstat-no" title="statement not covered" >Math.max(e,i,s),</span>o=<span class="cstat-no" title="statement not covered" >Math.min(e,i,s),</span>r=<span class="cstat-no" title="statement not covered" >(n+o)/2;</span>let a,h,l;<span class="cstat-no" title="statement not covered" >return n!==o&amp;&amp;(l=n-o,h=r&gt;.5?l/(2-n-o):l/(n+o),a=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s,n){<span class="cstat-no" title="statement not covered" >return t===n?(e-i)/s+(e&lt;i?6:0):e===n?(i-t)/s+2:(t-e)/s+4}</span>(e,i,s,l,n),a=60*a+.5),[0|a,h||0,r]}</span>function <span class="fstat-no" title="function not covered" >y(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return(Array.isArray(e)?t(e[0],e[1],e[2]):t(e,i,s)).map(r)}</span>function <span class="fstat-no" title="function not covered" >v(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return y(x,t,e,i)}</span>function <span class="fstat-no" title="function not covered" >w(</span>t){<span class="cstat-no" title="statement not covered" >return(t%360+360)%360}</span>function <span class="fstat-no" title="function not covered" >M(</span>t){const e=<span class="cstat-no" title="statement not covered" >p.exec(t);</span>let i,s=<span class="cstat-no" title="statement not covered" >255;<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >e</span></span>[5]!==i&amp;&amp;(s=e[6]?o(+e[5]):r(+e[5]));c</span>onst n=<span class="cstat-no" title="statement not covered" >w(+e[2]),</span>a=<span class="cstat-no" title="statement not covered" >+e[3]/100,</span>h=<span class="cstat-no" title="statement not covered" >+e[4]/100;<span class="cstat-no" title="statement not covered" ></span>return i="hwb"===e[1]?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return y(b,t,e,i)}</span>(n,a,h):"hsv"===e[1]?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return y(m,t,e,i)}</span>(n,a,h):v(n,a,h),{r:i[0],g:i[1],b:i[2],a:s}}</span>const k=<span class="cstat-no" title="statement not covered" >{x:"dark",Z:"light",Y:"re",X:"blu",W:"gr",V:"medium",U:"slate",A:"ee",T:"ol",S:"or",B:"ra",C:"lateg",D:"ights",R:"in",Q:"turquois",E:"hi",P:"ro",O:"al",N:"le",M:"de",L:"yello",F:"en",K:"ch",G:"arks",H:"ea",I:"ightg",J:"wh"},</span>S=<span class="cstat-no" title="statement not covered" >{OiceXe:"f0f8ff",antiquewEte:"faebd7",aqua:"ffff",aquamarRe:"7fffd4",azuY:"f0ffff",beige:"f5f5dc",bisque:"ffe4c4",black:"0",blanKedOmond:"ffebcd",Xe:"ff",XeviTet:"8a2be2",bPwn:"a52a2a",burlywood:"deb887",caMtXe:"5f9ea0",KartYuse:"7fff00",KocTate:"d2691e",cSO:"ff7f50",cSnflowerXe:"6495ed",cSnsilk:"fff8dc",crimson:"dc143c",cyan:"ffff",xXe:"8b",xcyan:"8b8b",xgTMnPd:"b8860b",xWay:"a9a9a9",xgYF:"6400",xgYy:"a9a9a9",xkhaki:"bdb76b",xmagFta:"8b008b",xTivegYF:"556b2f",xSange:"ff8c00",xScEd:"9932cc",xYd:"8b0000",xsOmon:"e9967a",xsHgYF:"8fbc8f",xUXe:"483d8b",xUWay:"2f4f4f",xUgYy:"2f4f4f",xQe:"ced1",xviTet:"9400d3",dAppRk:"ff1493",dApskyXe:"bfff",dimWay:"696969",dimgYy:"696969",dodgerXe:"1e90ff",fiYbrick:"b22222",flSOwEte:"fffaf0",foYstWAn:"228b22",fuKsia:"ff00ff",gaRsbSo:"dcdcdc",ghostwEte:"f8f8ff",gTd:"ffd700",gTMnPd:"daa520",Way:"808080",gYF:"8000",gYFLw:"adff2f",gYy:"808080",honeyMw:"f0fff0",hotpRk:"ff69b4",RdianYd:"cd5c5c",Rdigo:"4b0082",ivSy:"fffff0",khaki:"f0e68c",lavFMr:"e6e6fa",lavFMrXsh:"fff0f5",lawngYF:"7cfc00",NmoncEffon:"fffacd",ZXe:"add8e6",ZcSO:"f08080",Zcyan:"e0ffff",ZgTMnPdLw:"fafad2",ZWay:"d3d3d3",ZgYF:"90ee90",ZgYy:"d3d3d3",ZpRk:"ffb6c1",ZsOmon:"ffa07a",ZsHgYF:"20b2aa",ZskyXe:"87cefa",ZUWay:"778899",ZUgYy:"778899",ZstAlXe:"b0c4de",ZLw:"ffffe0",lime:"ff00",limegYF:"32cd32",lRF:"faf0e6",magFta:"ff00ff",maPon:"800000",VaquamarRe:"66cdaa",VXe:"cd",VScEd:"ba55d3",VpurpN:"9370db",VsHgYF:"3cb371",VUXe:"7b68ee",VsprRggYF:"fa9a",VQe:"48d1cc",VviTetYd:"c71585",midnightXe:"191970",mRtcYam:"f5fffa",mistyPse:"ffe4e1",moccasR:"ffe4b5",navajowEte:"ffdead",navy:"80",Tdlace:"fdf5e6",Tive:"808000",TivedBb:"6b8e23",Sange:"ffa500",SangeYd:"ff4500",ScEd:"da70d6",pOegTMnPd:"eee8aa",pOegYF:"98fb98",pOeQe:"afeeee",pOeviTetYd:"db7093",papayawEp:"ffefd5",pHKpuff:"ffdab9",peru:"cd853f",pRk:"ffc0cb",plum:"dda0dd",powMrXe:"b0e0e6",purpN:"800080",YbeccapurpN:"663399",Yd:"ff0000",Psybrown:"bc8f8f",PyOXe:"4169e1",saddNbPwn:"8b4513",sOmon:"fa8072",sandybPwn:"f4a460",sHgYF:"2e8b57",sHshell:"fff5ee",siFna:"a0522d",silver:"c0c0c0",skyXe:"87ceeb",UXe:"6a5acd",UWay:"708090",UgYy:"708090",snow:"fffafa",sprRggYF:"ff7f",stAlXe:"4682b4",tan:"d2b48c",teO:"8080",tEstN:"d8bfd8",tomato:"ff6347",Qe:"40e0d0",viTet:"ee82ee",JHt:"f5deb3",wEte:"ffffff",wEtesmoke:"f5f5f5",Lw:"ffff00",LwgYF:"9acd32"};</span>let P;function <span class="fstat-no" title="function not covered" >D(</span>t){<span class="cstat-no" title="statement not covered" >P||(P=<span class="fstat-no" title="function not covered" >fu</span>nction(){const t=<span class="cstat-no" title="statement not covered" >{},</span>e=<span class="cstat-no" title="statement not covered" >Object.keys(S),</span>i=<span class="cstat-no" title="statement not covered" >Object.keys(k);</span>let s,n,o,r,a;<span class="cstat-no" title="statement not covered" >for(s=0;s&lt;e.length;s++){<span class="cstat-no" title="statement not covered" >for(r=a=e[s],n=0;n&lt;i.length;n++)<span class="cstat-no" title="statement not covered" >o=i[n],a=a.replace(o,k[o]);<span class="cstat-no" title="statement not covered" >o</span></span>=parseInt(S[r],16),t[a]=[o&gt;&gt;16&amp;255,o&gt;&gt;8&amp;255,255&amp;o]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>(),P.transparent=[0,0,0,0]);c</span>onst e=<span class="cstat-no" title="statement not covered" >P[t.toLowerCase()];<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;{r:e[0],g:e[1],b:e[2],a:4===e.length?e[3]:255}}</span>const A=<span class="cstat-no" title="statement not covered" >/^rgba?\(\s*([-+.\d]+)(%)?[\s,]+([-+.e\d]+)(%)?[\s,]+([-+.e\d]+)(%)?(?:[\s,/]+([-+.e\d]+)(%)?)?\s*\)$/;</span>const O=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t&lt;=.0031308?12.92*t:1.055*Math.pow(t,1/2.4)-.055,</span></span>C=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t&lt;=.04045?t/12.92:Math.pow((t+.055)/1.055,2.4);</span></span>function <span class="fstat-no" title="function not covered" >T(</span>t,e,i){<span class="cstat-no" title="statement not covered" >if(t){let s=<span class="cstat-no" title="statement not covered" >_(t);<span class="cstat-no" title="statement not covered" ></span>s[e]=Math.max(0,Math.min(s[e]+s[e]*i,0===e?360:1)),s=v(s),t.r=s[0],t.g=s[1],t.b=s[2]}</span>}</span>function <span class="fstat-no" title="function not covered" >R(</span>t,e){<span class="cstat-no" title="statement not covered" >return t?Object.assign(e||{},t):t}</span>function <span class="fstat-no" title="function not covered" >I(</span>t){var e=<span class="cstat-no" title="statement not covered" >{r:0,g:0,b:0,a:255};<span class="cstat-no" title="statement not covered" ></span>return Array.isArray(t)?t.length&gt;=3&amp;&amp;(e={r:t[0],g:t[1],b:t[2],a:255},t.length&gt;3&amp;&amp;(e.a=r(t[3]))):(e=R(t,{r:0,g:0,b:0,a:1})).a=r(e.a),e}</span>function <span class="fstat-no" title="function not covered" >E(</span>t){<span class="cstat-no" title="statement not covered" >return"r"===t.charAt(0)?<span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >A.exec(t);</span>let i,s,r,a=<span class="cstat-no" title="statement not covered" >255;<span class="cstat-no" title="statement not covered" ></span>if(e){<span class="cstat-no" title="statement not covered" >if(e[7]!==i){const t=<span class="cstat-no" title="statement not covered" >+e[7];<span class="cstat-no" title="statement not covered" ></span>a=e[8]?o(t):n(255*t,0,255)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i=+e[1],s=+e[3],r=+e[5],i=255&amp;(e[2]?o(i):n(i,0,255)),s=255&amp;(e[4]?o(s):n(s,0,255)),r=255&amp;(e[6]?o(r):n(r,0,255)),{r:i,g:s,b:r,a:a}}</span>}</span>(t):M(t)}</span>class L{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >if(t instanceof L)<span class="cstat-no" title="statement not covered" >return t;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >typeof t;</span>let i;<span class="cstat-no" title="statement not covered" >"object"===e?i=I(t):"string"===e&amp;&amp;(i=<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e,i=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>return"#"===t[0]&amp;&amp;(4===i||5===i?e={r:255&amp;17*l[t[1]],g:255&amp;17*l[t[2]],b:255&amp;17*l[t[3]],a:5===i?17*l[t[4]]:255}:7!==i&amp;&amp;9!==i||(e={r:l[t[1]]&lt;&lt;4|l[t[2]],g:l[t[3]]&lt;&lt;4|l[t[4]],b:l[t[5]]&lt;&lt;4|l[t[6]],a:9===i?l[t[7]]&lt;&lt;4|l[t[8]]:255})),e}</span>(t)||D(t)||E(t)),this._rgb=i,this._valid=!!i}<span class="fstat-no" title="function not covered" ></span>ge</span>t valid(){<span class="cstat-no" title="statement not covered" >return this._valid}<span class="fstat-no" title="function not covered" ></span>ge</span>t rgb(){var t=<span class="cstat-no" title="statement not covered" >R(this._rgb);<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;(t.a=a(t.a)),t}<span class="fstat-no" title="function not covered" ></span>se</span>t rgb(t){<span class="cstat-no" title="statement not covered" >this._rgb=I(t)}<span class="fstat-no" title="function not covered" ></span>rg</span>bString(){<span class="cstat-no" title="statement not covered" >return this._valid?(t=this._rgb)&amp;&amp;(t.a&lt;255?`rgba(${t.r}, ${t.g}, ${t.b}, ${a(t.a)})`:`rgb(${t.r}, ${t.g}, ${t.b})`):void 0;v</span>ar t}<span class="fstat-no" title="function not covered" >he</span>xString(){<span class="cstat-no" title="statement not covered" >return this._valid?g(this._rgb):void 0}<span class="fstat-no" title="function not covered" ></span>hs</span>lString(){<span class="cstat-no" title="statement not covered" >return this._valid?<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >_(t),</span>i=<span class="cstat-no" title="statement not covered" >e[0],</span>s=<span class="cstat-no" title="statement not covered" >h(e[1]),</span>n=<span class="cstat-no" title="statement not covered" >h(e[2]);<span class="cstat-no" title="statement not covered" ></span>return t.a&lt;255?`hsla(${i}, ${s}%, ${n}%, ${a(t.a)})`:`hsl(${i}, ${s}%, ${n}%)`}</span>(this._rgb):void 0}<span class="fstat-no" title="function not covered" ></span>mi</span>x(t,e){<span class="cstat-no" title="statement not covered" >if(t){const i=<span class="cstat-no" title="statement not covered" >this.rgb,</span>s=<span class="cstat-no" title="statement not covered" >t.rgb;</span>let n;const o=<span class="cstat-no" title="statement not covered" >e===n?.5:e,</span>r=<span class="cstat-no" title="statement not covered" >2*o-1,</span>a=<span class="cstat-no" title="statement not covered" >i.a-s.a,</span>h=<span class="cstat-no" title="statement not covered" >((r*a===-1?r:(r+a)/(1+r*a))+1)/2;<span class="cstat-no" title="statement not covered" ></span>n=1-h,i.r=255&amp;h*i.r+n*s.r+.5,i.g=255&amp;h*i.g+n*s.g+.5,i.b=255&amp;h*i.b+n*s.b+.5,i.a=o*i.a+(1-o)*s.a,this.rgb=i}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this}<span class="fstat-no" title="function not covered" ></span>in</span>terpolate(t,e){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;(this._rgb=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const s=<span class="cstat-no" title="statement not covered" >C(a(t.r)),</span>n=<span class="cstat-no" title="statement not covered" >C(a(t.g)),</span>o=<span class="cstat-no" title="statement not covered" >C(a(t.b));<span class="cstat-no" title="statement not covered" ></span>return{r:r(O(s+i*(C(a(e.r))-s))),g:r(O(n+i*(C(a(e.g))-n))),b:r(O(o+i*(C(a(e.b))-o))),a:t.a+i*(e.a-t.a)}}</span>(this._rgb,t._rgb,e)),this}<span class="fstat-no" title="function not covered" ></span>cl</span>one(){<span class="cstat-no" title="statement not covered" >return new L(this.rgb)}<span class="fstat-no" title="function not covered" ></span>al</span>pha(t){<span class="cstat-no" title="statement not covered" >return this._rgb.a=r(t),this}<span class="fstat-no" title="function not covered" ></span>cl</span>earer(t){<span class="cstat-no" title="statement not covered" >return this._rgb.a*=1-t,this}<span class="fstat-no" title="function not covered" ></span>gr</span>eyscale(){const t=<span class="cstat-no" title="statement not covered" >this._rgb,</span>e=<span class="cstat-no" title="statement not covered" >s(.3*t.r+.59*t.g+.11*t.b);<span class="cstat-no" title="statement not covered" ></span>return t.r=t.g=t.b=e,this}<span class="fstat-no" title="function not covered" ></span>op</span>aquer(t){<span class="cstat-no" title="statement not covered" >return this._rgb.a*=1+t,this}<span class="fstat-no" title="function not covered" ></span>ne</span>gate(){const t=<span class="cstat-no" title="statement not covered" >this._rgb;<span class="cstat-no" title="statement not covered" ></span>return t.r=255-t.r,t.g=255-t.g,t.b=255-t.b,this}<span class="fstat-no" title="function not covered" ></span>li</span>ghten(t){<span class="cstat-no" title="statement not covered" >return T(this._rgb,2,t),this}<span class="fstat-no" title="function not covered" ></span>da</span>rken(t){<span class="cstat-no" title="statement not covered" >return T(this._rgb,2,-t),this}<span class="fstat-no" title="function not covered" ></span>sa</span>turate(t){<span class="cstat-no" title="statement not covered" >return T(this._rgb,1,t),this}<span class="fstat-no" title="function not covered" ></span>de</span>saturate(t){<span class="cstat-no" title="statement not covered" >return T(this._rgb,1,-t),this}<span class="fstat-no" title="function not covered" ></span>ro</span>tate(t){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var i=<span class="cstat-no" title="statement not covered" >_(t);<span class="cstat-no" title="statement not covered" ></span>i[0]=w(i[0]+e),i=v(i),t.r=i[0],t.g=i[1],t.b=i[2]}</span>(this._rgb,t),this}</span>}function <span class="fstat-no" title="function not covered" >z(</span>){}const F=<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >()</span>=&gt;{let t=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t++}</span></span>)();</span>function <span class="fstat-no" title="function not covered" >B(</span>t){<span class="cstat-no" title="statement not covered" >return null===t||void 0===t}</span>function <span class="fstat-no" title="function not covered" >W(</span>t){<span class="cstat-no" title="statement not covered" >if(Array.isArray&amp;&amp;Array.isArray(t))<span class="cstat-no" title="statement not covered" >return!0;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >Object.prototype.toString.call(t);<span class="cstat-no" title="statement not covered" ></span>return"[object"===e.slice(0,7)&amp;&amp;"Array]"===e.slice(-6)}</span>function <span class="fstat-no" title="function not covered" >H(</span>t){<span class="cstat-no" title="statement not covered" >return null!==t&amp;&amp;"[object Object]"===Object.prototype.toString.call(t)}</span>function <span class="fstat-no" title="function not covered" >V(</span>t){<span class="cstat-no" title="statement not covered" >return("number"===typeof t||t instanceof Number)&amp;&amp;isFinite(+t)}</span>function <span class="fstat-no" title="function not covered" >j(</span>t,e){<span class="cstat-no" title="statement not covered" >return V(t)?t:e}</span>function <span class="fstat-no" title="function not covered" >N(</span>t,e){<span class="cstat-no" title="statement not covered" >return"undefined"===typeof t?e:t}</span>const $=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >"string"===typeof t&amp;&amp;t.endsWith("%")?parseFloat(t)/100*e:+t;</span></span>function <span class="fstat-no" title="function not covered" >Y(</span>t,e,i){<span class="cstat-no" title="statement not covered" >if(t&amp;&amp;"function"===typeof t.call)<span class="cstat-no" title="statement not covered" >return t.apply(i,e)}</span></span>function <span class="fstat-no" title="function not covered" >U(</span>t,e,i,s){let n,o,r;<span class="cstat-no" title="statement not covered" >if(W(t))<span class="cstat-no" title="statement not covered" >if(o=t.length,s)<span class="cstat-no" title="statement not covered" >for(n=o-1;n&gt;=0;n--)<span class="cstat-no" title="statement not covered" >e.call(i,t[n],n);e</span></span>lse <span class="cstat-no" title="statement not covered" >for(n=0;n&lt;o;n++)<span class="cstat-no" title="statement not covered" >e.call(i,t[n],n);e</span></span></span>lse <span class="cstat-no" title="statement not covered" >if(H(t))<span class="cstat-no" title="statement not covered" >for(r=Object.keys(t),o=r.length,n=0;n&lt;o;n++)<span class="cstat-no" title="statement not covered" >e.call(i,t[r[n]],r[n])}</span></span></span></span>function <span class="fstat-no" title="function not covered" >X(</span>t,e){let i,s,n,o;<span class="cstat-no" title="statement not covered" >if(!t||!e||t.length!==e.length)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(i=0,s=t.length;i&lt;s;++i)<span class="cstat-no" title="statement not covered" >if(n=t[i],o=e[i],n.datasetIndex!==o.datasetIndex||n.index!==o.index)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>function <span class="fstat-no" title="function not covered" >q(</span>t){<span class="cstat-no" title="statement not covered" >if(W(t))<span class="cstat-no" title="statement not covered" >return t.map(q);<span class="cstat-no" title="statement not covered" >i</span></span>f(H(t)){const e=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>i=<span class="cstat-no" title="statement not covered" >Object.keys(t),</span>s=<span class="cstat-no" title="statement not covered" >i.length;</span>let n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;n&lt;s;++n)<span class="cstat-no" title="statement not covered" >e[i[n]]=q(t[i[n]]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >K(</span>t){<span class="cstat-no" title="statement not covered" >return-1===["__proto__","prototype","constructor"].indexOf(t)}</span>function <span class="fstat-no" title="function not covered" >J(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >if(!K(t))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >e[t],</span>o=<span class="cstat-no" title="statement not covered" >i[t];<span class="cstat-no" title="statement not covered" ></span>H(n)&amp;&amp;H(o)?G(n,o,s):e[t]=q(o)}</span>function <span class="fstat-no" title="function not covered" >G(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >W(e)?e:[e],</span>n=<span class="cstat-no" title="statement not covered" >s.length;<span class="cstat-no" title="statement not covered" ></span>if(!H(t))<span class="cstat-no" title="statement not covered" >return t;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >(i=i||{}).merger||J;</span>let r;<span class="cstat-no" title="statement not covered" >for(let a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;n;++a){<span class="cstat-no" title="statement not covered" >if(r=s[a],!H(r))<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >Object.keys(r);<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >e.length;</span>s&lt;n;++s)<span class="cstat-no" title="statement not covered" >o(e[s],t,r,i)}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >Z(</span>t,e){<span class="cstat-no" title="statement not covered" >return G(t,e,{merger:Q})}</span>function <span class="fstat-no" title="function not covered" >Q(</span>t,e,i){<span class="cstat-no" title="statement not covered" >if(!K(t))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >e[t],</span>n=<span class="cstat-no" title="statement not covered" >i[t];<span class="cstat-no" title="statement not covered" ></span>H(s)&amp;&amp;H(n)?Z(s,n):Object.prototype.hasOwnProperty.call(e,t)||(e[t]=q(n))}</span>const tt=<span class="cstat-no" title="statement not covered" >{"":<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t,</span>x:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.x,</span>y:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.y}</span>;</span>function <span class="fstat-no" title="function not covered" >et(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >tt[e]||(tt[e]=<span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >t.split("."),</span>i=<span class="cstat-no" title="statement not covered" >[];</span>let s=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>for(const n of e)<span class="cstat-no" title="statement not covered" >s+=n,s.endsWith("\\")?s=s.slice(0,-1)+".":(i.push(s),s="");<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>(t);<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >for(const i of e){<span class="cstat-no" title="statement not covered" >if(""===i)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >t</span></span>=t&amp;&amp;t[i]}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>}</span>(e));<span class="cstat-no" title="statement not covered" ></span>return i(t)}</span>function <span class="fstat-no" title="function not covered" >it(</span>t){<span class="cstat-no" title="statement not covered" >return t.charAt(0).toUpperCase()+t.slice(1)}</span>const st=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"undefined"!==typeof t,</span></span>nt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"function"===typeof t,</span></span>ot=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >if(t.size!==e.size)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(const i of t)<span class="cstat-no" title="statement not covered" >if(!e.has(i))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>;</span>const rt=<span class="cstat-no" title="statement not covered" >Math.PI,</span>at=<span class="cstat-no" title="statement not covered" >2*rt,</span>ht=<span class="cstat-no" title="statement not covered" >at+rt,</span>lt=<span class="cstat-no" title="statement not covered" >Number.POSITIVE_INFINITY,</span>ct=<span class="cstat-no" title="statement not covered" >rt/180,</span>dt=<span class="cstat-no" title="statement not covered" >rt/2,</span>ut=<span class="cstat-no" title="statement not covered" >rt/4,</span>ft=<span class="cstat-no" title="statement not covered" >2*rt/3,</span>gt=<span class="cstat-no" title="statement not covered" >Math.log10,</span>pt=<span class="cstat-no" title="statement not covered" >Math.sign;</span>function <span class="fstat-no" title="function not covered" >xt(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return Math.abs(t-e)&lt;i}</span>function <span class="fstat-no" title="function not covered" >mt(</span>t){const e=<span class="cstat-no" title="statement not covered" >Math.round(t);<span class="cstat-no" title="statement not covered" ></span>t=xt(t,e,t/1e3)?e:t;c</span>onst i=<span class="cstat-no" title="statement not covered" >Math.pow(10,Math.floor(gt(t))),</span>s=<span class="cstat-no" title="statement not covered" >t/i;<span class="cstat-no" title="statement not covered" ></span>return(s&lt;=1?1:s&lt;=2?2:s&lt;=5?5:10)*i}</span>function <span class="fstat-no" title="function not covered" >bt(</span>t){<span class="cstat-no" title="statement not covered" >return!<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"symbol"===typeof t||"object"===typeof t&amp;&amp;null!==t&amp;&amp;!(Symbol.toPrimitive in t||"toString"in t||"valueOf"in t)}</span>(t)&amp;&amp;!isNaN(parseFloat(t))&amp;&amp;isFinite(t)}</span>function <span class="fstat-no" title="function not covered" >_t(</span>t,e,i){let s,n,o;<span class="cstat-no" title="statement not covered" >for(s=0,n=t.length;s&lt;n;s++)<span class="cstat-no" title="statement not covered" >o=t[s][i],isNaN(o)||(e.min=Math.min(e.min,o),e.max=Math.max(e.max,o))}</span></span>function <span class="fstat-no" title="function not covered" >yt(</span>t){<span class="cstat-no" title="statement not covered" >return t*(rt/180)}</span>function <span class="fstat-no" title="function not covered" >vt(</span>t){<span class="cstat-no" title="statement not covered" >return t*(180/rt)}</span>function <span class="fstat-no" title="function not covered" >wt(</span>t){<span class="cstat-no" title="statement not covered" >if(!V(t))<span class="cstat-no" title="statement not covered" >return;l</span></span>et e=<span class="cstat-no" title="statement not covered" >1,</span>i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;Math.round(t*e)/e!==t;)<span class="cstat-no" title="statement not covered" >e*=10,i++;<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>function <span class="fstat-no" title="function not covered" >Mt(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >e.x-t.x,</span>s=<span class="cstat-no" title="statement not covered" >e.y-t.y,</span>n=<span class="cstat-no" title="statement not covered" >Math.sqrt(i*i+s*s);</span>let o=<span class="cstat-no" title="statement not covered" >Math.atan2(s,i);<span class="cstat-no" title="statement not covered" ></span>return o&lt;-.5*rt&amp;&amp;(o+=at),{angle:o,distance:n}}</span>function <span class="fstat-no" title="function not covered" >kt(</span>t,e){<span class="cstat-no" title="statement not covered" >return Math.sqrt(Math.pow(e.x-t.x,2)+Math.pow(e.y-t.y,2))}</span>function <span class="fstat-no" title="function not covered" >St(</span>t,e){<span class="cstat-no" title="statement not covered" >return(t-e+ht)%at-rt}</span>function <span class="fstat-no" title="function not covered" >Pt(</span>t){<span class="cstat-no" title="statement not covered" >return(t%at+at)%at}</span>function <span class="fstat-no" title="function not covered" >Dt(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >Pt(t),</span>o=<span class="cstat-no" title="statement not covered" >Pt(e),</span>r=<span class="cstat-no" title="statement not covered" >Pt(i),</span>a=<span class="cstat-no" title="statement not covered" >Pt(o-n),</span>h=<span class="cstat-no" title="statement not covered" >Pt(r-n),</span>l=<span class="cstat-no" title="statement not covered" >Pt(n-o),</span>c=<span class="cstat-no" title="statement not covered" >Pt(n-r);<span class="cstat-no" title="statement not covered" ></span>return n===o||n===r||s&amp;&amp;o===r||a&gt;h&amp;&amp;l&lt;c}</span>function <span class="fstat-no" title="function not covered" >At(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return Math.max(e,Math.min(i,t))}</span>function <span class="fstat-no" title="function not covered" >Ot(</span>t,e,i,s=<span class="branch-0 cbranch-no" title="branch not covered" >1e-6)</span>{<span class="cstat-no" title="statement not covered" >return t&gt;=Math.min(e,i)-s&amp;&amp;t&lt;=Math.max(e,i)+s}</span>function <span class="fstat-no" title="function not covered" >Ct(</span>t,e,i){<span class="cstat-no" title="statement not covered" >i=i||(<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >t[i]&lt;e)</span>;l</span>et s,n=<span class="cstat-no" title="statement not covered" >t.length-1,</span>o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;n-o&gt;1;)<span class="cstat-no" title="statement not covered" >s=o+n&gt;&gt;1,i(s)?o=s:n=s;<span class="cstat-no" title="statement not covered" >r</span></span>eturn{lo:o,hi:n}}</span>const Tt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i,s)=&gt;<span class="cstat-no" title="statement not covered" >Ct(t,i,s?<span class="fstat-no" title="function not covered" >s=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >t[s][e];<span class="cstat-no" title="statement not covered" ></span>return n&lt;i||n===i&amp;&amp;t[s+1][e]===i}</span>:<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >t[s][e]&lt;i)</span>,</span></span>Rt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >Ct(t,i,(<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >t[s][e]&gt;=i)</span>);</span></span>const It=<span class="cstat-no" title="statement not covered" >["push","pop","shift","splice","unshift"];</span>function <span class="fstat-no" title="function not covered" >Et(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t._chartjs;<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >i.listeners,</span>n=<span class="cstat-no" title="statement not covered" >s.indexOf(e);<span class="cstat-no" title="statement not covered" ></span>-1!==n&amp;&amp;s.splice(n,1),s.length&gt;0||(It.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >delete t[e]}</span>)),delete t._chartjs)}</span>function <span class="fstat-no" title="function not covered" >Lt(</span>t){const e=<span class="cstat-no" title="statement not covered" >new Set(t);<span class="cstat-no" title="statement not covered" ></span>return e.size===t.length?t:Array.from(e)}</span>const zt=<span class="cstat-no" title="statement not covered" >"undefined"===typeof window?<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t()}</span>:window.requestAnimationFrame;</span>function <span class="fstat-no" title="function not covered" >Ft(</span>t,e){let i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(...n){<span class="cstat-no" title="statement not covered" >i=n,s||(s=!0,zt.call(window,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >s=!1,t.apply(e,i)}</span>)))}</span>}</span>const Bt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"start"===t?"left":"end"===t?"right":"center",</span></span>Wt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >"start"===t?e:"end"===t?i:(e+i)/2;</span></span>function <span class="fstat-no" title="function not covered" >Ht(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >e.length;</span>let n=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>if(t._sorted){const{iScale:r,vScale:a,_parsed:h}=<span class="cstat-no" title="statement not covered" >t,</span>l=<span class="cstat-no" title="statement not covered" >t.dataset&amp;&amp;t.dataset.options?t.dataset.options.spanGaps:null,</span>c=<span class="cstat-no" title="statement not covered" >r.axis,</span>{min:d,max:u,minDefined:f,maxDefined:g}=<span class="cstat-no" title="statement not covered" >r.getUserBounds();<span class="cstat-no" title="statement not covered" ></span>if(f){<span class="cstat-no" title="statement not covered" >if(n=Math.min(Tt(h,c,d).lo,i?s:Tt(e,c,r.getPixelForValue(d)).lo),l){const t=<span class="cstat-no" title="statement not covered" >h.slice(0,n+1).reverse().findIndex((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!B(t[a.axis]))</span>);<span class="cstat-no" title="statement not covered" ></span>n-=Math.max(0,t)}<span class="cstat-no" title="statement not covered" ></span>n</span>=At(n,0,s-1)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(g){let t=<span class="cstat-no" title="statement not covered" >Math.max(Tt(h,r.axis,u,!0).hi+1,i?0:Tt(e,c,r.getPixelForValue(u),!0).hi+1);<span class="cstat-no" title="statement not covered" ></span>if(l){const e=<span class="cstat-no" title="statement not covered" >h.slice(t-1).findIndex((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!B(t[a.axis]))</span>);<span class="cstat-no" title="statement not covered" ></span>t+=Math.max(0,e)}<span class="cstat-no" title="statement not covered" ></span>o</span>=At(t,n,s)-n}</span>else <span class="cstat-no" title="statement not covered" >o=s-n}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn{start:n,count:o}}</span>function <span class="fstat-no" title="function not covered" >Vt(</span>t){const{xScale:e,yScale:i,_scaleRanges:s}=<span class="cstat-no" title="statement not covered" >t,</span>n=<span class="cstat-no" title="statement not covered" >{xmin:e.min,xmax:e.max,ymin:i.min,ymax:i.max};<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return t._scaleRanges=n,!0;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >s.xmin!==e.min||s.xmax!==e.max||s.ymin!==i.min||s.ymax!==i.max;<span class="cstat-no" title="statement not covered" ></span>return Object.assign(s,n),o}</span>const jt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >0===t||1===t,</span></span>Nt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >-Math.pow(2,10*(t-=1))*Math.sin((t-e)*at/i),</span></span>$t=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >Math.pow(2,-10*t)*Math.sin((t-e)*at/i)+1,</span></span>Yt=<span class="cstat-no" title="statement not covered" >{linear:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t,</span>easeInQuad:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t*t,</span>easeOutQuad:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >-t*(t-2),</span>easeInOutQuad:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(t/=.5)&lt;1?.5*t*t:-.5*(--t*(t-2)-1),</span>easeInCubic:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t*t*t,</span>easeOutCubic:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(t-=1)*t*t+1,</span>easeInOutCubic:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(t/=.5)&lt;1?.5*t*t*t:.5*((t-=2)*t*t+2),</span>easeInQuart:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t*t*t*t,</span>easeOutQuart:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >-((t-=1)*t*t*t-1),</span>easeInOutQuart:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(t/=.5)&lt;1?.5*t*t*t*t:-.5*((t-=2)*t*t*t-2),</span>easeInQuint:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t*t*t*t*t,</span>easeOutQuint:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(t-=1)*t*t*t*t+1,</span>easeInOutQuint:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(t/=.5)&lt;1?.5*t*t*t*t*t:.5*((t-=2)*t*t*t*t+2),</span>easeInSine:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >1-Math.cos(t*dt),</span>easeOutSine:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Math.sin(t*dt),</span>easeInOutSine:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >-.5*(Math.cos(rt*t)-1),</span>easeInExpo:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >0===t?0:Math.pow(2,10*(t-1)),</span>easeOutExpo:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >1===t?1:1-Math.pow(2,-10*t),</span>easeInOutExpo:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >jt(t)?t:t&lt;.5?.5*Math.pow(2,10*(2*t-1)):.5*(2-Math.pow(2,-10*(2*t-1))),</span>easeInCirc:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t&gt;=1?t:-(Math.sqrt(1-t*t)-1),</span>easeOutCirc:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Math.sqrt(1-(t-=1)*t),</span>easeInOutCirc:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(t/=.5)&lt;1?-.5*(Math.sqrt(1-t*t)-1):.5*(Math.sqrt(1-(t-=2)*t)+1),</span>easeInElastic:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >jt(t)?t:Nt(t,.075,.3),</span>easeOutElastic:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >jt(t)?t:$t(t,.075,.3),<span class="fstat-no" title="function not covered" ></span>ea</span>seInOutElastic(t){const e=<span class="cstat-no" title="statement not covered" >.1125;<span class="cstat-no" title="statement not covered" ></span>return jt(t)?t:t&lt;.5?.5*Nt(2*t,e,.45):.5+.5*$t(2*t-1,e,.45)}</span>,<span class="fstat-no" title="function not covered" >ea</span>seInBack(t){const e=<span class="cstat-no" title="statement not covered" >1.70158;<span class="cstat-no" title="statement not covered" ></span>return t*t*((e+1)*t-e)}</span>,<span class="fstat-no" title="function not covered" >ea</span>seOutBack(t){const e=<span class="cstat-no" title="statement not covered" >1.70158;<span class="cstat-no" title="statement not covered" ></span>return(t-=1)*t*((e+1)*t+e)+1}</span>,<span class="fstat-no" title="function not covered" >ea</span>seInOutBack(t){let e=<span class="cstat-no" title="statement not covered" >1.70158;<span class="cstat-no" title="statement not covered" ></span>return(t/=.5)&lt;1?t*t*((1+(e*=1.525))*t-e)*.5:.5*((t-=2)*t*((1+(e*=1.525))*t+e)+2)}</span>,easeInBounce:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >1-Yt.easeOutBounce(1-t),<span class="fstat-no" title="function not covered" ></span>ea</span>seOutBounce(t){const e=<span class="cstat-no" title="statement not covered" >7.5625,</span>i=<span class="cstat-no" title="statement not covered" >2.75;<span class="cstat-no" title="statement not covered" ></span>return t&lt;1/i?e*t*t:t&lt;2/i?e*(t-=1.5/i)*t+.75:t&lt;2.5/i?e*(t-=2.25/i)*t+.9375:e*(t-=2.625/i)*t+.984375}</span>,easeInOutBounce:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t&lt;.5?.5*Yt.easeInBounce(2*t):.5*Yt.easeOutBounce(2*t-1)+.5}</span>;</span>function <span class="fstat-no" title="function not covered" >Ut(</span>t){<span class="cstat-no" title="statement not covered" >if(t&amp;&amp;"object"===typeof t){const e=<span class="cstat-no" title="statement not covered" >t.toString();<span class="cstat-no" title="statement not covered" ></span>return"[object CanvasPattern]"===e||"[object CanvasGradient]"===e}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>function <span class="fstat-no" title="function not covered" >Xt(</span>t){<span class="cstat-no" title="statement not covered" >return Ut(t)?t:new L(t)}</span>function <span class="fstat-no" title="function not covered" >qt(</span>t){<span class="cstat-no" title="statement not covered" >return Ut(t)?t:new L(t).saturate(.5).darken(.1).hexString()}</span>const Kt=<span class="cstat-no" title="statement not covered" >["x","y","borderWidth","radius","tension"],</span>Jt=<span class="cstat-no" title="statement not covered" >["color","borderColor","backgroundColor"];</span>const Gt=<span class="cstat-no" title="statement not covered" >new Map;</span>function <span class="fstat-no" title="function not covered" >Zt(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >e=e||{};c</span>onst i=<span class="cstat-no" title="statement not covered" >t+JSON.stringify(e);</span>let s=<span class="cstat-no" title="statement not covered" >Gt.get(i);<span class="cstat-no" title="statement not covered" ></span>return s||(s=new Intl.NumberFormat(t,e),Gt.set(i,s)),s}</span>(e,i).format(t)}</span>const Qt=<span class="cstat-no" title="statement not covered" >{values:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >W(t)?t:""+t,<span class="fstat-no" title="function not covered" ></span>nu</span>meric(t,e,i){<span class="cstat-no" title="statement not covered" >if(0===t)<span class="cstat-no" title="statement not covered" >return"0";c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this.chart.options.locale;</span>let n,o=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if(i.length&gt;1){const e=<span class="cstat-no" title="statement not covered" >Math.max(Math.abs(i[0].value),Math.abs(i[i.length-1].value));<span class="cstat-no" title="statement not covered" ></span>(e&lt;1e-4||e&gt;1e15)&amp;&amp;(n="scientific"),o=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){let i=<span class="cstat-no" title="statement not covered" >e.length&gt;3?e[2].value-e[1].value:e[1].value-e[0].value;<span class="cstat-no" title="statement not covered" ></span>Math.abs(i)&gt;=1&amp;&amp;t!==Math.floor(t)&amp;&amp;(i=t-Math.floor(t));<span class="cstat-no" title="statement not covered" >r</span>eturn i}</span>(t,i)}</span>c</span>onst r=<span class="cstat-no" title="statement not covered" >gt(Math.abs(o)),</span>a=<span class="cstat-no" title="statement not covered" >isNaN(r)?1:Math.max(Math.min(-1*Math.floor(r),20),0),</span>h=<span class="cstat-no" title="statement not covered" >{notation:n,minimumFractionDigits:a,maximumFractionDigits:a};<span class="cstat-no" title="statement not covered" ></span>return Object.assign(h,this.options.ticks.format),Zt(t,s,h)}</span>,<span class="fstat-no" title="function not covered" >lo</span>garithmic(t,e,i){<span class="cstat-no" title="statement not covered" >if(0===t)<span class="cstat-no" title="statement not covered" >return"0";c</span></span>onst s=<span class="cstat-no" title="statement not covered" >i[e].significand||t/Math.pow(10,Math.floor(gt(t)));<span class="cstat-no" title="statement not covered" ></span>return[1,2,3,5,10,15].includes(s)||e&gt;.8*i.length?Qt.numeric.call(this,t,e,i):""}</span>};</span>var te=<span class="cstat-no" title="statement not covered" >{formatters:Qt};</span>const ee=<span class="cstat-no" title="statement not covered" >Object.create(null),</span>ie=<span class="cstat-no" title="statement not covered" >Object.create(null);</span>function <span class="fstat-no" title="function not covered" >se(</span>t,e){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return t;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >e.split(".");<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >i.length;</span>s&lt;n;++s){const e=<span class="cstat-no" title="statement not covered" >i[s];<span class="cstat-no" title="statement not covered" ></span>t=t[e]||(t[e]=Object.create(null))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}</span>function <span class="fstat-no" title="function not covered" >ne(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return"string"===typeof e?G(se(t,e),i):G(se(t,""),e)}</span>class oe{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >this.animation=void 0,this.backgroundColor="rgba(0,0,0,0.1)",this.borderColor="rgba(0,0,0,0.1)",this.color="#666",this.datasets={},this.devicePixelRatio=<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.chart.platform.getDevicePixelRatio(),</span>this.elements={},this.events=["mousemove","mouseout","click","touchstart","touchmove"],this.font={family:"'Helvetica Neue', 'Helvetica', 'Arial', sans-serif",size:12,style:"normal",lineHeight:1.2,weight:null},this.hover={},this.hoverBackgroundColor=<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >qt(e.backgroundColor),</span>this.hoverBorderColor=<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >qt(e.borderColor),</span>this.hoverColor=<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >qt(e.color),</span>this.indexAxis="x",this.interaction={mode:"nearest",intersect:!0,includeInvisible:!1},this.maintainAspectRatio=!0,this.onHover=null,this.onClick=null,this.parsing=!0,this.plugins={},this.responsive=!0,this.scale=void 0,this.scales={},this.showLine=!0,this.drawActiveElementsOnTop=!0,this.describe(t),this.apply(e)}<span class="fstat-no" title="function not covered" ></span>se</span>t(t,e){<span class="cstat-no" title="statement not covered" >return ne(this,t,e)}<span class="fstat-no" title="function not covered" ></span>ge</span>t(t){<span class="cstat-no" title="statement not covered" >return se(this,t)}<span class="fstat-no" title="function not covered" ></span>de</span>scribe(t,e){<span class="cstat-no" title="statement not covered" >return ne(ie,t,e)}<span class="fstat-no" title="function not covered" ></span>ov</span>erride(t,e){<span class="cstat-no" title="statement not covered" >return ne(ee,t,e)}<span class="fstat-no" title="function not covered" ></span>ro</span>ute(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >se(this,t),</span>o=<span class="cstat-no" title="statement not covered" >se(this,i),</span>r=<span class="cstat-no" title="statement not covered" >"_"+e;<span class="cstat-no" title="statement not covered" ></span>Object.defineProperties(n,{[r]:{value:n[e],writable:!0},[e]:{enumerable:!0,<span class="fstat-no" title="function not covered" >ge</span>t(){const t=<span class="cstat-no" title="statement not covered" >this[r],</span>e=<span class="cstat-no" title="statement not covered" >o[s];<span class="cstat-no" title="statement not covered" ></span>return H(t)?Object.assign({},e,t):N(t,e)}</span>,<span class="fstat-no" title="function not covered" >se</span>t(t){<span class="cstat-no" title="statement not covered" >this[r]=t}</span>}})}<span class="fstat-no" title="function not covered" ></span>ap</span>ply(t){<span class="cstat-no" title="statement not covered" >t.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t(this))</span>)}</span>}var re=<span class="cstat-no" title="statement not covered" >new oe({_scriptable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!t.startsWith("on"),</span>_indexable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"events"!==t,</span>hover:{_fallback:"interaction"},interaction:{_scriptable:!1,_indexable:!1}},[<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.set("animation",{delay:void 0,duration:1e3,easing:"easeOutQuart",fn:void 0,from:void 0,loop:void 0,to:void 0,type:void 0}),t.describe("animation",{_fallback:!1,_indexable:!1,_scriptable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"onProgress"!==t&amp;&amp;"onComplete"!==t&amp;&amp;"fn"!==t}</span>),t.set("animations",{colors:{type:"color",properties:Jt},numbers:{type:"number",properties:Kt}}),t.describe("animations",{_fallback:"animation"}),t.set("transitions",{active:{animation:{duration:400}},resize:{animation:{duration:0}},show:{animations:{colors:{from:"transparent"},visible:{type:"boolean",duration:0}}},hide:{animations:{colors:{to:"transparent"},visible:{type:"boolean",easing:"linear",fn:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >0|t}</span>}}})}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.set("layout",{autoPadding:!0,padding:{top:0,right:0,bottom:0,left:0}})}</span>,<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >t.set("scale",{display:!0,offset:!1,reverse:!1,beginAtZero:!1,bounds:"ticks",clip:!0,grace:0,grid:{display:!0,lineWidth:1,drawOnChartArea:!0,drawTicks:!0,tickLength:8,tickWidth:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e.lineWidth,</span>tickColor:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e.color,</span>offset:!1},border:{display:!0,dash:[],dashOffset:0,width:1},title:{display:!1,text:"",padding:{top:4,bottom:4}},ticks:{minRotation:0,maxRotation:50,mirror:!1,textStrokeWidth:0,textStrokeColor:"",padding:3,display:!0,autoSkip:!0,autoSkipPadding:3,labelOffset:0,callback:te.formatters.values,minor:{},major:{},align:"center",crossAlign:"near",showLabelBackdrop:!1,backdropColor:"rgba(255, 255, 255, 0.75)",backdropPadding:2}}),t.route("scale.ticks","color","","color"),t.route("scale.grid","color","","borderColor"),t.route("scale.border","color","","borderColor"),t.route("scale.title","color","","color"),t.describe("scale",{_fallback:!1,_scriptable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!t.startsWith("before")&amp;&amp;!t.startsWith("after")&amp;&amp;"callback"!==t&amp;&amp;"parser"!==t,</span>_indexable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"borderDash"!==t&amp;&amp;"tickBorderDash"!==t&amp;&amp;"dash"!==t}</span>),t.describe("scales",{_fallback:"scale"}),t.describe("scale.ticks",{_scriptable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"backdropPadding"!==t&amp;&amp;"callback"!==t,</span>_indexable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"backdropPadding"!==t}</span>)}</span>]);</span>function <span class="fstat-no" title="function not covered" >ae(</span>t,e,i,s,n){let o=<span class="cstat-no" title="statement not covered" >e[n];<span class="cstat-no" title="statement not covered" ></span>return o||(o=e[n]=t.measureText(n).width,i.push(n)),o&gt;s&amp;&amp;(s=o),s}</span>function <span class="fstat-no" title="function not covered" >he(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.currentDevicePixelRatio,</span>n=<span class="cstat-no" title="statement not covered" >0!==i?Math.max(i/2,.5):0;<span class="cstat-no" title="statement not covered" ></span>return Math.round((e-n)*s)/s+n}</span>function <span class="fstat-no" title="function not covered" >le(</span>t,e){<span class="cstat-no" title="statement not covered" >(e||t)&amp;&amp;((e=e||t.getContext("2d")).save(),e.resetTransform(),e.clearRect(0,0,t.width,t.height),e.restore())}</span>function <span class="fstat-no" title="function not covered" >ce(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >de(t,e,i,s,null)}</span>function <span class="fstat-no" title="function not covered" >de(</span>t,e,i,s,n){let o,r,a,h,l,c,d,u;const f=<span class="cstat-no" title="statement not covered" >e.pointStyle,</span>g=<span class="cstat-no" title="statement not covered" >e.rotation,</span>p=<span class="cstat-no" title="statement not covered" >e.radius;</span>let x=<span class="cstat-no" title="statement not covered" >(g||0)*ct;<span class="cstat-no" title="statement not covered" ></span>if(f&amp;&amp;"object"===typeof f&amp;&amp;(o=f.toString(),"[object HTMLImageElement]"===o||"[object HTMLCanvasElement]"===o))<span class="cstat-no" title="statement not covered" >return t.save(),t.translate(i,s),t.rotate(x),t.drawImage(f,-f.width/2,-f.height/2,f.width,f.height),void t.restore();<span class="cstat-no" title="statement not covered" >i</span></span>f(!(isNaN(p)||p&lt;=0)){<span class="cstat-no" title="statement not covered" >switch(t.beginPath(),f){default:<span class="cstat-no" title="statement not covered" >n?t.ellipse(i,s,n/2,p,0,0,at):t.arc(i,s,p,0,at),t.closePath();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"triangle":<span class="cstat-no" title="statement not covered" >c=n?n/2:p,t.moveTo(i+Math.sin(x)*c,s-Math.cos(x)*p),x+=ft,t.lineTo(i+Math.sin(x)*c,s-Math.cos(x)*p),x+=ft,t.lineTo(i+Math.sin(x)*c,s-Math.cos(x)*p),t.closePath();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"rectRounded":<span class="cstat-no" title="statement not covered" >l=.516*p,h=p-l,r=Math.cos(x+ut)*h,d=Math.cos(x+ut)*(n?n/2-l:h),a=Math.sin(x+ut)*h,u=Math.sin(x+ut)*(n?n/2-l:h),t.arc(i-d,s-a,l,x-rt,x-dt),t.arc(i+u,s-r,l,x-dt,x),t.arc(i+d,s+a,l,x,x+dt),t.arc(i-u,s+r,l,x+dt,x+rt),t.closePath();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"rect":<span class="cstat-no" title="statement not covered" >if(!g){<span class="cstat-no" title="statement not covered" >h=Math.SQRT1_2*p,c=n?n/2:h,t.rect(i-c,s-h,2*c,2*h);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>x</span>+=ut;c</span>ase"rectRot":<span class="cstat-no" title="statement not covered" >d=Math.cos(x)*(n?n/2:p),r=Math.cos(x)*p,a=Math.sin(x)*p,u=Math.sin(x)*(n?n/2:p),t.moveTo(i-d,s-a),t.lineTo(i+u,s-r),t.lineTo(i+d,s+a),t.lineTo(i-u,s+r),t.closePath();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"crossRot":<span class="cstat-no" title="statement not covered" >x+=ut;c</span>ase"cross":<span class="cstat-no" title="statement not covered" >d=Math.cos(x)*(n?n/2:p),r=Math.cos(x)*p,a=Math.sin(x)*p,u=Math.sin(x)*(n?n/2:p),t.moveTo(i-d,s-a),t.lineTo(i+d,s+a),t.moveTo(i+u,s-r),t.lineTo(i-u,s+r);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"star":<span class="cstat-no" title="statement not covered" >d=Math.cos(x)*(n?n/2:p),r=Math.cos(x)*p,a=Math.sin(x)*p,u=Math.sin(x)*(n?n/2:p),t.moveTo(i-d,s-a),t.lineTo(i+d,s+a),t.moveTo(i+u,s-r),t.lineTo(i-u,s+r),x+=ut,d=Math.cos(x)*(n?n/2:p),r=Math.cos(x)*p,a=Math.sin(x)*p,u=Math.sin(x)*(n?n/2:p),t.moveTo(i-d,s-a),t.lineTo(i+d,s+a),t.moveTo(i+u,s-r),t.lineTo(i-u,s+r);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"line":<span class="cstat-no" title="statement not covered" >r=n?n/2:Math.cos(x)*p,a=Math.sin(x)*p,t.moveTo(i-r,s-a),t.lineTo(i+r,s+a);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"dash":<span class="cstat-no" title="statement not covered" >t.moveTo(i,s),t.lineTo(i+Math.cos(x)*(n?n/2:p),s+Math.sin(x)*p);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase!1:<span class="cstat-no" title="statement not covered" >t.closePath()}<span class="cstat-no" title="statement not covered" ></span>t</span>.fill(),e.borderWidth&gt;0&amp;&amp;t.stroke()}</span>}</span>function <span class="fstat-no" title="function not covered" >ue(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return i=i||.5,!e||t&amp;&amp;t.x&gt;e.left-i&amp;&amp;t.x&lt;e.right+i&amp;&amp;t.y&gt;e.top-i&amp;&amp;t.y&lt;e.bottom+i}</span>function <span class="fstat-no" title="function not covered" >fe(</span>t,e){<span class="cstat-no" title="statement not covered" >t.save(),t.beginPath(),t.rect(e.left,e.top,e.right-e.left,e.bottom-e.top),t.clip()}</span>function <span class="fstat-no" title="function not covered" >ge(</span>t){<span class="cstat-no" title="statement not covered" >t.restore()}</span>function <span class="fstat-no" title="function not covered" >pe(</span>t,e,i,s,n){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return t.lineTo(i.x,i.y);<span class="cstat-no" title="statement not covered" >i</span></span>f("middle"===n){const s=<span class="cstat-no" title="statement not covered" >(e.x+i.x)/2;<span class="cstat-no" title="statement not covered" ></span>t.lineTo(s,e.y),t.lineTo(s,i.y)}</span>else<span class="cstat-no" title="statement not covered" >"after"===n!==!!s?t.lineTo(e.x,i.y):t.lineTo(i.x,e.y);<span class="cstat-no" title="statement not covered" >t</span></span>.lineTo(i.x,i.y)}</span>function <span class="fstat-no" title="function not covered" >xe(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return t.lineTo(i.x,i.y);<span class="cstat-no" title="statement not covered" >t</span></span>.bezierCurveTo(s?e.cp1x:e.cp2x,s?e.cp1y:e.cp2y,s?i.cp2x:i.cp1x,s?i.cp2y:i.cp1y,i.x,i.y)}</span>function <span class="fstat-no" title="function not covered" >me(</span>t,e,i,s,n){<span class="cstat-no" title="statement not covered" >if(n.strikethrough||n.underline){const o=<span class="cstat-no" title="statement not covered" >t.measureText(s),</span>r=<span class="cstat-no" title="statement not covered" >e-o.actualBoundingBoxLeft,</span>a=<span class="cstat-no" title="statement not covered" >e+o.actualBoundingBoxRight,</span>h=<span class="cstat-no" title="statement not covered" >i-o.actualBoundingBoxAscent,</span>l=<span class="cstat-no" title="statement not covered" >i+o.actualBoundingBoxDescent,</span>c=<span class="cstat-no" title="statement not covered" >n.strikethrough?(h+l)/2:l;<span class="cstat-no" title="statement not covered" ></span>t.strokeStyle=t.fillStyle,t.beginPath(),t.lineWidth=n.decorationWidth||2,t.moveTo(r,c),t.lineTo(a,c),t.stroke()}</span>}</span>function <span class="fstat-no" title="function not covered" >be(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t.fillStyle;<span class="cstat-no" title="statement not covered" ></span>t.fillStyle=e.color,t.fillRect(e.left,e.top,e.width,e.height),t.fillStyle=i}</span>function <span class="fstat-no" title="function not covered" >_e(</span>t,e,i,s,n,o=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const r=<span class="cstat-no" title="statement not covered" >W(e)?e:[e],</span>a=<span class="cstat-no" title="statement not covered" >o.strokeWidth&gt;0&amp;&amp;""!==o.strokeColor;</span>let h,l;<span class="cstat-no" title="statement not covered" >for(t.save(),t.font=n.string,<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >e.translation&amp;&amp;t.translate(e.translation[0],e.translation[1]),B(e.rotation)||t.rotate(e.rotation),e.color&amp;&amp;(t.fillStyle=e.color),e.textAlign&amp;&amp;(t.textAlign=e.textAlign),e.textBaseline&amp;&amp;(t.textBaseline=e.textBaseline)}</span>(t,o),h=0;h&lt;r.length;++h)<span class="cstat-no" title="statement not covered" >l=r[h],o.backdrop&amp;&amp;be(t,o.backdrop),a&amp;&amp;(o.strokeColor&amp;&amp;(t.strokeStyle=o.strokeColor),B(o.strokeWidth)||(t.lineWidth=o.strokeWidth),t.strokeText(l,i,s,o.maxWidth)),t.fillText(l,i,s,o.maxWidth),me(t,i,s,l,o),s+=Number(n.lineHeight);<span class="cstat-no" title="statement not covered" >t</span></span>.restore()}</span>function <span class="fstat-no" title="function not covered" >ye(</span>t,e){const{x:i,y:s,w:n,h:o,radius:r}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>t.arc(i+r.topLeft,s+r.topLeft,r.topLeft,1.5*rt,rt,!0),t.lineTo(i,s+o-r.bottomLeft),t.arc(i+r.bottomLeft,s+o-r.bottomLeft,r.bottomLeft,rt,dt,!0),t.lineTo(i+n-r.bottomRight,s+o),t.arc(i+n-r.bottomRight,s+o-r.bottomRight,r.bottomRight,dt,0,!0),t.lineTo(i+n,s+r.topRight),t.arc(i+n-r.topRight,s+r.topRight,r.topRight,0,-dt,!0),t.lineTo(i+r.topLeft,s)}</span>const ve=<span class="cstat-no" title="statement not covered" >/^(normal|(\d+(?:\.\d+)?)(px|em|%)?)$/,</span>we=<span class="cstat-no" title="statement not covered" >/^(normal|italic|initial|inherit|unset|(oblique( -?[0-9]?[0-9]deg)?))$/;</span>function <span class="fstat-no" title="function not covered" >Me(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >(""+t).match(ve);<span class="cstat-no" title="statement not covered" ></span>if(!i||"normal"===i[1])<span class="cstat-no" title="statement not covered" >return 1.2*e;<span class="cstat-no" title="statement not covered" >s</span></span>witch(t=+i[2],i[3]){case"px":<span class="cstat-no" title="statement not covered" >return t;c</span>ase"%":<span class="cstat-no" title="statement not covered" >t/=100}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e*t}</span>function <span class="fstat-no" title="function not covered" >ke(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >{},</span>s=<span class="cstat-no" title="statement not covered" >H(e),</span>n=<span class="cstat-no" title="statement not covered" >s?Object.keys(e):e,</span>o=<span class="cstat-no" title="statement not covered" >H(t)?s?<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >N(t[i],t[e[i]]):<span class="fstat-no" title="function not covered" ></span>e=</span>&gt;<span class="cstat-no" title="statement not covered" >t[e]:<span class="fstat-no" title="function not covered" ></span>()</span>=&gt;<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span></span>for(const r of n)<span class="cstat-no" title="statement not covered" >i[r]=+o(r)||0;<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>function <span class="fstat-no" title="function not covered" >Se(</span>t){<span class="cstat-no" title="statement not covered" >return ke(t,{top:"y",right:"x",bottom:"y",left:"x"})}</span>function <span class="fstat-no" title="function not covered" >Pe(</span>t){<span class="cstat-no" title="statement not covered" >return ke(t,["topLeft","topRight","bottomLeft","bottomRight"])}</span>function <span class="fstat-no" title="function not covered" >De(</span>t){const e=<span class="cstat-no" title="statement not covered" >Se(t);<span class="cstat-no" title="statement not covered" ></span>return e.width=e.left+e.right,e.height=e.top+e.bottom,e}</span>function <span class="fstat-no" title="function not covered" >Ae(</span>t,e){<span class="cstat-no" title="statement not covered" >t=t||{},e=e||re.font;l</span>et i=<span class="cstat-no" title="statement not covered" >N(t.size,e.size);<span class="cstat-no" title="statement not covered" ></span>"string"===typeof i&amp;&amp;(i=parseInt(i,10));l</span>et s=<span class="cstat-no" title="statement not covered" >N(t.style,e.style);<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;!(""+s).match(we)&amp;&amp;(console.warn('Invalid font style specified: "'+s+'"'),s=void 0);c</span>onst n=<span class="cstat-no" title="statement not covered" >{family:N(t.family,e.family),lineHeight:Me(N(t.lineHeight,e.lineHeight),i),size:i,style:s,weight:N(t.weight,e.weight),string:""};<span class="cstat-no" title="statement not covered" ></span>return n.string=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return!t||B(t.size)||B(t.family)?null:(t.style?t.style+" ":"")+(t.weight?t.weight+" ":"")+t.size+"px "+t.family}</span>(n),n}</span>function <span class="fstat-no" title="function not covered" >Oe(</span>t,e,i,s){let n,o,r,a=<span class="cstat-no" title="statement not covered" >!0;<span class="cstat-no" title="statement not covered" ></span>for(n=0,o=t.length;n&lt;o;++n)<span class="cstat-no" title="statement not covered" >if(r=t[n],void 0!==r&amp;&amp;(void 0!==e&amp;&amp;"function"===typeof r&amp;&amp;(r=r(e),a=!1),void 0!==i&amp;&amp;W(r)&amp;&amp;(r=r[i%r.length],a=!1),void 0!==r))<span class="cstat-no" title="statement not covered" >return s&amp;&amp;!a&amp;&amp;(s.cacheable=!1),r}</span></span></span>function <span class="fstat-no" title="function not covered" >Ce(</span>t,e){<span class="cstat-no" title="statement not covered" >return Object.assign(Object.create(t),e)}</span>function <span class="fstat-no" title="function not covered" >Te(</span>t,e=<span class="branch-0 cbranch-no" title="branch not covered" >[""],</span>i,s,n=(<span class="fstat-no" title="function not covered" ><span class="branch-0 cbranch-no" title="branch not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t[0])</span></span>){const o=<span class="cstat-no" title="statement not covered" >i||t;<span class="cstat-no" title="statement not covered" ></span>"undefined"===typeof s&amp;&amp;(s=je("_fallback",t));c</span>onst r=<span class="cstat-no" title="statement not covered" >{[Symbol.toStringTag]:"Object",_cacheable:!0,_scopes:t,_rootScopes:o,_fallback:s,_getTarget:n,override:<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >Te([i,...t],e,o,s)}</span>;<span class="cstat-no" title="statement not covered" ></span>return new Proxy(r,{deleteProperty:<span class="fstat-no" title="function not covered" >(e</span>,i)=&gt;(<span class="cstat-no" title="statement not covered" >delete e[i],delete e._keys,delete t[0][i],!0)</span>,get:<span class="fstat-no" title="function not covered" >(i</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >ze(i,s,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){let n;<span class="cstat-no" title="statement not covered" >for(const o of e)<span class="cstat-no" title="statement not covered" >if(n=je(Ee(o,t),i),"undefined"!==typeof n)<span class="cstat-no" title="statement not covered" >return Le(t,n)?He(i,s,t,n):n}</span></span></span>(s,e,t,i))</span>),</span>getOwnPropertyDescriptor:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >Reflect.getOwnPropertyDescriptor(t._scopes[0],e),</span>getPrototypeOf:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Reflect.getPrototypeOf(t[0]),</span>has:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >Ne(t).includes(e),</span>ownKeys:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Ne(t),<span class="fstat-no" title="function not covered" ></span>se</span>t(t,e,i){const s=<span class="cstat-no" title="statement not covered" >t._storage||(t._storage=n());<span class="cstat-no" title="statement not covered" ></span>return t[e]=s[e]=i,delete t._keys,!0}</span>})}</span>function <span class="fstat-no" title="function not covered" >Re(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >{_cacheable:!1,_proxy:t,_context:e,_subProxy:i,_stack:new Set,_descriptors:Ie(t,s),setContext:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >Re(t,e,i,s),</span>override:<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >Re(t.override(n),e,i,s)}</span>;<span class="cstat-no" title="statement not covered" ></span>return new Proxy(n,{deleteProperty:<span class="fstat-no" title="function not covered" >(e</span>,i)=&gt;(<span class="cstat-no" title="statement not covered" >delete e[i],delete t[i],!0)</span>,get:<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >ze(t,e,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const{_proxy:s,_context:n,_subProxy:o,_descriptors:r}=<span class="cstat-no" title="statement not covered" >t;</span>let a=<span class="cstat-no" title="statement not covered" >s[e];<span class="cstat-no" title="statement not covered" ></span>nt(a)&amp;&amp;r.isScriptable(e)&amp;&amp;(a=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const{_proxy:n,_context:o,_subProxy:r,_stack:a}=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>if(a.has(t))<span class="cstat-no" title="statement not covered" >throw new Error("Recursion detected: "+Array.from(a).join("-&gt;")+"-&gt;"+t);<span class="cstat-no" title="statement not covered" >a</span></span>.add(t);l</span>et h=<span class="cstat-no" title="statement not covered" >e(o,r||s);<span class="cstat-no" title="statement not covered" ></span>a.delete(t),Le(t,h)&amp;&amp;(h=He(n._scopes,n,t,h));<span class="cstat-no" title="statement not covered" >r</span>eturn h}</span>(e,a,t,i));<span class="cstat-no" title="statement not covered" >W</span>(a)&amp;&amp;a.length&amp;&amp;(a=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const{_proxy:n,_context:o,_subProxy:r,_descriptors:a}=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>if("undefined"!==typeof o.index&amp;&amp;s(t))<span class="cstat-no" title="statement not covered" >return e[o.index%e.length];<span class="cstat-no" title="statement not covered" >i</span></span>f(H(e[0])){const i=<span class="cstat-no" title="statement not covered" >e,</span>s=<span class="cstat-no" title="statement not covered" >n._scopes.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t!==i)</span>);<span class="cstat-no" title="statement not covered" ></span>e=[];<span class="cstat-no" title="statement not covered" >f</span>or(const h of i){const i=<span class="cstat-no" title="statement not covered" >He(s,n,t,h);<span class="cstat-no" title="statement not covered" ></span>e.push(Re(i,o,r&amp;&amp;r[t],a))}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>(e,a,t,r.isIndexable));<span class="cstat-no" title="statement not covered" >L</span>e(e,a)&amp;&amp;(a=Re(a,n,o&amp;&amp;o[e],r));<span class="cstat-no" title="statement not covered" >r</span>eturn a}</span>(t,e,i))</span>),</span>getOwnPropertyDescriptor:<span class="fstat-no" title="function not covered" >(e</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >e._descriptors.allKeys?Reflect.has(t,i)?{enumerable:!0,configurable:!0}:void 0:Reflect.getOwnPropertyDescriptor(t,i),</span>getPrototypeOf:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Reflect.getPrototypeOf(t),</span>has:<span class="fstat-no" title="function not covered" >(e</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >Reflect.has(t,i),</span>ownKeys:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Reflect.ownKeys(t),</span>set:<span class="fstat-no" title="function not covered" >(e</span>,i,s)=&gt;(<span class="cstat-no" title="statement not covered" >t[i]=s,delete e[i],!0)</span>})}</span>function <span class="fstat-no" title="function not covered" >Ie(</span>t,e=<span class="branch-0 cbranch-no" title="branch not covered" >{scriptable:!0,indexable:!0})</span>{const{_scriptable:i=<span class="branch-0 cbranch-no" title="branch not covered" >e.scriptable,</span>_indexable:s=<span class="branch-0 cbranch-no" title="branch not covered" >e.indexable,</span>_allKeys:n=<span class="branch-0 cbranch-no" title="branch not covered" >e.allKeys}</span>=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return{allKeys:n,scriptable:i,indexable:s,isScriptable:nt(i)?i:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >i,</span>isIndexable:nt(s)?s:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >s}</span>}</span>const Ee=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t?t+it(e):e,</span></span>Le=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >H(e)&amp;&amp;"adapters"!==t&amp;&amp;(null===Object.getPrototypeOf(e)||e.constructor===Object);</span></span>function <span class="fstat-no" title="function not covered" >ze(</span>t,e,i){<span class="cstat-no" title="statement not covered" >if(Object.prototype.hasOwnProperty.call(t,e)||"constructor"===e)<span class="cstat-no" title="statement not covered" >return t[e];c</span></span>onst s=<span class="cstat-no" title="statement not covered" >i();<span class="cstat-no" title="statement not covered" ></span>return t[e]=s,s}</span>function <span class="fstat-no" title="function not covered" >Fe(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return nt(t)?t(e,i):t}</span>const Be=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >!0===t?e:"string"===typeof t?et(e,t):void 0;</span></span>function <span class="fstat-no" title="function not covered" >We(</span>t,e,i,s,n){<span class="cstat-no" title="statement not covered" >for(const o of e){const e=<span class="cstat-no" title="statement not covered" >Be(i,o);<span class="cstat-no" title="statement not covered" ></span>if(e){<span class="cstat-no" title="statement not covered" >t.add(e);c</span>onst o=<span class="cstat-no" title="statement not covered" >Fe(e._fallback,i,n);<span class="cstat-no" title="statement not covered" ></span>if("undefined"!==typeof o&amp;&amp;o!==i&amp;&amp;o!==s)<span class="cstat-no" title="statement not covered" >return o}</span></span>else <span class="cstat-no" title="statement not covered" >if(!1===e&amp;&amp;"undefined"!==typeof s&amp;&amp;i!==s)<span class="cstat-no" title="statement not covered" >return null}<span class="cstat-no" title="statement not covered" ></span></span></span>r</span>eturn!1}</span>function <span class="fstat-no" title="function not covered" >He(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >e._rootScopes,</span>o=<span class="cstat-no" title="statement not covered" >Fe(e._fallback,i,s),</span>r=<span class="cstat-no" title="statement not covered" >[...t,...n],</span>a=<span class="cstat-no" title="statement not covered" >new Set;<span class="cstat-no" title="statement not covered" ></span>a.add(s);l</span>et h=<span class="cstat-no" title="statement not covered" >Ve(a,r,i,o||i,s);<span class="cstat-no" title="statement not covered" ></span>return null!==h&amp;&amp;(("undefined"===typeof o||o===i||(h=Ve(a,r,o,h,s),null!==h))&amp;&amp;Te(Array.from(a),[""],n,o,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const s=<span class="cstat-no" title="statement not covered" >t._getTarget();<span class="cstat-no" title="statement not covered" ></span>e in s||(s[e]={});c</span>onst n=<span class="cstat-no" title="statement not covered" >s[e];<span class="cstat-no" title="statement not covered" ></span>if(W(n)&amp;&amp;H(i))<span class="cstat-no" title="statement not covered" >return i;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n||{}}</span>(e,i,s))</span>))}</span>function <span class="fstat-no" title="function not covered" >Ve(</span>t,e,i,s,n){<span class="cstat-no" title="statement not covered" >for(;i;)<span class="cstat-no" title="statement not covered" >i=We(t,e,i,s,n);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>function <span class="fstat-no" title="function not covered" >je(</span>t,e){<span class="cstat-no" title="statement not covered" >for(const i of e){<span class="cstat-no" title="statement not covered" >if(!i)<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >i[t];<span class="cstat-no" title="statement not covered" ></span>if("undefined"!==typeof e)<span class="cstat-no" title="statement not covered" >return e}</span></span>}</span>function <span class="fstat-no" title="function not covered" >Ne(</span>t){let e=<span class="cstat-no" title="statement not covered" >t._keys;<span class="cstat-no" title="statement not covered" ></span>return e||(e=t._keys=<span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >new Set;<span class="cstat-no" title="statement not covered" ></span>for(const i of t)<span class="cstat-no" title="statement not covered" >for(const t of Object.keys(i).filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!t.startsWith("_"))</span>))<span class="cstat-no" title="statement not covered" >e.add(t);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn Array.from(e)}</span>(t._scopes)),e}</span>const $e=<span class="cstat-no" title="statement not covered" >Number.EPSILON||1e-14,</span>Ye=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e&lt;t.length&amp;&amp;!t[e].skip&amp;&amp;t[e],</span></span>Ue=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"x"===t?"y":"x";</span></span>function <span class="fstat-no" title="function not covered" >Xe(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >t.skip?e:t,</span>o=<span class="cstat-no" title="statement not covered" >e,</span>r=<span class="cstat-no" title="statement not covered" >i.skip?e:i,</span>a=<span class="cstat-no" title="statement not covered" >kt(o,n),</span>h=<span class="cstat-no" title="statement not covered" >kt(r,o);</span>let l=<span class="cstat-no" title="statement not covered" >a/(a+h),</span>c=<span class="cstat-no" title="statement not covered" >h/(a+h);<span class="cstat-no" title="statement not covered" ></span>l=isNaN(l)?0:l,c=isNaN(c)?0:c;c</span>onst d=<span class="cstat-no" title="statement not covered" >s*l,</span>u=<span class="cstat-no" title="statement not covered" >s*c;<span class="cstat-no" title="statement not covered" ></span>return{previous:{x:o.x-d*(r.x-n.x),y:o.y-d*(r.y-n.y)},next:{x:o.x+u*(r.x-n.x),y:o.y+u*(r.y-n.y)}}}</span>function <span class="fstat-no" title="function not covered" >qe(</span>t,e=<span class="branch-0 cbranch-no" title="branch not covered" >"x")</span>{const i=<span class="cstat-no" title="statement not covered" >Ue(e),</span>s=<span class="cstat-no" title="statement not covered" >t.length,</span>n=<span class="cstat-no" title="statement not covered" >Array(s).fill(0),</span>o=<span class="cstat-no" title="statement not covered" >Array(s);</span>let r,a,h,l=<span class="cstat-no" title="statement not covered" >Ye(t,0);<span class="cstat-no" title="statement not covered" ></span>for(r=0;r&lt;s;++r)<span class="cstat-no" title="statement not covered" >if(a=h,h=l,l=Ye(t,r+1),h){<span class="cstat-no" title="statement not covered" >if(l){const t=<span class="cstat-no" title="statement not covered" >l[e]-h[e];<span class="cstat-no" title="statement not covered" ></span>n[r]=0!==t?(l[i]-h[i])/t:0}<span class="cstat-no" title="statement not covered" ></span>o</span>[r]=a?l?pt(n[r-1])!==pt(n[r])?0:(n[r-1]+n[r])/2:n[r-1]:n[r]}<span class="cstat-no" title="statement not covered" ></span>!<span class="fstat-no" title="function not covered" ></span></span>fu</span>nction(t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.length;</span>let n,o,r,a,h,l=<span class="cstat-no" title="statement not covered" >Ye(t,0);<span class="cstat-no" title="statement not covered" ></span>for(let c=<span class="cstat-no" title="statement not covered" >0;</span>c&lt;s-1;++c)<span class="cstat-no" title="statement not covered" >h=l,l=Ye(t,c+1),h&amp;&amp;l&amp;&amp;(xt(e[c],0,$e)?i[c]=i[c+1]=0:(n=i[c]/e[c],o=i[c+1]/e[c],a=Math.pow(n,2)+Math.pow(o,2),a&lt;=9||(r=3/Math.sqrt(a),i[c]=n*r*e[c],i[c+1]=o*r*e[c])))}</span></span>(t,n,o),<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >"x")</span>{const s=<span class="cstat-no" title="statement not covered" >Ue(i),</span>n=<span class="cstat-no" title="statement not covered" >t.length;</span>let o,r,a,h=<span class="cstat-no" title="statement not covered" >Ye(t,0);<span class="cstat-no" title="statement not covered" ></span>for(let l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;n;++l){<span class="cstat-no" title="statement not covered" >if(r=a,a=h,h=Ye(t,l+1),!a)<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >a[i],</span>c=<span class="cstat-no" title="statement not covered" >a[s];<span class="cstat-no" title="statement not covered" ></span>r&amp;&amp;(o=(n-r[i])/3,a[`cp1${i}`]=n-o,a[`cp1${s}`]=c-o*e[l]),h&amp;&amp;(o=(h[i]-n)/3,a[`cp2${i}`]=n+o,a[`cp2${s}`]=c+o*e[l])}</span>}</span>(t,o,e)}</span>function <span class="fstat-no" title="function not covered" >Ke(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return Math.max(Math.min(t,i),e)}</span>function <span class="fstat-no" title="function not covered" >Je(</span>t,e,i,s,n){let o,r,a,h;<span class="cstat-no" title="statement not covered" >if(e.spanGaps&amp;&amp;(t=t.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!t.skip)</span>)),"monotone"===e.cubicInterpolationMode)<span class="cstat-no" title="statement not covered" >qe(t,n);e</span>lse{let i=<span class="cstat-no" title="statement not covered" >s?t[t.length-1]:t[0];<span class="cstat-no" title="statement not covered" ></span>for(o=0,r=t.length;o&lt;r;++o)<span class="cstat-no" title="statement not covered" >a=t[o],h=Xe(i,a,t[Math.min(o+1,r-(s?0:1))%r],e.tension),a.cp1x=h.previous.x,a.cp1y=h.previous.y,a.cp2x=h.next.x,a.cp2y=h.next.y,i=a}<span class="cstat-no" title="statement not covered" ></span></span>e</span>.capBezierPoints&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){let i,s,n,o,r,a=<span class="cstat-no" title="statement not covered" >ue(t[0],e);<span class="cstat-no" title="statement not covered" ></span>for(i=0,s=t.length;i&lt;s;++i)<span class="cstat-no" title="statement not covered" >r=o,o=a,a=i&lt;s-1&amp;&amp;ue(t[i+1],e),o&amp;&amp;(n=t[i],r&amp;&amp;(n.cp1x=Ke(n.cp1x,e.left,e.right),n.cp1y=Ke(n.cp1y,e.top,e.bottom)),a&amp;&amp;(n.cp2x=Ke(n.cp2x,e.left,e.right),n.cp2y=Ke(n.cp2y,e.top,e.bottom)))}</span></span>(t,i)}</span>function <span class="fstat-no" title="function not covered" >Ge(</span>){<span class="cstat-no" title="statement not covered" >return"undefined"!==typeof window&amp;&amp;"undefined"!==typeof document}</span>function <span class="fstat-no" title="function not covered" >Ze(</span>t){let e=<span class="cstat-no" title="statement not covered" >t.parentNode;<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;"[object ShadowRoot]"===e.toString()&amp;&amp;(e=e.host),e}</span>function <span class="fstat-no" title="function not covered" >Qe(</span>t,e,i){let s;<span class="cstat-no" title="statement not covered" >return"string"===typeof t?(s=parseInt(t,10),-1!==t.indexOf("%")&amp;&amp;(s=s/100*e.parentNode[i])):s=t,s}</span>const ti=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.ownerDocument.defaultView.getComputedStyle(t,null);</span></span>const ei=<span class="cstat-no" title="statement not covered" >["top","right","bottom","left"];</span>function <span class="fstat-no" title="function not covered" >ii(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>i=i?"-"+i:"";<span class="cstat-no" title="statement not covered" >f</span>or(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;4;n++){const o=<span class="cstat-no" title="statement not covered" >ei[n];<span class="cstat-no" title="statement not covered" ></span>s[o]=parseFloat(t[e+"-"+o+i])||0}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s.width=s.left+s.right,s.height=s.top+s.bottom,s}</span>function <span class="fstat-no" title="function not covered" >si(</span>t,e){<span class="cstat-no" title="statement not covered" >if("native"in t)<span class="cstat-no" title="statement not covered" >return t;c</span></span>onst{canvas:i,currentDevicePixelRatio:s}=<span class="cstat-no" title="statement not covered" >e,</span>n=<span class="cstat-no" title="statement not covered" >ti(i),</span>o=<span class="cstat-no" title="statement not covered" >"border-box"===n.boxSizing,</span>r=<span class="cstat-no" title="statement not covered" >ii(n,"padding"),</span>a=<span class="cstat-no" title="statement not covered" >ii(n,"border","width"),</span>{x:h,y:l,box:c}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >t.touches,</span>s=<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.length?i[0]:t,</span>{offsetX:n,offsetY:o}=<span class="cstat-no" title="statement not covered" >s;</span>let r,a,h=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if((<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >(t&gt;0||e&gt;0)&amp;&amp;(!i||!i.shadowRoot))</span>(n,o,t.target))<span class="cstat-no" title="statement not covered" >r=n,a=o;e</span>lse{const t=<span class="cstat-no" title="statement not covered" >e.getBoundingClientRect();<span class="cstat-no" title="statement not covered" ></span>r=s.clientX-t.left,a=s.clientY-t.top,h=!0}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{x:r,y:a,box:h}}</span>(t,i),</span>d=<span class="cstat-no" title="statement not covered" >r.left+(c&amp;&amp;a.left),</span>u=<span class="cstat-no" title="statement not covered" >r.top+(c&amp;&amp;a.top);</span>let{width:f,height:g}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return o&amp;&amp;(f-=r.width+a.width,g-=r.height+a.height),{x:Math.round((h-d)/f*i.width/s),y:Math.round((l-u)/g*i.height/s)}}</span>const ni=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Math.round(10*t)/10;</span></span>function <span class="fstat-no" title="function not covered" >oi(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >ti(t),</span>o=<span class="cstat-no" title="statement not covered" >ii(n,"margin"),</span>r=<span class="cstat-no" title="statement not covered" >Qe(n.maxWidth,t,"clientWidth")||lt,</span>a=<span class="cstat-no" title="statement not covered" >Qe(n.maxHeight,t,"clientHeight")||lt,</span>h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){let s,n;<span class="cstat-no" title="statement not covered" >if(void 0===e||void 0===i){const o=<span class="cstat-no" title="statement not covered" >t&amp;&amp;Ze(t);<span class="cstat-no" title="statement not covered" ></span>if(o){const t=<span class="cstat-no" title="statement not covered" >o.getBoundingClientRect(),</span>r=<span class="cstat-no" title="statement not covered" >ti(o),</span>a=<span class="cstat-no" title="statement not covered" >ii(r,"border","width"),</span>h=<span class="cstat-no" title="statement not covered" >ii(r,"padding");<span class="cstat-no" title="statement not covered" ></span>e=t.width-h.width-a.width,i=t.height-h.height-a.height,s=Qe(r.maxWidth,o,"clientWidth"),n=Qe(r.maxHeight,o,"clientHeight")}</span>else <span class="cstat-no" title="statement not covered" >e=t.clientWidth,i=t.clientHeight}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn{width:e,height:i,maxWidth:s||lt,maxHeight:n||lt}}</span>(t,e,i);</span>let{width:l,height:c}=<span class="cstat-no" title="statement not covered" >h;<span class="cstat-no" title="statement not covered" ></span>if("content-box"===n.boxSizing){const t=<span class="cstat-no" title="statement not covered" >ii(n,"border","width"),</span>e=<span class="cstat-no" title="statement not covered" >ii(n,"padding");<span class="cstat-no" title="statement not covered" ></span>l-=e.width+t.width,c-=e.height+t.height}<span class="cstat-no" title="statement not covered" ></span>l</span>=Math.max(0,l-o.width),c=Math.max(0,s?l/s:c-o.height),l=ni(Math.min(l,r,h.maxWidth)),c=ni(Math.min(c,a,h.maxHeight)),l&amp;&amp;!c&amp;&amp;(c=ni(l/2));<span class="cstat-no" title="statement not covered" >r</span>eturn(void 0!==e||void 0!==i)&amp;&amp;s&amp;&amp;h.height&amp;&amp;c&gt;h.height&amp;&amp;(c=h.height,l=ni(Math.floor(c*s))),{width:l,height:c}}</span>function <span class="fstat-no" title="function not covered" >ri(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >e||1,</span>n=<span class="cstat-no" title="statement not covered" >ni(t.height*s),</span>o=<span class="cstat-no" title="statement not covered" >ni(t.width*s);<span class="cstat-no" title="statement not covered" ></span>t.height=ni(t.height),t.width=ni(t.width);c</span>onst r=<span class="cstat-no" title="statement not covered" >t.canvas;<span class="cstat-no" title="statement not covered" ></span>return r.style&amp;&amp;(i||!r.style.height&amp;&amp;!r.style.width)&amp;&amp;(r.style.height=`${t.height}px`,r.style.width=`${t.width}px`),(t.currentDevicePixelRatio!==s||r.height!==n||r.width!==o)&amp;&amp;(t.currentDevicePixelRatio=s,r.height=n,r.width=o,t.ctx.setTransform(s,0,0,s,0,0),!0)}</span>const ai=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){let t=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>try{const e=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >ge</span>t passive(){<span class="cstat-no" title="statement not covered" >return t=!0,!1}</span>};<span class="cstat-no" title="statement not covered" ></span>Ge()&amp;&amp;(window.addEventListener("test",null,e),window.removeEventListener("test",null,e))}</span>catch(e){}<span class="cstat-no" title="statement not covered" >r</span>eturn t}</span>();</span>function <span class="fstat-no" title="function not covered" >hi(</span>t,e){const i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return ti(t).getPropertyValue(e)}</span>(t,e),</span>s=<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.match(/^(\d+)(\.\d+)?px$/);<span class="cstat-no" title="statement not covered" ></span>return s?+s[1]:void 0}</span>function <span class="fstat-no" title="function not covered" >li(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return{x:t.x+i*(e.x-t.x),y:t.y+i*(e.y-t.y)}}</span>function <span class="fstat-no" title="function not covered" >ci(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return{x:t.x+i*(e.x-t.x),y:"middle"===s?i&lt;.5?t.y:e.y:"after"===s?i&lt;1?t.y:e.y:i&gt;0?e.y:t.y}}</span>function <span class="fstat-no" title="function not covered" >di(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >{x:t.cp2x,y:t.cp2y},</span>o=<span class="cstat-no" title="statement not covered" >{x:e.cp1x,y:e.cp1y},</span>r=<span class="cstat-no" title="statement not covered" >li(t,n,i),</span>a=<span class="cstat-no" title="statement not covered" >li(n,o,i),</span>h=<span class="cstat-no" title="statement not covered" >li(o,e,i),</span>l=<span class="cstat-no" title="statement not covered" >li(r,a,i),</span>c=<span class="cstat-no" title="statement not covered" >li(a,h,i);<span class="cstat-no" title="statement not covered" ></span>return li(l,c,i)}</span>function <span class="fstat-no" title="function not covered" >ui(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return t?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return{x:<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >t+t+e-i,<span class="fstat-no" title="function not covered" ></span>se</span>tWidth(t){<span class="cstat-no" title="statement not covered" >e=t}</span>,textAlign:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"center"===t?t:"right"===t?"left":"right",</span>xPlus:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t-e,</span>leftForLtr:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t-e}</span>}</span>(e,i):{x:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t,<span class="fstat-no" title="function not covered" ></span>se</span>tWidth(t){},textAlign:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t,</span>xPlus:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t+e,</span>leftForLtr:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t}</span>}</span>function <span class="fstat-no" title="function not covered" >fi(</span>t,e){let i,s;<span class="cstat-no" title="statement not covered" >"ltr"!==e&amp;&amp;"rtl"!==e||(i=t.canvas.style,s=[i.getPropertyValue("direction"),i.getPropertyPriority("direction")],i.setProperty("direction",e,"important"),t.prevTextDirection=s)}</span>function <span class="fstat-no" title="function not covered" >gi(</span>t,e){<span class="cstat-no" title="statement not covered" >void 0!==e&amp;&amp;(delete t.prevTextDirection,t.canvas.style.setProperty("direction",e[0],e[1]))}</span>function <span class="fstat-no" title="function not covered" >pi(</span>t){<span class="cstat-no" title="statement not covered" >return"angle"===t?{between:Dt,compare:St,normalize:Pt}:{between:Ot,compare:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t-e,</span>normalize:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t}</span>}</span>function <span class="fstat-no" title="function not covered" >xi(</span>{start:t,end:e,count:i,loop:s,style:n}){<span class="cstat-no" title="statement not covered" >return{start:t%i,end:e%i,loop:s&amp;&amp;(e-t+1)%i===0,style:n}}</span>function <span class="fstat-no" title="function not covered" >mi(</span>t,e,i){<span class="cstat-no" title="statement not covered" >if(!i)<span class="cstat-no" title="statement not covered" >return[t];c</span></span>onst{property:s,start:n,end:o}=<span class="cstat-no" title="statement not covered" >i,</span>r=<span class="cstat-no" title="statement not covered" >e.length,</span>{compare:a,between:h,normalize:l}=<span class="cstat-no" title="statement not covered" >pi(s),</span>{start:c,end:d,loop:u,style:f}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const{property:s,start:n,end:o}=<span class="cstat-no" title="statement not covered" >i,</span>{between:r,normalize:a}=<span class="cstat-no" title="statement not covered" >pi(s),</span>h=<span class="cstat-no" title="statement not covered" >e.length;</span>let l,c,{start:d,end:u,loop:f}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if(f){<span class="cstat-no" title="statement not covered" >for(d+=h,u+=h,l=0,c=h;l&lt;c&amp;&amp;r(a(e[d%h][s]),n,o);++l)<span class="cstat-no" title="statement not covered" >d--,u--;<span class="cstat-no" title="statement not covered" >d</span></span>%=h,u%=h}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn u&lt;d&amp;&amp;(u+=h),{start:d,end:u,loop:f,style:t.style}}</span>(t,e,i),</span>g=<span class="cstat-no" title="statement not covered" >[];</span>let p,x,m,b=<span class="cstat-no" title="statement not covered" >!1,</span>_=<span class="cstat-no" title="statement not covered" >null;</span>const y=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >b||h(n,m,p)&amp;&amp;0!==a(n,m),</span></span>v=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >!b||0===a(o,p)||h(o,m,p);<span class="cstat-no" title="statement not covered" ></span></span>for(let w=<span class="cstat-no" title="statement not covered" >c,</span>M=<span class="cstat-no" title="statement not covered" >c;</span>w&lt;=d;++w)<span class="cstat-no" title="statement not covered" >x=e[w%r],x.skip||(p=l(x[s]),p!==m&amp;&amp;(b=h(p,n,o),null===_&amp;&amp;y()&amp;&amp;(_=0===a(p,n)?w:M),null!==_&amp;&amp;v()&amp;&amp;(g.push(xi({start:_,end:w,loop:u,count:r,style:f})),_=null),M=w,m=p));<span class="cstat-no" title="statement not covered" >r</span></span>eturn null!==_&amp;&amp;g.push(xi({start:_,end:d,loop:u,count:r,style:f})),g}</span>function <span class="fstat-no" title="function not covered" >bi(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >t.segments;<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;s.length;n++){const o=<span class="cstat-no" title="statement not covered" >mi(s[n],t.points,e);<span class="cstat-no" title="statement not covered" ></span>o.length&amp;&amp;i.push(...o)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>function <span class="fstat-no" title="function not covered" >_i(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return s&amp;&amp;s.setContext&amp;&amp;i?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >t._chart.getContext(),</span>o=<span class="cstat-no" title="statement not covered" >yi(t.options),</span>{_datasetIndex:r,options:{spanGaps:a}}=<span class="cstat-no" title="statement not covered" >t,</span>h=<span class="cstat-no" title="statement not covered" >i.length,</span>l=<span class="cstat-no" title="statement not covered" >[];</span>let c=<span class="cstat-no" title="statement not covered" >o,</span>d=<span class="cstat-no" title="statement not covered" >e[0].start,</span>u=<span class="cstat-no" title="statement not covered" >d;</span>function <span class="fstat-no" title="function not covered" >f(</span>t,e,s,n){const o=<span class="cstat-no" title="statement not covered" >a?-1:1;<span class="cstat-no" title="statement not covered" ></span>if(t!==e){<span class="cstat-no" title="statement not covered" >for(t+=h;i[t%h].skip;)<span class="cstat-no" title="statement not covered" >t-=o;<span class="cstat-no" title="statement not covered" >f</span></span>or(;i[e%h].skip;)<span class="cstat-no" title="statement not covered" >e+=o;<span class="cstat-no" title="statement not covered" >t</span></span>%h!==e%h&amp;&amp;(l.push({start:t%h,end:e%h,loop:s,style:n}),c=n,d=e%h)}</span>}<span class="cstat-no" title="statement not covered" ></span>for(const g of e){<span class="cstat-no" title="statement not covered" >d=a?d:g.start;l</span>et t,e=<span class="cstat-no" title="statement not covered" >i[d%h];<span class="cstat-no" title="statement not covered" ></span>for(u=d+1;u&lt;=g.end;u++){const o=<span class="cstat-no" title="statement not covered" >i[u%h];<span class="cstat-no" title="statement not covered" ></span>t=yi(s.setContext(Ce(n,{type:"segment",p0:e,p1:o,p0DataIndex:(u-1)%h,p1DataIndex:u%h,datasetIndex:r}))),vi(t,c)&amp;&amp;f(d,u-1,g.loop,c),e=o,c=t}<span class="cstat-no" title="statement not covered" ></span>d</span>&lt;u-1&amp;&amp;f(d,u-1,g.loop,c)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn l}</span>(t,e,i,s):e}</span>function <span class="fstat-no" title="function not covered" >yi(</span>t){<span class="cstat-no" title="statement not covered" >return{backgroundColor:t.backgroundColor,borderCapStyle:t.borderCapStyle,borderDash:t.borderDash,borderDashOffset:t.borderDashOffset,borderJoinStyle:t.borderJoinStyle,borderWidth:t.borderWidth,borderColor:t.borderColor}}</span>function <span class="fstat-no" title="function not covered" >vi(</span>t,e){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return Ut(e)?(i.includes(e)||i.push(e),i.indexOf(e)):e}</span>;<span class="cstat-no" title="statement not covered" ></span>return JSON.stringify(t,s)!==JSON.stringify(e,s)}</span>function <span class="fstat-no" title="function not covered" >wi(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return t.options.clip?t[i]:e[i]}</span>function <span class="fstat-no" title="function not covered" >Mi(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >e._clip;<span class="cstat-no" title="statement not covered" ></span>if(i.disabled)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const{xScale:i,yScale:s}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;s?{left:wi(i,e,"left"),right:wi(i,e,"right"),top:wi(s,e,"top"),bottom:wi(s,e,"bottom")}:e}</span>(e,t.chartArea);<span class="cstat-no" title="statement not covered" ></span>return{left:!1===i.left?0:s.left-(!0===i.left?0:i.left),right:!1===i.right?t.width:s.right+(!0===i.right?0:i.right),top:!1===i.top?0:s.top-(!0===i.top?0:i.top),bottom:!1===i.bottom?t.height:s.bottom+(!0===i.bottom?0:i.bottom)}}</span>class ki{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this._request=null,this._charts=new Map,this._running=!1,this._lastDate=void 0}<span class="fstat-no" title="function not covered" ></span>_n</span>otify(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >e.listeners[s],</span>o=<span class="cstat-no" title="statement not covered" >e.duration;<span class="cstat-no" title="statement not covered" ></span>n.forEach((<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >s({chart:t,initial:e.initial,numSteps:o,currentStep:Math.min(i-e.start,o)}))</span>)}<span class="fstat-no" title="function not covered" ></span>_r</span>efresh(){<span class="cstat-no" title="statement not covered" >this._request||(this._running=!0,this._request=zt.call(window,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._update(),this._request=null,this._running&amp;&amp;this._refresh()}</span>)))}<span class="fstat-no" title="function not covered" ></span>_u</span>pdate(t=<span class="branch-0 cbranch-no" title="branch not covered" >Date.now())</span>{let e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>this._charts.forEach((<span class="fstat-no" title="function not covered" >(i</span>,s)=&gt;{<span class="cstat-no" title="statement not covered" >if(!i.running||!i.items.length)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >i.items;</span>let o,r=<span class="cstat-no" title="statement not covered" >n.length-1,</span>a=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>for(;r&gt;=0;--r)<span class="cstat-no" title="statement not covered" >o=n[r],o._active?(o._total&gt;i.duration&amp;&amp;(i.duration=o._total),o.tick(t),a=!0):(n[r]=n[n.length-1],n.pop());<span class="cstat-no" title="statement not covered" >a</span></span>&amp;&amp;(s.draw(),this._notify(s,i,t,"progress")),n.length||(i.running=!1,this._notify(s,i,t,"complete"),i.initial=!1),e+=n.length}</span>)),this._lastDate=t,0===e&amp;&amp;(this._running=!1)}<span class="fstat-no" title="function not covered" ></span>_g</span>etAnims(t){const e=<span class="cstat-no" title="statement not covered" >this._charts;</span>let i=<span class="cstat-no" title="statement not covered" >e.get(t);<span class="cstat-no" title="statement not covered" ></span>return i||(i={running:!1,initial:!0,items:[],listeners:{complete:[],progress:[]}},e.set(t,i)),i}<span class="fstat-no" title="function not covered" ></span>li</span>sten(t,e,i){<span class="cstat-no" title="statement not covered" >this._getAnims(t).listeners[e].push(i)}<span class="fstat-no" title="function not covered" ></span>ad</span>d(t,e){<span class="cstat-no" title="statement not covered" >e&amp;&amp;e.length&amp;&amp;this._getAnims(t).items.push(...e)}<span class="fstat-no" title="function not covered" ></span>ha</span>s(t){<span class="cstat-no" title="statement not covered" >return this._getAnims(t).items.length&gt;0}<span class="fstat-no" title="function not covered" ></span>st</span>art(t){const e=<span class="cstat-no" title="statement not covered" >this._charts.get(t);<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;(e.running=!0,e.start=Date.now(),e.duration=e.items.reduce((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >Math.max(t,e._duration))</span>,0),this._refresh())}<span class="fstat-no" title="function not covered" ></span>ru</span>nning(t){<span class="cstat-no" title="statement not covered" >if(!this._running)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this._charts.get(t);<span class="cstat-no" title="statement not covered" ></span>return!!(e&amp;&amp;e.running&amp;&amp;e.items.length)}<span class="fstat-no" title="function not covered" ></span>st</span>op(t){const e=<span class="cstat-no" title="statement not covered" >this._charts.get(t);<span class="cstat-no" title="statement not covered" ></span>if(!e||!e.items.length)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >e.items;</span>let s=<span class="cstat-no" title="statement not covered" >i.length-1;<span class="cstat-no" title="statement not covered" ></span>for(;s&gt;=0;--s)<span class="cstat-no" title="statement not covered" >i[s].cancel();<span class="cstat-no" title="statement not covered" >e</span></span>.items=[],this._notify(t,e,Date.now(),"complete")}<span class="fstat-no" title="function not covered" ></span>re</span>move(t){<span class="cstat-no" title="statement not covered" >return this._charts.delete(t)}</span>}var Si=<span class="cstat-no" title="statement not covered" >new ki;</span>const Pi=<span class="cstat-no" title="statement not covered" >"transparent",</span>Di=<span class="cstat-no" title="statement not covered" >{boolean:<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >i&gt;.5?e:t,<span class="fstat-no" title="function not covered" ></span>co</span>lor(t,e,i){const s=<span class="cstat-no" title="statement not covered" >Xt(t||Pi),</span>n=<span class="cstat-no" title="statement not covered" >s.valid&amp;&amp;Xt(e||Pi);<span class="cstat-no" title="statement not covered" ></span>return n&amp;&amp;n.valid?n.mix(s,i).hexString():e}</span>,number:<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >t+(e-t)*i}</span>;</span>class Ai{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >e[i];<span class="cstat-no" title="statement not covered" ></span>s=Oe([t.to,s,n,t.from]);c</span>onst o=<span class="cstat-no" title="statement not covered" >Oe([t.from,n,s]);<span class="cstat-no" title="statement not covered" ></span>this._active=!0,this._fn=t.fn||Di[t.type||typeof o],this._easing=Yt[t.easing]||Yt.linear,this._start=Math.floor(Date.now()+(t.delay||0)),this._duration=this._total=Math.floor(t.duration),this._loop=!!t.loop,this._target=e,this._prop=i,this._from=o,this._to=s,this._promises=void 0}<span class="fstat-no" title="function not covered" ></span>ac</span>tive(){<span class="cstat-no" title="statement not covered" >return this._active}<span class="fstat-no" title="function not covered" ></span>up</span>date(t,e,i){<span class="cstat-no" title="statement not covered" >if(this._active){<span class="cstat-no" title="statement not covered" >this._notify(!1);c</span>onst s=<span class="cstat-no" title="statement not covered" >this._target[this._prop],</span>n=<span class="cstat-no" title="statement not covered" >i-this._start,</span>o=<span class="cstat-no" title="statement not covered" >this._duration-n;<span class="cstat-no" title="statement not covered" ></span>this._start=i,this._duration=Math.floor(Math.max(o,t.duration)),this._total+=n,this._loop=!!t.loop,this._to=Oe([t.to,e,s,t.from]),this._from=Oe([t.from,s,e])}</span>}<span class="fstat-no" title="function not covered" ></span>ca</span>ncel(){<span class="cstat-no" title="statement not covered" >this._active&amp;&amp;(this.tick(Date.now()),this._active=!1,this._notify(!1))}<span class="fstat-no" title="function not covered" ></span>ti</span>ck(t){const e=<span class="cstat-no" title="statement not covered" >t-this._start,</span>i=<span class="cstat-no" title="statement not covered" >this._duration,</span>s=<span class="cstat-no" title="statement not covered" >this._prop,</span>n=<span class="cstat-no" title="statement not covered" >this._from,</span>o=<span class="cstat-no" title="statement not covered" >this._loop,</span>r=<span class="cstat-no" title="statement not covered" >this._to;</span>let a;<span class="cstat-no" title="statement not covered" >if(this._active=n!==r&amp;&amp;(o||e&lt;i),!this._active)<span class="cstat-no" title="statement not covered" >return this._target[s]=r,void this._notify(!0);<span class="cstat-no" title="statement not covered" >e</span></span>&lt;0?this._target[s]=n:(a=e/i%2,a=o&amp;&amp;a&gt;1?2-a:a,a=this._easing(Math.min(1,Math.max(0,a))),this._target[s]=this._fn(n,r,a))}<span class="fstat-no" title="function not covered" ></span>wa</span>it(){const t=<span class="cstat-no" title="statement not covered" >this._promises||(this._promises=[]);<span class="cstat-no" title="statement not covered" ></span>return new Promise((<span class="fstat-no" title="function not covered" >(e</span>,i)=&gt;{<span class="cstat-no" title="statement not covered" >t.push({res:e,rej:i})}</span>))}<span class="fstat-no" title="function not covered" ></span>_n</span>otify(t){const e=<span class="cstat-no" title="statement not covered" >t?"res":"rej",</span>i=<span class="cstat-no" title="statement not covered" >this._promises||[];<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;i.length;s++)<span class="cstat-no" title="statement not covered" >i[s][e]()}</span></span>}class Oi{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >this._chart=t,this._properties=new Map,this.configure(e)}<span class="fstat-no" title="function not covered" ></span>co</span>nfigure(t){<span class="cstat-no" title="statement not covered" >if(!H(t))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >Object.keys(re.animation),</span>i=<span class="cstat-no" title="statement not covered" >this._properties;<span class="cstat-no" title="statement not covered" ></span>Object.getOwnPropertyNames(t).forEach((<span class="fstat-no" title="function not covered" >s=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >t[s];<span class="cstat-no" title="statement not covered" ></span>if(!H(n))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(const t of e)<span class="cstat-no" title="statement not covered" >o[t]=n[t];<span class="cstat-no" title="statement not covered" >(</span></span>W(n.properties)&amp;&amp;n.properties||[s]).forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >t!==s&amp;&amp;i.has(t)||i.set(t,o)}</span>))}</span>))}<span class="fstat-no" title="function not covered" ></span>_a</span>nimateOptions(t,e){const i=<span class="cstat-no" title="statement not covered" >e.options,</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return;l</span></span>et i=<span class="cstat-no" title="statement not covered" >t.options;<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return void(t.options=e);<span class="cstat-no" title="statement not covered" >i</span></span>.$shared&amp;&amp;(t.options=i=Object.assign({},i,{$shared:!1,$animations:{}}));<span class="cstat-no" title="statement not covered" >r</span>eturn i}</span>(t,i);<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return[];c</span></span>onst n=<span class="cstat-no" title="statement not covered" >this._createAnimations(s,i);<span class="cstat-no" title="statement not covered" ></span>return i.$shared&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >Object.keys(e);<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;s.length;n++){const e=<span class="cstat-no" title="statement not covered" >t[s[n]];<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;e.active()&amp;&amp;i.push(e.wait())}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Promise.all(i)}</span>(t.options.$animations,i).then((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.options=i}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{})),n}<span class="fstat-no" title="function not covered" ></span>_c</span>reateAnimations(t,e){const i=<span class="cstat-no" title="statement not covered" >this._properties,</span>s=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >t.$animations||(t.$animations={}),</span>o=<span class="cstat-no" title="statement not covered" >Object.keys(e),</span>r=<span class="cstat-no" title="statement not covered" >Date.now();</span>let a;<span class="cstat-no" title="statement not covered" >for(a=o.length-1;a&gt;=0;--a){const h=<span class="cstat-no" title="statement not covered" >o[a];<span class="cstat-no" title="statement not covered" ></span>if("$"===h.charAt(0))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f("options"===h){<span class="cstat-no" title="statement not covered" >s.push(...this._animateOptions(t,e));<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>c</span>onst l=<span class="cstat-no" title="statement not covered" >e[h];</span>let c=<span class="cstat-no" title="statement not covered" >n[h];</span>const d=<span class="cstat-no" title="statement not covered" >i.get(h);<span class="cstat-no" title="statement not covered" ></span>if(c){<span class="cstat-no" title="statement not covered" >if(d&amp;&amp;c.active()){<span class="cstat-no" title="statement not covered" >c.update(d,l,r);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>c</span>.cancel()}<span class="cstat-no" title="statement not covered" ></span>d</span>&amp;&amp;d.duration?(n[h]=c=new Ai(d,t,h,l),s.push(c)):t[h]=l}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>up</span>date(t,e){<span class="cstat-no" title="statement not covered" >if(0===this._properties.size)<span class="cstat-no" title="statement not covered" >return void Object.assign(t,e);c</span></span>onst i=<span class="cstat-no" title="statement not covered" >this._createAnimations(t,e);<span class="cstat-no" title="statement not covered" ></span>return i.length?(Si.add(this._chart,i),!0):void 0}</span>}function <span class="fstat-no" title="function not covered" >Ci(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.options||{},</span>s=<span class="cstat-no" title="statement not covered" >i.reverse,</span>n=<span class="cstat-no" title="statement not covered" >void 0===i.min?e:0,</span>o=<span class="cstat-no" title="statement not covered" >void 0===i.max?e:0;<span class="cstat-no" title="statement not covered" ></span>return{start:s?o:n,end:s?n:o}}</span>function <span class="fstat-no" title="function not covered" >Ti(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >t._getSortedDatasetMetas(e);</span>let n,o;<span class="cstat-no" title="statement not covered" >for(n=0,o=s.length;n&lt;o;++n)<span class="cstat-no" title="statement not covered" >i.push(s[n].index);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>function <span class="fstat-no" title="function not covered" >Ri(</span>t,e,i,s=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const n=<span class="cstat-no" title="statement not covered" >t.keys,</span>o=<span class="cstat-no" title="statement not covered" >"single"===s.mode;</span>let r,a,h,l;<span class="cstat-no" title="statement not covered" >if(null===e)<span class="cstat-no" title="statement not covered" >return;l</span></span>et c=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>for(r=0,a=n.length;r&lt;a;++r){<span class="cstat-no" title="statement not covered" >if(h=+n[r],h===i){<span class="cstat-no" title="statement not covered" >if(c=!0,s.all)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >b</span></span>reak}<span class="cstat-no" title="statement not covered" ></span>l</span>=t.values[h],V(l)&amp;&amp;(o||0===e||pt(e)===pt(l))&amp;&amp;(e+=l)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn c||s.all?e:0}</span>function <span class="fstat-no" title="function not covered" >Ii(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.options.stacked;<span class="cstat-no" title="statement not covered" ></span>return i||void 0===i&amp;&amp;void 0!==e.stack}</span>function <span class="fstat-no" title="function not covered" >Ei(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t[e]||(t[e]={});<span class="cstat-no" title="statement not covered" ></span>return s[i]||(s[i]={})}</span>function <span class="fstat-no" title="function not covered" >Li(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >for(const n of e.getMatchingVisibleMetas(s).reverse()){const e=<span class="cstat-no" title="statement not covered" >t[n.index];<span class="cstat-no" title="statement not covered" ></span>if(i&amp;&amp;e&gt;0||!i&amp;&amp;e&lt;0)<span class="cstat-no" title="statement not covered" >return n.index}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn null}</span>function <span class="fstat-no" title="function not covered" >zi(</span>t,e){const{chart:i,_cachedMeta:s}=<span class="cstat-no" title="statement not covered" >t,</span>n=<span class="cstat-no" title="statement not covered" >i._stacks||(i._stacks={}),</span>{iScale:o,vScale:r,index:a}=<span class="cstat-no" title="statement not covered" >s,</span>h=<span class="cstat-no" title="statement not covered" >o.axis,</span>l=<span class="cstat-no" title="statement not covered" >r.axis,</span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return`${t.id}.${e.id}.${i.stack||i.type}`}</span>(o,r,s),</span>d=<span class="cstat-no" title="statement not covered" >e.length;</span>let u;<span class="cstat-no" title="statement not covered" >for(let f=<span class="cstat-no" title="statement not covered" >0;</span>f&lt;d;++f){const t=<span class="cstat-no" title="statement not covered" >e[f],</span>{[h]:i,[l]:o}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>u=(t._stacks||(t._stacks={}))[l]=Ei(n,c,i),u[a]=o,u._top=Li(u,r,!0,s.type),u._bottom=Li(u,r,!1,s.type);<span class="cstat-no" title="statement not covered" >(</span>u._visualValues||(u._visualValues={}))[a]=o}</span>}</span>function <span class="fstat-no" title="function not covered" >Fi(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t.scales;<span class="cstat-no" title="statement not covered" ></span>return Object.keys(i).filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >i[t].axis===e)</span>).shift()}</span>function <span class="fstat-no" title="function not covered" >Bi(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t.controller.index,</span>s=<span class="cstat-no" title="statement not covered" >t.vScale&amp;&amp;t.vScale.axis;<span class="cstat-no" title="statement not covered" ></span>if(s){<span class="cstat-no" title="statement not covered" >e=e||t._parsed;<span class="cstat-no" title="statement not covered" >f</span>or(const t of e){const e=<span class="cstat-no" title="statement not covered" >t._stacks;<span class="cstat-no" title="statement not covered" ></span>if(!e||void 0===e[s]||void 0===e[s][i])<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >d</span></span>elete e[s][i],void 0!==e[s]._visualValues&amp;&amp;void 0!==e[s]._visualValues[i]&amp;&amp;delete e[s]._visualValues[i]}</span>}</span>}</span>const Wi=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"reset"===t||"none"===t,</span></span>Hi=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e?t:Object.assign({},t);</span></span>class Vi{static defaults=<span class="cstat-no" title="statement not covered" >{};</span>static datasetElementType=<span class="cstat-no" title="statement not covered" >null;</span>static dataElementType=<span class="cstat-no" title="statement not covered" >null;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >this.chart=t,this._ctx=t.ctx,this.index=e,this._cachedDataOpts={},this._cachedMeta=this.getMeta(),this._type=this._cachedMeta.type,this.options=void 0,this._parsing=!1,this._data=void 0,this._objectData=void 0,this._sharedOptions=void 0,this._drawStart=void 0,this._drawCount=void 0,this.enableOptionSharing=!1,this.supportsDecimation=!1,this.$context=void 0,this._syncList=[],this.datasetElementType=new.target.datasetElementType,this.dataElementType=new.target.dataElementType,this.initialize()}<span class="fstat-no" title="function not covered" ></span>in</span>itialize(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>this.configure(),this.linkScales(),t._stacked=Ii(t.vScale,t),this.addElements(),this.options.fill&amp;&amp;!this.chart.isPluginEnabled("filler")&amp;&amp;console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options")}<span class="fstat-no" title="function not covered" ></span>up</span>dateIndex(t){<span class="cstat-no" title="statement not covered" >this.index!==t&amp;&amp;Bi(this._cachedMeta),this.index=t}<span class="fstat-no" title="function not covered" ></span>li</span>nkScales(){const t=<span class="cstat-no" title="statement not covered" >this.chart,</span>e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>i=<span class="cstat-no" title="statement not covered" >this.getDataset(),</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i,s)=&gt;<span class="cstat-no" title="statement not covered" >"x"===t?e:"r"===t?s:i,</span></span>n=<span class="cstat-no" title="statement not covered" >e.xAxisID=N(i.xAxisID,Fi(t,"x")),</span>o=<span class="cstat-no" title="statement not covered" >e.yAxisID=N(i.yAxisID,Fi(t,"y")),</span>r=<span class="cstat-no" title="statement not covered" >e.rAxisID=N(i.rAxisID,Fi(t,"r")),</span>a=<span class="cstat-no" title="statement not covered" >e.indexAxis,</span>h=<span class="cstat-no" title="statement not covered" >e.iAxisID=s(a,n,o,r),</span>l=<span class="cstat-no" title="statement not covered" >e.vAxisID=s(a,o,n,r);<span class="cstat-no" title="statement not covered" ></span>e.xScale=this.getScaleForId(n),e.yScale=this.getScaleForId(o),e.rScale=this.getScaleForId(r),e.iScale=this.getScaleForId(h),e.vScale=this.getScaleForId(l)}<span class="fstat-no" title="function not covered" ></span>ge</span>tDataset(){<span class="cstat-no" title="statement not covered" >return this.chart.data.datasets[this.index]}<span class="fstat-no" title="function not covered" ></span>ge</span>tMeta(){<span class="cstat-no" title="statement not covered" >return this.chart.getDatasetMeta(this.index)}<span class="fstat-no" title="function not covered" ></span>ge</span>tScaleForId(t){<span class="cstat-no" title="statement not covered" >return this.chart.scales[t]}<span class="fstat-no" title="function not covered" ></span>_g</span>etOtherScale(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>return t===e.iScale?e.vScale:e.iScale}<span class="fstat-no" title="function not covered" ></span>re</span>set(){<span class="cstat-no" title="statement not covered" >this._update("reset")}<span class="fstat-no" title="function not covered" ></span>_d</span>estroy(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>this._data&amp;&amp;Et(this._data,this),t._stacked&amp;&amp;Bi(t)}<span class="fstat-no" title="function not covered" ></span>_d</span>ataCheck(){const t=<span class="cstat-no" title="statement not covered" >this.getDataset(),</span>e=<span class="cstat-no" title="statement not covered" >t.data||(t.data=[]),</span>i=<span class="cstat-no" title="statement not covered" >this._data;<span class="cstat-no" title="statement not covered" ></span>if(H(e)){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>this._data=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const{iScale:i,vScale:s}=<span class="cstat-no" title="statement not covered" >e,</span>n=<span class="cstat-no" title="statement not covered" >"x"===i.axis?"x":"y",</span>o=<span class="cstat-no" title="statement not covered" >"x"===s.axis?"x":"y",</span>r=<span class="cstat-no" title="statement not covered" >Object.keys(t),</span>a=<span class="cstat-no" title="statement not covered" >new Array(r.length);</span>let h,l,c;<span class="cstat-no" title="statement not covered" >for(h=0,l=r.length;h&lt;l;++h)<span class="cstat-no" title="statement not covered" >c=r[h],a[h]={[n]:c,[o]:t[c]};<span class="cstat-no" title="statement not covered" >r</span></span>eturn a}</span>(e,t)}</span>else <span class="cstat-no" title="statement not covered" >if(i!==e){<span class="cstat-no" title="statement not covered" >if(i){<span class="cstat-no" title="statement not covered" >Et(i,this);c</span>onst t=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>Bi(t),t._parsed=[]}<span class="cstat-no" title="statement not covered" ></span>e</span>&amp;&amp;Object.isExtensible(e)&amp;&amp;(n=this,(s=e)._chartjs?s._chartjs.listeners.push(n):(Object.defineProperty(s,"_chartjs",{configurable:!0,enumerable:!1,value:{listeners:[n]}}),It.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >"_onData"+it(t),</span>i=<span class="cstat-no" title="statement not covered" >s[t];<span class="cstat-no" title="statement not covered" ></span>Object.defineProperty(s,t,{configurable:!0,enumerable:!1,<span class="fstat-no" title="function not covered" >va</span>lue(...t){const n=<span class="cstat-no" title="statement not covered" >i.apply(this,t);<span class="cstat-no" title="statement not covered" ></span>return s._chartjs.listeners.forEach((<span class="fstat-no" title="function not covered" >i=</span>&gt;{<span class="cstat-no" title="statement not covered" >"function"===typeof i[e]&amp;&amp;i[e](...t)}</span>)),n}</span>})}</span>)))),this._syncList=[],this._data=e}</span>v</span></span>ar s,n}<span class="fstat-no" title="function not covered" >ad</span>dElements(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>this._dataCheck(),this.datasetElementType&amp;&amp;(t.dataset=new this.datasetElementType)}<span class="fstat-no" title="function not covered" ></span>bu</span>ildOrUpdateElements(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>i=<span class="cstat-no" title="statement not covered" >this.getDataset();</span>let s=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>this._dataCheck();c</span>onst n=<span class="cstat-no" title="statement not covered" >e._stacked;<span class="cstat-no" title="statement not covered" ></span>e._stacked=Ii(e.vScale,e),e.stack!==i.stack&amp;&amp;(s=!0,Bi(e),e.stack=i.stack),this._resyncElements(t),(s||n!==e._stacked)&amp;&amp;(zi(this,e._parsed),e._stacked=Ii(e.vScale,e))}<span class="fstat-no" title="function not covered" ></span>co</span>nfigure(){const t=<span class="cstat-no" title="statement not covered" >this.chart.config,</span>e=<span class="cstat-no" title="statement not covered" >t.datasetScopeKeys(this._type),</span>i=<span class="cstat-no" title="statement not covered" >t.getOptionScopes(this.getDataset(),e,!0);<span class="cstat-no" title="statement not covered" ></span>this.options=t.createResolver(i,this.getContext()),this._parsing=this.options.parsing,this._cachedDataOpts={}}<span class="fstat-no" title="function not covered" ></span>pa</span>rse(t,e){const{_cachedMeta:i,_data:s}=<span class="cstat-no" title="statement not covered" >this,</span>{iScale:n,_stacked:o}=<span class="cstat-no" title="statement not covered" >i,</span>r=<span class="cstat-no" title="statement not covered" >n.axis;</span>let a,h,l,c=<span class="cstat-no" title="statement not covered" >0===t&amp;&amp;e===s.length||i._sorted,</span>d=<span class="cstat-no" title="statement not covered" >t&gt;0&amp;&amp;i._parsed[t-1];<span class="cstat-no" title="statement not covered" ></span>if(!1===this._parsing)<span class="cstat-no" title="statement not covered" >i._parsed=s,i._sorted=!0,l=s;e</span>lse{<span class="cstat-no" title="statement not covered" >l=W(s[t])?this.parseArrayData(i,s,t,e):H(s[t])?this.parseObjectData(i,s,t,e):this.parsePrimitiveData(i,s,t,e);c</span>onst n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >null===h[r]||d&amp;&amp;h[r]&lt;d[r];<span class="cstat-no" title="statement not covered" ></span></span>for(a=0;a&lt;e;++a)<span class="cstat-no" title="statement not covered" >i._parsed[a+t]=h=l[a],c&amp;&amp;(n()&amp;&amp;(c=!1),d=h);<span class="cstat-no" title="statement not covered" >i</span></span>._sorted=c}<span class="cstat-no" title="statement not covered" ></span>o</span>&amp;&amp;zi(this,l)}<span class="fstat-no" title="function not covered" ></span>pa</span>rsePrimitiveData(t,e,i,s){const{iScale:n,vScale:o}=<span class="cstat-no" title="statement not covered" >t,</span>r=<span class="cstat-no" title="statement not covered" >n.axis,</span>a=<span class="cstat-no" title="statement not covered" >o.axis,</span>h=<span class="cstat-no" title="statement not covered" >n.getLabels(),</span>l=<span class="cstat-no" title="statement not covered" >n===o,</span>c=<span class="cstat-no" title="statement not covered" >new Array(s);</span>let d,u,f;<span class="cstat-no" title="statement not covered" >for(d=0,u=s;d&lt;u;++d)<span class="cstat-no" title="statement not covered" >f=d+i,c[d]={[r]:l||n.parse(h[f],f),[a]:o.parse(e[f],f)};<span class="cstat-no" title="statement not covered" >r</span></span>eturn c}<span class="fstat-no" title="function not covered" ></span>pa</span>rseArrayData(t,e,i,s){const{xScale:n,yScale:o}=<span class="cstat-no" title="statement not covered" >t,</span>r=<span class="cstat-no" title="statement not covered" >new Array(s);</span>let a,h,l,c;<span class="cstat-no" title="statement not covered" >for(a=0,h=s;a&lt;h;++a)<span class="cstat-no" title="statement not covered" >l=a+i,c=e[l],r[a]={x:n.parse(c[0],l),y:o.parse(c[1],l)};<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}<span class="fstat-no" title="function not covered" ></span>pa</span>rseObjectData(t,e,i,s){const{xScale:n,yScale:o}=<span class="cstat-no" title="statement not covered" >t,</span>{xAxisKey:r=<span class="branch-0 cbranch-no" title="branch not covered" >"x",</span>yAxisKey:a=<span class="branch-0 cbranch-no" title="branch not covered" >"y"}</span>=<span class="cstat-no" title="statement not covered" >this._parsing,</span>h=<span class="cstat-no" title="statement not covered" >new Array(s);</span>let l,c,d,u;<span class="cstat-no" title="statement not covered" >for(l=0,c=s;l&lt;c;++l)<span class="cstat-no" title="statement not covered" >d=l+i,u=e[d],h[l]={x:n.parse(et(u,r),d),y:o.parse(et(u,a),d)};<span class="cstat-no" title="statement not covered" >r</span></span>eturn h}<span class="fstat-no" title="function not covered" ></span>ge</span>tParsed(t){<span class="cstat-no" title="statement not covered" >return this._cachedMeta._parsed[t]}<span class="fstat-no" title="function not covered" ></span>ge</span>tDataElement(t){<span class="cstat-no" title="statement not covered" >return this._cachedMeta.data[t]}<span class="fstat-no" title="function not covered" ></span>ap</span>plyStack(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.chart,</span>n=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>o=<span class="cstat-no" title="statement not covered" >e[t.axis];<span class="cstat-no" title="statement not covered" ></span>return Ri({keys:Ti(s,!0),values:e._stacks[t.axis]._visualValues},o,n.index,{mode:i})}<span class="fstat-no" title="function not covered" ></span>up</span>dateRangeFromParsed(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >i[e.axis];</span>let o=<span class="cstat-no" title="statement not covered" >null===n?NaN:n;</span>const r=<span class="cstat-no" title="statement not covered" >s&amp;&amp;i._stacks[e.axis];<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;r&amp;&amp;(s.values=r,o=Ri(s,n,this._cachedMeta.index)),t.min=Math.min(t.min,o),t.max=Math.max(t.max,o)}<span class="fstat-no" title="function not covered" ></span>ge</span>tMinMax(t,e){const i=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>s=<span class="cstat-no" title="statement not covered" >i._parsed,</span>n=<span class="cstat-no" title="statement not covered" >i._sorted&amp;&amp;t===i.iScale,</span>o=<span class="cstat-no" title="statement not covered" >s.length,</span>r=<span class="cstat-no" title="statement not covered" >this._getOtherScale(t),</span>a=<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >t&amp;&amp;!e.hidden&amp;&amp;e._stacked&amp;&amp;{keys:Ti(i,!0),values:null})</span>(e,i,this.chart),</span>h=<span class="cstat-no" title="statement not covered" >{min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY},</span>{min:l,max:c}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const{min:e,max:i,minDefined:s,maxDefined:n}=<span class="cstat-no" title="statement not covered" >t.getUserBounds();<span class="cstat-no" title="statement not covered" ></span>return{min:s?e:Number.NEGATIVE_INFINITY,max:n?i:Number.POSITIVE_INFINITY}}</span>(r);</span>let d,u;function <span class="fstat-no" title="function not covered" >f(</span>){<span class="cstat-no" title="statement not covered" >u=s[d];c</span>onst e=<span class="cstat-no" title="statement not covered" >u[r.axis];<span class="cstat-no" title="statement not covered" ></span>return!V(u[t.axis])||l&gt;e||c&lt;e}<span class="cstat-no" title="statement not covered" ></span>for(d=0;d&lt;o&amp;&amp;(f()||(this.updateRangeFromParsed(h,t,u,a),!n));++d);<span class="cstat-no" title="statement not covered" >i</span>f(n)<span class="cstat-no" title="statement not covered" >for(d=o-1;d&gt;=0;--d)<span class="cstat-no" title="statement not covered" >if(!f()){<span class="cstat-no" title="statement not covered" >this.updateRangeFromParsed(h,t,u,a);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn h}<span class="fstat-no" title="function not covered" ></span>ge</span>tAllParsedValues(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta._parsed,</span>i=<span class="cstat-no" title="statement not covered" >[];</span>let s,n,o;<span class="cstat-no" title="statement not covered" >for(s=0,n=e.length;s&lt;n;++s)<span class="cstat-no" title="statement not covered" >o=e[s][t.axis],V(o)&amp;&amp;i.push(o);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaxOverflow(){<span class="cstat-no" title="statement not covered" >return!1}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelAndValue(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>i=<span class="cstat-no" title="statement not covered" >e.iScale,</span>s=<span class="cstat-no" title="statement not covered" >e.vScale,</span>n=<span class="cstat-no" title="statement not covered" >this.getParsed(t);<span class="cstat-no" title="statement not covered" ></span>return{label:i?""+i.getLabelForValue(n[i.axis]):"",value:s?""+s.getLabelForValue(n[s.axis]):""}}<span class="fstat-no" title="function not covered" ></span>_u</span>pdate(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>this.update(t||"default"),e._clip=<span class="fstat-no" title="function not covered" >fu</span>nction(t){let e,i,s,n;<span class="cstat-no" title="statement not covered" >return H(t)?(e=t.top,i=t.right,s=t.bottom,n=t.left):e=i=s=n=t,{top:e,right:i,bottom:s,left:n,disabled:!1===t}}</span>(N(this.options.clip,<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >if(!1===i)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >Ci(t,i),</span>n=<span class="cstat-no" title="statement not covered" >Ci(e,i);<span class="cstat-no" title="statement not covered" ></span>return{top:n.end,right:s.end,bottom:n.start,left:s.start}}</span>(e.xScale,e.yScale,this.getMaxOverflow())))}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){}<span class="fstat-no" title="function not covered" >dr</span>aw(){const t=<span class="cstat-no" title="statement not covered" >this._ctx,</span>e=<span class="cstat-no" title="statement not covered" >this.chart,</span>i=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>s=<span class="cstat-no" title="statement not covered" >i.data||[],</span>n=<span class="cstat-no" title="statement not covered" >e.chartArea,</span>o=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >this._drawStart||0,</span>a=<span class="cstat-no" title="statement not covered" >this._drawCount||s.length-r,</span>h=<span class="cstat-no" title="statement not covered" >this.options.drawActiveElementsOnTop;</span>let l;<span class="cstat-no" title="statement not covered" >for(i.dataset&amp;&amp;i.dataset.draw(t,n,r,a),l=r;l&lt;r+a;++l){const e=<span class="cstat-no" title="statement not covered" >s[l];<span class="cstat-no" title="statement not covered" ></span>e.hidden||(e.active&amp;&amp;h?o.push(e):e.draw(t,n))}<span class="cstat-no" title="statement not covered" ></span>f</span>or(l=0;l&lt;o.length;++l)<span class="cstat-no" title="statement not covered" >o[l].draw(t,n)}<span class="fstat-no" title="function not covered" ></span></span>ge</span>tStyle(t,e){const i=<span class="cstat-no" title="statement not covered" >e?"active":"default";<span class="cstat-no" title="statement not covered" ></span>return void 0===t&amp;&amp;this._cachedMeta.dataset?this.resolveDatasetElementOptions(i):this.resolveDataElementOptions(t||0,i)}<span class="fstat-no" title="function not covered" ></span>ge</span>tContext(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.getDataset();</span>let n;<span class="cstat-no" title="statement not covered" >if(t&gt;=0&amp;&amp;t&lt;this._cachedMeta.data.length){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta.data[t];<span class="cstat-no" title="statement not covered" ></span>n=e.$context||(e.$context=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return Ce(t,{active:!1,dataIndex:e,parsed:void 0,raw:void 0,element:i,index:e,mode:"default",type:"data"})}</span>(this.getContext(),t,e)),n.parsed=this.getParsed(t),n.raw=s.data[t],n.index=n.dataIndex=t}</span>else <span class="cstat-no" title="statement not covered" >n=this.$context||(this.$context=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return Ce(t,{active:!1,dataset:void 0,datasetIndex:e,index:e,mode:"default",type:"dataset"})}</span>(this.chart.getContext(),this.index)),n.dataset=s,n.index=n.datasetIndex=this.index;<span class="cstat-no" title="statement not covered" >r</span></span>eturn n.active=!!e,n.mode=i,n}<span class="fstat-no" title="function not covered" ></span>re</span>solveDatasetElementOptions(t){<span class="cstat-no" title="statement not covered" >return this._resolveElementOptions(this.datasetElementType.id,t)}<span class="fstat-no" title="function not covered" ></span>re</span>solveDataElementOptions(t,e){<span class="cstat-no" title="statement not covered" >return this._resolveElementOptions(this.dataElementType.id,e,t)}<span class="fstat-no" title="function not covered" ></span>_r</span>esolveElementOptions(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >"default",</span>i){const s=<span class="cstat-no" title="statement not covered" >"active"===e,</span>n=<span class="cstat-no" title="statement not covered" >this._cachedDataOpts,</span>o=<span class="cstat-no" title="statement not covered" >t+"-"+e,</span>r=<span class="cstat-no" title="statement not covered" >n[o],</span>a=<span class="cstat-no" title="statement not covered" >this.enableOptionSharing&amp;&amp;st(i);<span class="cstat-no" title="statement not covered" ></span>if(r)<span class="cstat-no" title="statement not covered" >return Hi(r,a);c</span></span>onst h=<span class="cstat-no" title="statement not covered" >this.chart.config,</span>l=<span class="cstat-no" title="statement not covered" >h.datasetElementScopeKeys(this._type,t),</span>c=<span class="cstat-no" title="statement not covered" >s?[`${t}Hover`,"hover",t,""]:[t,""],</span>d=<span class="cstat-no" title="statement not covered" >h.getOptionScopes(this.getDataset(),l),</span>u=<span class="cstat-no" title="statement not covered" >Object.keys(re.elements[t]),</span>f=<span class="cstat-no" title="statement not covered" >h.resolveNamedOptions(d,u,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.getContext(i,s,e))</span>,c);<span class="cstat-no" title="statement not covered" ></span>return f.$shared&amp;&amp;(f.$shared=a,n[o]=Object.freeze(Hi(f,a))),f}<span class="fstat-no" title="function not covered" ></span>_r</span>esolveAnimations(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.chart,</span>n=<span class="cstat-no" title="statement not covered" >this._cachedDataOpts,</span>o=<span class="cstat-no" title="statement not covered" >`animation-${e}`,</span>r=<span class="cstat-no" title="statement not covered" >n[o];<span class="cstat-no" title="statement not covered" ></span>if(r)<span class="cstat-no" title="statement not covered" >return r;l</span></span>et a;<span class="cstat-no" title="statement not covered" >if(!1!==s.options.animation){const s=<span class="cstat-no" title="statement not covered" >this.chart.config,</span>n=<span class="cstat-no" title="statement not covered" >s.datasetAnimationScopeKeys(this._type,e),</span>o=<span class="cstat-no" title="statement not covered" >s.getOptionScopes(this.getDataset(),n);<span class="cstat-no" title="statement not covered" ></span>a=s.createResolver(o,this.getContext(t,i,e))}</span>c</span>onst h=<span class="cstat-no" title="statement not covered" >new Oi(s,a&amp;&amp;a.animations);<span class="cstat-no" title="statement not covered" ></span>return a&amp;&amp;a._cacheable&amp;&amp;(n[o]=Object.freeze(h)),h}<span class="fstat-no" title="function not covered" ></span>ge</span>tSharedOptions(t){<span class="cstat-no" title="statement not covered" >if(t.$shared)<span class="cstat-no" title="statement not covered" >return this._sharedOptions||(this._sharedOptions=Object.assign({},t))}<span class="fstat-no" title="function not covered" ></span></span>in</span>cludeOptions(t,e){<span class="cstat-no" title="statement not covered" >return!e||Wi(t)||this.chart._animationsDisabled}<span class="fstat-no" title="function not covered" ></span>_g</span>etSharedOptions(t,e){const i=<span class="cstat-no" title="statement not covered" >this.resolveDataElementOptions(t,e),</span>s=<span class="cstat-no" title="statement not covered" >this._sharedOptions,</span>n=<span class="cstat-no" title="statement not covered" >this.getSharedOptions(i),</span>o=<span class="cstat-no" title="statement not covered" >this.includeOptions(e,n)||n!==s;<span class="cstat-no" title="statement not covered" ></span>return this.updateSharedOptions(n,e,i),{sharedOptions:n,includeOptions:o}}<span class="fstat-no" title="function not covered" ></span>up</span>dateElement(t,e,i,s){<span class="cstat-no" title="statement not covered" >Wi(s)?Object.assign(t,i):this._resolveAnimations(e,s).update(t,i)}<span class="fstat-no" title="function not covered" ></span>up</span>dateSharedOptions(t,e,i){<span class="cstat-no" title="statement not covered" >t&amp;&amp;!Wi(e)&amp;&amp;this._resolveAnimations(void 0,e).update(t,i)}<span class="fstat-no" title="function not covered" ></span>_s</span>etStyle(t,e,i,s){<span class="cstat-no" title="statement not covered" >t.active=s;c</span>onst n=<span class="cstat-no" title="statement not covered" >this.getStyle(e,s);<span class="cstat-no" title="statement not covered" ></span>this._resolveAnimations(e,i,s).update(t,{options:!s&amp;&amp;this.getSharedOptions(n)||n})}<span class="fstat-no" title="function not covered" ></span>re</span>moveHoverStyle(t,e,i){<span class="cstat-no" title="statement not covered" >this._setStyle(t,i,"active",!1)}<span class="fstat-no" title="function not covered" ></span>se</span>tHoverStyle(t,e,i){<span class="cstat-no" title="statement not covered" >this._setStyle(t,i,"active",!0)}<span class="fstat-no" title="function not covered" ></span>_r</span>emoveDatasetHoverStyle(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta.dataset;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;this._setStyle(t,void 0,"active",!1)}<span class="fstat-no" title="function not covered" ></span>_s</span>etDatasetHoverStyle(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta.dataset;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;this._setStyle(t,void 0,"active",!0)}<span class="fstat-no" title="function not covered" ></span>_r</span>esyncElements(t){const e=<span class="cstat-no" title="statement not covered" >this._data,</span>i=<span class="cstat-no" title="statement not covered" >this._cachedMeta.data;<span class="cstat-no" title="statement not covered" ></span>for(const[r,a,h]of this._syncList)<span class="cstat-no" title="statement not covered" >this[r](a,h);<span class="cstat-no" title="statement not covered" >t</span></span>his._syncList=[];c</span>onst s=<span class="cstat-no" title="statement not covered" >i.length,</span>n=<span class="cstat-no" title="statement not covered" >e.length,</span>o=<span class="cstat-no" title="statement not covered" >Math.min(n,s);<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;this.parse(0,o),n&gt;s?this._insertElements(s,n-s,t):n&lt;s&amp;&amp;this._removeElements(n,s-n)}<span class="fstat-no" title="function not covered" ></span>_i</span>nsertElements(t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>{const s=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>n=<span class="cstat-no" title="statement not covered" >s.data,</span>o=<span class="cstat-no" title="statement not covered" >t+e;</span>let r;const a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >for(t.length+=e,r=t.length-1;r&gt;=o;r--)<span class="cstat-no" title="statement not covered" >t[r]=t[r-e]}</span></span>;<span class="cstat-no" title="statement not covered" ></span>for(a(n),r=t;r&lt;o;++r)<span class="cstat-no" title="statement not covered" >n[r]=new this.dataElementType;<span class="cstat-no" title="statement not covered" >t</span></span>his._parsing&amp;&amp;a(s._parsed),this.parse(t,e),i&amp;&amp;this.updateElements(n,t,e,"reset")}<span class="fstat-no" title="function not covered" ></span>up</span>dateElements(t,e,i,s){}<span class="fstat-no" title="function not covered" >_r</span>emoveElements(t,e){const i=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>if(this._parsing){const s=<span class="cstat-no" title="statement not covered" >i._parsed.splice(t,e);<span class="cstat-no" title="statement not covered" ></span>i._stacked&amp;&amp;Bi(i,s)}<span class="cstat-no" title="statement not covered" ></span>i</span>.data.splice(t,e)}<span class="fstat-no" title="function not covered" ></span>_s</span>ync(t){<span class="cstat-no" title="statement not covered" >if(this._parsing)<span class="cstat-no" title="statement not covered" >this._syncList.push(t);e</span>lse{const[e,i,s]=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>this[e](i,s)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.chart._dataChanges.push([this.index,...t])}<span class="fstat-no" title="function not covered" ></span>_o</span>nDataPush(){const t=<span class="cstat-no" title="statement not covered" >arguments.length;<span class="cstat-no" title="statement not covered" ></span>this._sync(["_insertElements",this.getDataset().data.length-t,t])}<span class="fstat-no" title="function not covered" ></span>_o</span>nDataPop(){<span class="cstat-no" title="statement not covered" >this._sync(["_removeElements",this._cachedMeta.data.length-1,1])}<span class="fstat-no" title="function not covered" ></span>_o</span>nDataShift(){<span class="cstat-no" title="statement not covered" >this._sync(["_removeElements",0,1])}<span class="fstat-no" title="function not covered" ></span>_o</span>nDataSplice(t,e){<span class="cstat-no" title="statement not covered" >e&amp;&amp;this._sync(["_removeElements",t,e]);c</span>onst i=<span class="cstat-no" title="statement not covered" >arguments.length-2;<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;this._sync(["_insertElements",t,i])}<span class="fstat-no" title="function not covered" ></span>_o</span>nDataUnshift(){<span class="cstat-no" title="statement not covered" >this._sync(["_insertElements",0,arguments.length])}</span>}function <span class="fstat-no" title="function not covered" >ji(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.iScale,</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(!t._cache.$bar){const i=<span class="cstat-no" title="statement not covered" >t.getMatchingVisibleMetas(e);</span>let s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0,</span>n=<span class="cstat-no" title="statement not covered" >i.length;</span>e&lt;n;e++)<span class="cstat-no" title="statement not covered" >s=s.concat(i[e].controller.getAllParsedValues(t));<span class="cstat-no" title="statement not covered" >t</span></span>._cache.$bar=Lt(s.sort((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t-e)</span>))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t._cache.$bar}</span>(e,t.type);</span>let s,n,o,r,a=<span class="cstat-no" title="statement not covered" >e._length;</span>const h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >32767!==o&amp;&amp;-32768!==o&amp;&amp;(st(r)&amp;&amp;(a=Math.min(a,Math.abs(o-r)||a)),r=o)}</span>;<span class="cstat-no" title="statement not covered" ></span>for(s=0,n=i.length;s&lt;n;++s)<span class="cstat-no" title="statement not covered" >o=e.getPixelForValue(i[s]),h();<span class="cstat-no" title="statement not covered" >f</span></span>or(r=void 0,s=0,n=e.ticks.length;s&lt;n;++s)<span class="cstat-no" title="statement not covered" >o=e.getPixelForTick(s),h();<span class="cstat-no" title="statement not covered" >r</span></span>eturn a}</span>function <span class="fstat-no" title="function not covered" >Ni(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return W(t)?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >i.parse(t[0],s),</span>o=<span class="cstat-no" title="statement not covered" >i.parse(t[1],s),</span>r=<span class="cstat-no" title="statement not covered" >Math.min(n,o),</span>a=<span class="cstat-no" title="statement not covered" >Math.max(n,o);</span>let h=<span class="cstat-no" title="statement not covered" >r,</span>l=<span class="cstat-no" title="statement not covered" >a;<span class="cstat-no" title="statement not covered" ></span>Math.abs(r)&gt;Math.abs(a)&amp;&amp;(h=a,l=r),e[i.axis]=l,e._custom={barStart:h,barEnd:l,start:n,end:o,min:r,max:a}}</span>(t,e,i,s):e[i.axis]=i.parse(t,s),e}</span>function <span class="fstat-no" title="function not covered" >$i(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >t.iScale,</span>o=<span class="cstat-no" title="statement not covered" >t.vScale,</span>r=<span class="cstat-no" title="statement not covered" >n.getLabels(),</span>a=<span class="cstat-no" title="statement not covered" >n===o,</span>h=<span class="cstat-no" title="statement not covered" >[];</span>let l,c,d,u;<span class="cstat-no" title="statement not covered" >for(l=i,c=i+s;l&lt;c;++l)<span class="cstat-no" title="statement not covered" >u=e[l],d={},d[n.axis]=a||n.parse(r[l],l),h.push(Ni(u,d,o,l));<span class="cstat-no" title="statement not covered" >r</span></span>eturn h}</span>function <span class="fstat-no" title="function not covered" >Yi(</span>t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;void 0!==t.barStart&amp;&amp;void 0!==t.barEnd}</span>function <span class="fstat-no" title="function not covered" >Ui(</span>t,e,i,s){let n=<span class="cstat-no" title="statement not covered" >e.borderSkipped;</span>const o=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >return void(t.borderSkipped=o);<span class="cstat-no" title="statement not covered" >i</span></span>f(!0===n)<span class="cstat-no" title="statement not covered" >return void(t.borderSkipped={top:!0,right:!0,bottom:!0,left:!0});c</span></span>onst{start:r,end:a,reverse:h,top:l,bottom:c}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){let e,i,s,n,o;<span class="cstat-no" title="statement not covered" >return t.horizontal?(e=t.base&gt;t.x,i="left",s="right"):(e=t.base&lt;t.y,i="bottom",s="top"),e?(n="end",o="start"):(n="start",o="end"),{start:i,end:s,reverse:e,top:n,bottom:o}}</span>(t);<span class="cstat-no" title="statement not covered" ></span>"middle"===n&amp;&amp;i&amp;&amp;(t.enableBorderRadius=!0,(i._top||0)===s?n=l:(i._bottom||0)===s?n=c:(o[Xi(c,r,a,h)]=!0,n=l)),o[Xi(n,r,a,h)]=!0,t.borderSkipped=o}</span>function <span class="fstat-no" title="function not covered" >Xi(</span>t,e,i,s){var n,o,r;<span class="cstat-no" title="statement not covered" >return s?(r=i,t=qi(t=(n=t)===(o=e)?r:n===r?o:n,i,e)):t=qi(t,e,i),t}</span>function <span class="fstat-no" title="function not covered" >qi(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return"start"===t?e:"end"===t?i:t}</span>function <span class="fstat-no" title="function not covered" >Ki(</span>t,{inflateAmount:e},i){<span class="cstat-no" title="statement not covered" >t.inflateAmount="auto"===e?1===i?.33:0:e}</span>class Ji extends Vi{static id=<span class="cstat-no" title="statement not covered" >"bar";</span>static defaults=<span class="cstat-no" title="statement not covered" >{datasetElementType:!1,dataElementType:"bar",categoryPercentage:.8,barPercentage:.9,grouped:!0,animations:{numbers:{type:"number",properties:["x","y","base","width","height"]}}};</span>static overrides=<span class="cstat-no" title="statement not covered" >{scales:{_index_:{type:"category",offset:!0,grid:{offset:!0}},_value_:{type:"linear",beginAtZero:!0}}};<span class="fstat-no" title="function not covered" ></span>pa</span>rsePrimitiveData(t,e,i,s){<span class="cstat-no" title="statement not covered" >return $i(t,e,i,s)}<span class="fstat-no" title="function not covered" ></span>pa</span>rseArrayData(t,e,i,s){<span class="cstat-no" title="statement not covered" >return $i(t,e,i,s)}<span class="fstat-no" title="function not covered" ></span>pa</span>rseObjectData(t,e,i,s){const{iScale:n,vScale:o}=<span class="cstat-no" title="statement not covered" >t,</span>{xAxisKey:r=<span class="branch-0 cbranch-no" title="branch not covered" >"x",</span>yAxisKey:a=<span class="branch-0 cbranch-no" title="branch not covered" >"y"}</span>=<span class="cstat-no" title="statement not covered" >this._parsing,</span>h=<span class="cstat-no" title="statement not covered" >"x"===n.axis?r:a,</span>l=<span class="cstat-no" title="statement not covered" >"x"===o.axis?r:a,</span>c=<span class="cstat-no" title="statement not covered" >[];</span>let d,u,f,g;<span class="cstat-no" title="statement not covered" >for(d=i,u=i+s;d&lt;u;++d)<span class="cstat-no" title="statement not covered" >g=e[d],f={},f[n.axis]=n.parse(et(g,h),d),c.push(Ni(et(g,l),f,o,d));<span class="cstat-no" title="statement not covered" >r</span></span>eturn c}<span class="fstat-no" title="function not covered" ></span>up</span>dateRangeFromParsed(t,e,i,s){<span class="cstat-no" title="statement not covered" >super.updateRangeFromParsed(t,e,i,s);c</span>onst n=<span class="cstat-no" title="statement not covered" >i._custom;<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;e===this._cachedMeta.vScale&amp;&amp;(t.min=Math.min(t.min,n.min),t.max=Math.max(t.max,n.max))}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaxOverflow(){<span class="cstat-no" title="statement not covered" >return 0}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelAndValue(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>{iScale:i,vScale:s}=<span class="cstat-no" title="statement not covered" >e,</span>n=<span class="cstat-no" title="statement not covered" >this.getParsed(t),</span>o=<span class="cstat-no" title="statement not covered" >n._custom,</span>r=<span class="cstat-no" title="statement not covered" >Yi(o)?"["+o.start+", "+o.end+"]":""+s.getLabelForValue(n[s.axis]);<span class="cstat-no" title="statement not covered" ></span>return{label:""+i.getLabelForValue(n[i.axis]),value:r}}<span class="fstat-no" title="function not covered" ></span>in</span>itialize(){<span class="cstat-no" title="statement not covered" >this.enableOptionSharing=!0,super.initialize();<span class="cstat-no" title="statement not covered" >t</span>his._cachedMeta.stack=this.getDataset().stack}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>this.updateElements(e.data,0,e.data.length,t)}<span class="fstat-no" title="function not covered" ></span>up</span>dateElements(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >"reset"===s,</span>{index:o,_cachedMeta:{vScale:r}}=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" >r.getBasePixel(),</span>h=<span class="cstat-no" title="statement not covered" >r.isHorizontal(),</span>l=<span class="cstat-no" title="statement not covered" >this._getRuler(),</span>{sharedOptions:c,includeOptions:d}=<span class="cstat-no" title="statement not covered" >this._getSharedOptions(e,s);<span class="cstat-no" title="statement not covered" ></span>for(let u=<span class="cstat-no" title="statement not covered" >e;</span>u&lt;e+i;u++){const e=<span class="cstat-no" title="statement not covered" >this.getParsed(u),</span>i=<span class="cstat-no" title="statement not covered" >n||B(e[r.axis])?{base:a,head:a}:this._calculateBarValuePixels(u),</span>f=<span class="cstat-no" title="statement not covered" >this._calculateBarIndexPixels(u,l),</span>g=<span class="cstat-no" title="statement not covered" >(e._stacks||{})[r.axis],</span>p=<span class="cstat-no" title="statement not covered" >{horizontal:h,base:i.base,enableBorderRadius:!g||Yi(e._custom)||o===g._top||o===g._bottom,x:h?i.head:f.center,y:h?f.center:i.head,height:h?f.size:Math.abs(i.size),width:h?Math.abs(i.size):f.size};<span class="cstat-no" title="statement not covered" ></span>d&amp;&amp;(p.options=c||this.resolveDataElementOptions(u,t[u].active?"active":s));c</span>onst x=<span class="cstat-no" title="statement not covered" >p.options||t[u].options;<span class="cstat-no" title="statement not covered" ></span>Ui(p,x,g,o),Ki(p,x,l.ratio),this.updateElement(t[u],u,p,s)}</span>}<span class="fstat-no" title="function not covered" ></span>_g</span>etStacks(t,e){const{iScale:i}=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>s=<span class="cstat-no" title="statement not covered" >i.getMatchingVisibleMetas(this._type).filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.controller.options.grouped)</span>),</span>n=<span class="cstat-no" title="statement not covered" >i.options.stacked,</span>o=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >this._cachedMeta.controller.getParsed(e),</span>a=<span class="cstat-no" title="statement not covered" >r&amp;&amp;r[i.axis],</span>h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >t._parsed.find((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t[i.axis]===a)</span>),</span>s=<span class="cstat-no" title="statement not covered" >e&amp;&amp;e[t.vScale.axis];<span class="cstat-no" title="statement not covered" ></span>if(B(s)||isNaN(s))<span class="cstat-no" title="statement not covered" >return!0}</span></span>;<span class="cstat-no" title="statement not covered" ></span>for(const l of s)<span class="cstat-no" title="statement not covered" >if((void 0===e||!h(l))&amp;&amp;((!1===n||-1===o.indexOf(l.stack)||void 0===n&amp;&amp;void 0===l.stack)&amp;&amp;o.push(l.stack),l.index===t))<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn o.length||o.push(void 0),o}<span class="fstat-no" title="function not covered" ></span>_g</span>etStackCount(t){<span class="cstat-no" title="statement not covered" >return this._getStacks(void 0,t).length}<span class="fstat-no" title="function not covered" ></span>_g</span>etAxisCount(){<span class="cstat-no" title="statement not covered" >return this._getAxis().length}<span class="fstat-no" title="function not covered" ></span>ge</span>tFirstScaleIdForIndexAxis(){const t=<span class="cstat-no" title="statement not covered" >this.chart.scales,</span>e=<span class="cstat-no" title="statement not covered" >this.chart.options.indexAxis;<span class="cstat-no" title="statement not covered" ></span>return Object.keys(t).filter((<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >t[i].axis===e)</span>).shift()}<span class="fstat-no" title="function not covered" ></span>_g</span>etAxis(){const t=<span class="cstat-no" title="statement not covered" >{},</span>e=<span class="cstat-no" title="statement not covered" >this.getFirstScaleIdForIndexAxis();<span class="cstat-no" title="statement not covered" ></span>for(const i of this.chart.data.datasets)<span class="cstat-no" title="statement not covered" >t[N("x"===this.chart.options.indexAxis?i.xAxisID:i.yAxisID,e)]=!0;<span class="cstat-no" title="statement not covered" >r</span></span>eturn Object.keys(t)}<span class="fstat-no" title="function not covered" ></span>_g</span>etStackIndex(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this._getStacks(t,i),</span>n=<span class="cstat-no" title="statement not covered" >void 0!==e?s.indexOf(e):-1;<span class="cstat-no" title="statement not covered" ></span>return-1===n?s.length-1:n}<span class="fstat-no" title="function not covered" ></span>_g</span>etRuler(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>i=<span class="cstat-no" title="statement not covered" >e.iScale,</span>s=<span class="cstat-no" title="statement not covered" >[];</span>let n,o;<span class="cstat-no" title="statement not covered" >for(n=0,o=e.data.length;n&lt;o;++n)<span class="cstat-no" title="statement not covered" >s.push(i.getPixelForValue(this.getParsed(n)[i.axis],n));c</span></span>onst r=<span class="cstat-no" title="statement not covered" >t.barThickness;<span class="cstat-no" title="statement not covered" ></span>return{min:r||ji(e),pixels:s,start:i._startPixel,end:i._endPixel,stackCount:this._getStackCount(),scale:i,grouped:t.grouped,ratio:r?1:t.categoryPercentage*t.barPercentage}}<span class="fstat-no" title="function not covered" ></span>_c</span>alculateBarValuePixels(t){const{_cachedMeta:{vScale:e,_stacked:i,index:s},options:{base:n,minBarLength:o}}=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >n||0,</span>a=<span class="cstat-no" title="statement not covered" >this.getParsed(t),</span>h=<span class="cstat-no" title="statement not covered" >a._custom,</span>l=<span class="cstat-no" title="statement not covered" >Yi(h);</span>let c,d,u=<span class="cstat-no" title="statement not covered" >a[e.axis],</span>f=<span class="cstat-no" title="statement not covered" >0,</span>g=<span class="cstat-no" title="statement not covered" >i?this.applyStack(e,a,i):u;<span class="cstat-no" title="statement not covered" ></span>g!==u&amp;&amp;(f=g-u,g=u),l&amp;&amp;(u=h.barStart,g=h.barEnd-h.barStart,0!==u&amp;&amp;pt(u)!==pt(h.barEnd)&amp;&amp;(f=0),f+=u);c</span>onst p=<span class="cstat-no" title="statement not covered" >B(n)||l?f:n;</span>let x=<span class="cstat-no" title="statement not covered" >e.getPixelForValue(p);<span class="cstat-no" title="statement not covered" ></span>if(c=this.chart.getDataVisibility(t)?e.getPixelForValue(f+g):x,d=c-x,Math.abs(d)&lt;o){<span class="cstat-no" title="statement not covered" >d=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return 0!==t?pt(t):(e.isHorizontal()?1:-1)*(e.min&gt;=i?1:-1)}</span>(d,e,r)*o,u===r&amp;&amp;(x-=d/2);c</span>onst t=<span class="cstat-no" title="statement not covered" >e.getPixelForDecimal(0),</span>n=<span class="cstat-no" title="statement not covered" >e.getPixelForDecimal(1),</span>h=<span class="cstat-no" title="statement not covered" >Math.min(t,n),</span>f=<span class="cstat-no" title="statement not covered" >Math.max(t,n);<span class="cstat-no" title="statement not covered" ></span>x=Math.max(Math.min(x,f),h),c=x+d,i&amp;&amp;!l&amp;&amp;(a._stacks[e.axis]._visualValues[s]=e.getValueForPixel(c)-e.getValueForPixel(x))}<span class="cstat-no" title="statement not covered" ></span>i</span>f(x===e.getPixelForValue(r)){const t=<span class="cstat-no" title="statement not covered" >pt(d)*e.getLineWidthForValue(r)/2;<span class="cstat-no" title="statement not covered" ></span>x+=t,d-=t}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{size:d,base:x,head:c,center:c+d/2}}<span class="fstat-no" title="function not covered" ></span>_c</span>alculateBarIndexPixels(t,e){const i=<span class="cstat-no" title="statement not covered" >e.scale,</span>s=<span class="cstat-no" title="statement not covered" >this.options,</span>n=<span class="cstat-no" title="statement not covered" >s.skipNull,</span>o=<span class="cstat-no" title="statement not covered" >N(s.maxBarThickness,1/0);</span>let r,a;const h=<span class="cstat-no" title="statement not covered" >this._getAxisCount();<span class="cstat-no" title="statement not covered" ></span>if(e.grouped){const i=<span class="cstat-no" title="statement not covered" >n?this._getStackCount(t):e.stackCount,</span>l=<span class="cstat-no" title="statement not covered" >"flex"===s.barThickness?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >e.pixels,</span>o=<span class="cstat-no" title="statement not covered" >n[t];</span>let r=<span class="cstat-no" title="statement not covered" >t&gt;0?n[t-1]:null,</span>a=<span class="cstat-no" title="statement not covered" >t&lt;n.length-1?n[t+1]:null;</span>const h=<span class="cstat-no" title="statement not covered" >i.categoryPercentage;<span class="cstat-no" title="statement not covered" ></span>null===r&amp;&amp;(r=o-(null===a?e.end-e.start:a-o)),null===a&amp;&amp;(a=o+o-r);c</span>onst l=<span class="cstat-no" title="statement not covered" >o-(o-Math.min(r,a))/2*h;<span class="cstat-no" title="statement not covered" ></span>return{chunk:Math.abs(a-r)/2*h/s,ratio:i.barPercentage,start:l}}</span>(t,e,s,i*h):<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >i.barThickness;</span>let o,r;<span class="cstat-no" title="statement not covered" >return B(n)?(o=e.min*i.categoryPercentage,r=i.barPercentage):(o=n*s,r=1),{chunk:o/s,ratio:r,start:e.pixels[t]-o/2}}</span>(t,e,s,i*h),</span>c=<span class="cstat-no" title="statement not covered" >"x"===this.chart.options.indexAxis?this.getDataset().xAxisID:this.getDataset().yAxisID,</span>d=<span class="cstat-no" title="statement not covered" >this._getAxis().indexOf(N(c,this.getFirstScaleIdForIndexAxis())),</span>u=<span class="cstat-no" title="statement not covered" >this._getStackIndex(this.index,this._cachedMeta.stack,n?t:void 0)+d;<span class="cstat-no" title="statement not covered" ></span>r=l.start+l.chunk*u+l.chunk/2,a=Math.min(o,l.chunk*l.ratio)}</span>else <span class="cstat-no" title="statement not covered" >r=i.getPixelForValue(this.getParsed(t)[i.axis],t),a=Math.min(o,e.min*e.ratio);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{base:r-a/2,head:r+a/2,center:r,size:a}}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>e=<span class="cstat-no" title="statement not covered" >t.vScale,</span>i=<span class="cstat-no" title="statement not covered" >t.data,</span>s=<span class="cstat-no" title="statement not covered" >i.length;</span>let n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;n&lt;s;++n)<span class="cstat-no" title="statement not covered" >null===this.getParsed(n)[e.axis]||i[n].hidden||i[n].draw(this._ctx)}</span></span>}class Gi extends Vi{static id=<span class="cstat-no" title="statement not covered" >"doughnut";</span>static defaults=<span class="cstat-no" title="statement not covered" >{datasetElementType:!1,dataElementType:"arc",animation:{animateRotate:!0,animateScale:!1},animations:{numbers:{type:"number",properties:["circumference","endAngle","innerRadius","outerRadius","startAngle","x","y","offset","borderWidth","spacing"]}},cutout:"50%",rotation:0,circumference:360,radius:"100%",spacing:0,indexAxis:"r"};</span>static descriptors=<span class="cstat-no" title="statement not covered" >{_scriptable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"spacing"!==t,</span>_indexable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"spacing"!==t&amp;&amp;!t.startsWith("borderDash")&amp;&amp;!t.startsWith("hoverBorderDash")}</span>;</span>static overrides=<span class="cstat-no" title="statement not covered" >{aspectRatio:1,plugins:{legend:{labels:{<span class="fstat-no" title="function not covered" >ge</span>nerateLabels(t){const e=<span class="cstat-no" title="statement not covered" >t.data,</span>{labels:{pointStyle:i,textAlign:s,color:n,useBorderRadius:o,borderRadius:r}}=<span class="cstat-no" title="statement not covered" >t.legend.options;<span class="cstat-no" title="statement not covered" ></span>return e.labels.length&amp;&amp;e.datasets.length?e.labels.map((<span class="fstat-no" title="function not covered" >(e</span>,a)=&gt;{const h=<span class="cstat-no" title="statement not covered" >t.getDatasetMeta(0).controller.getStyle(a);<span class="cstat-no" title="statement not covered" ></span>return{text:e,fillStyle:h.backgroundColor,fontColor:n,hidden:!t.getDataVisibility(a),lineDash:h.borderDash,lineDashOffset:h.borderDashOffset,lineJoin:h.borderJoinStyle,lineWidth:h.borderWidth,strokeStyle:h.borderColor,textAlign:s,pointStyle:i,borderRadius:o&amp;&amp;(r||h.borderRadius),index:a}}</span>)):[]}</span>},<span class="fstat-no" title="function not covered" >on</span>Click(t,e,i){<span class="cstat-no" title="statement not covered" >i.chart.toggleDataVisibility(e.index),i.chart.update()}</span>}}};<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >super(t,e),this.enableOptionSharing=!0,this.innerRadius=void 0,this.outerRadius=void 0,this.offsetX=void 0,this.offsetY=void 0}<span class="fstat-no" title="function not covered" ></span>li</span>nkScales(){}<span class="fstat-no" title="function not covered" >pa</span>rse(t,e){const i=<span class="cstat-no" title="statement not covered" >this.getDataset().data,</span>s=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>if(!1===this._parsing)<span class="cstat-no" title="statement not covered" >s._parsed=i;e</span>lse{let n,o,r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >+i[t];<span class="cstat-no" title="statement not covered" ></span></span>if(H(i[t])){const{key:t=<span class="branch-0 cbranch-no" title="branch not covered" >"value"}</span>=<span class="cstat-no" title="statement not covered" >this._parsing;<span class="cstat-no" title="statement not covered" ></span>r=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >+et(i[e],t)}<span class="cstat-no" title="statement not covered" ></span></span>f</span>or(n=t,o=t+e;n&lt;o;++n)<span class="cstat-no" title="statement not covered" >s._parsed[n]=r(n)}</span></span>}<span class="fstat-no" title="function not covered" ></span>_g</span>etRotation(){<span class="cstat-no" title="statement not covered" >return yt(this.options.rotation-90)}<span class="fstat-no" title="function not covered" ></span>_g</span>etCircumference(){<span class="cstat-no" title="statement not covered" >return yt(this.options.circumference)}<span class="fstat-no" title="function not covered" ></span>_g</span>etRotationExtents(){let t=<span class="cstat-no" title="statement not covered" >at,</span>e=<span class="cstat-no" title="statement not covered" >-at;<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;this.chart.data.datasets.length;++i)<span class="cstat-no" title="statement not covered" >if(this.chart.isDatasetVisible(i)&amp;&amp;this.chart.getDatasetMeta(i).type===this._type){const s=<span class="cstat-no" title="statement not covered" >this.chart.getDatasetMeta(i).controller,</span>n=<span class="cstat-no" title="statement not covered" >s._getRotation(),</span>o=<span class="cstat-no" title="statement not covered" >s._getCircumference();<span class="cstat-no" title="statement not covered" ></span>t=Math.min(t,n),e=Math.max(e,n+o)}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn{rotation:t,circumference:e-t}}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){const e=<span class="cstat-no" title="statement not covered" >this.chart,</span>{chartArea:i}=<span class="cstat-no" title="statement not covered" >e,</span>s=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>n=<span class="cstat-no" title="statement not covered" >s.data,</span>o=<span class="cstat-no" title="statement not covered" >this.getMaxBorderWidth()+this.getMaxOffset(n)+this.options.spacing,</span>r=<span class="cstat-no" title="statement not covered" >Math.max((Math.min(i.width,i.height)-o)/2,0),</span>a=<span class="cstat-no" title="statement not covered" >Math.min((h=this.options.cutout,l=r,"string"===typeof h&amp;&amp;h.endsWith("%")?parseFloat(h)/100:+h/l),1);</span>var h,l;const c=<span class="cstat-no" title="statement not covered" >this._getRingWeight(this.index),</span>{circumference:d,rotation:u}=<span class="cstat-no" title="statement not covered" >this._getRotationExtents(),</span>{ratioX:f,ratioY:g,offsetX:p,offsetY:x}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){let s=<span class="cstat-no" title="statement not covered" >1,</span>n=<span class="cstat-no" title="statement not covered" >1,</span>o=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(e&lt;at){const a=<span class="cstat-no" title="statement not covered" >t,</span>h=<span class="cstat-no" title="statement not covered" >a+e,</span>l=<span class="cstat-no" title="statement not covered" >Math.cos(a),</span>c=<span class="cstat-no" title="statement not covered" >Math.sin(a),</span>d=<span class="cstat-no" title="statement not covered" >Math.cos(h),</span>u=<span class="cstat-no" title="statement not covered" >Math.sin(h),</span>f=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;<span class="cstat-no" title="statement not covered" >Dt(t,a,h,!0)?1:Math.max(e,e*i,s,s*i),</span></span>g=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;<span class="cstat-no" title="statement not covered" >Dt(t,a,h,!0)?-1:Math.min(e,e*i,s,s*i),</span></span>p=<span class="cstat-no" title="statement not covered" >f(0,l,d),</span>x=<span class="cstat-no" title="statement not covered" >f(dt,c,u),</span>m=<span class="cstat-no" title="statement not covered" >g(rt,l,d),</span>b=<span class="cstat-no" title="statement not covered" >g(rt+dt,c,u);<span class="cstat-no" title="statement not covered" ></span>s=(p-m)/2,n=(x-b)/2,o=-(p+m)/2,r=-(x+b)/2}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{ratioX:s,ratioY:n,offsetX:o,offsetY:r}}</span>(u,d,a),</span>m=<span class="cstat-no" title="statement not covered" >(i.width-o)/f,</span>b=<span class="cstat-no" title="statement not covered" >(i.height-o)/g,</span>_=<span class="cstat-no" title="statement not covered" >Math.max(Math.min(m,b)/2,0),</span>y=<span class="cstat-no" title="statement not covered" >$(this.options.radius,_),</span>v=<span class="cstat-no" title="statement not covered" >(y-Math.max(y*a,0))/this._getVisibleDatasetWeightTotal();<span class="cstat-no" title="statement not covered" ></span>this.offsetX=p*y,this.offsetY=x*y,s.total=this.calculateTotal(),this.outerRadius=y-v*this._getRingWeightOffset(this.index),this.innerRadius=Math.max(this.outerRadius-v*c,0),this.updateElements(n,0,n.length,t)}<span class="fstat-no" title="function not covered" ></span>_c</span>ircumference(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options,</span>s=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>n=<span class="cstat-no" title="statement not covered" >this._getCircumference();<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;i.animation.animateRotate||!this.chart.getDataVisibility(t)||null===s._parsed[t]||s.data[t].hidden?0:this.calculateCircumference(s._parsed[t]*n/at)}<span class="fstat-no" title="function not covered" ></span>up</span>dateElements(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >"reset"===s,</span>o=<span class="cstat-no" title="statement not covered" >this.chart,</span>r=<span class="cstat-no" title="statement not covered" >o.chartArea,</span>a=<span class="cstat-no" title="statement not covered" >o.options.animation,</span>h=<span class="cstat-no" title="statement not covered" >(r.left+r.right)/2,</span>l=<span class="cstat-no" title="statement not covered" >(r.top+r.bottom)/2,</span>c=<span class="cstat-no" title="statement not covered" >n&amp;&amp;a.animateScale,</span>d=<span class="cstat-no" title="statement not covered" >c?0:this.innerRadius,</span>u=<span class="cstat-no" title="statement not covered" >c?0:this.outerRadius,</span>{sharedOptions:f,includeOptions:g}=<span class="cstat-no" title="statement not covered" >this._getSharedOptions(e,s);</span>let p,x=<span class="cstat-no" title="statement not covered" >this._getRotation();<span class="cstat-no" title="statement not covered" ></span>for(p=0;p&lt;e;++p)<span class="cstat-no" title="statement not covered" >x+=this._circumference(p,n);<span class="cstat-no" title="statement not covered" >f</span></span>or(p=e;p&lt;e+i;++p){const e=<span class="cstat-no" title="statement not covered" >this._circumference(p,n),</span>i=<span class="cstat-no" title="statement not covered" >t[p],</span>o=<span class="cstat-no" title="statement not covered" >{x:h+this.offsetX,y:l+this.offsetY,startAngle:x,endAngle:x+e,circumference:e,outerRadius:u,innerRadius:d};<span class="cstat-no" title="statement not covered" ></span>g&amp;&amp;(o.options=f||this.resolveDataElementOptions(p,i.active?"active":s)),x+=e,this.updateElement(i,p,o,s)}</span>}<span class="fstat-no" title="function not covered" ></span>ca</span>lculateTotal(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>e=<span class="cstat-no" title="statement not covered" >t.data;</span>let i,s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(i=0;i&lt;e.length;i++){const n=<span class="cstat-no" title="statement not covered" >t._parsed[i];<span class="cstat-no" title="statement not covered" ></span>null===n||isNaN(n)||!this.chart.getDataVisibility(i)||e[i].hidden||(s+=Math.abs(n))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>ca</span>lculateCircumference(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta.total;<span class="cstat-no" title="statement not covered" ></span>return e&gt;0&amp;&amp;!isNaN(t)?at*(Math.abs(t)/e):0}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelAndValue(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>i=<span class="cstat-no" title="statement not covered" >this.chart,</span>s=<span class="cstat-no" title="statement not covered" >i.data.labels||[],</span>n=<span class="cstat-no" title="statement not covered" >Zt(e._parsed[t],i.options.locale);<span class="cstat-no" title="statement not covered" ></span>return{label:s[t]||"",value:n}}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaxBorderWidth(t){let e=<span class="cstat-no" title="statement not covered" >0;</span>const i=<span class="cstat-no" title="statement not covered" >this.chart;</span>let s,n,o,r,a;<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >for(s=0,n=i.data.datasets.length;s&lt;n;++s)<span class="cstat-no" title="statement not covered" >if(i.isDatasetVisible(s)){<span class="cstat-no" title="statement not covered" >o=i.getDatasetMeta(s),t=o.data,r=o.controller;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span></span></span>f(!t)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >f</span></span>or(s=0,n=t.length;s&lt;n;++s)<span class="cstat-no" title="statement not covered" >a=r.resolveDataElementOptions(s),"inner"!==a.borderAlign&amp;&amp;(e=Math.max(e,a.borderWidth||0,a.hoverBorderWidth||0));<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaxOffset(t){let e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >t.length;</span>i&lt;s;++i){const t=<span class="cstat-no" title="statement not covered" >this.resolveDataElementOptions(i);<span class="cstat-no" title="statement not covered" ></span>e=Math.max(e,t.offset||0,t.hoverOffset||0)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}<span class="fstat-no" title="function not covered" ></span>_g</span>etRingWeightOffset(t){let e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;t;++i)<span class="cstat-no" title="statement not covered" >this.chart.isDatasetVisible(i)&amp;&amp;(e+=this._getRingWeight(i));<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}<span class="fstat-no" title="function not covered" ></span>_g</span>etRingWeight(t){<span class="cstat-no" title="statement not covered" >return Math.max(N(this.chart.data.datasets[t].weight,1),0)}<span class="fstat-no" title="function not covered" ></span>_g</span>etVisibleDatasetWeightTotal(){<span class="cstat-no" title="statement not covered" >return this._getRingWeightOffset(this.chart.data.datasets.length)||1}</span>}class Zi extends Vi{static id=<span class="cstat-no" title="statement not covered" >"line";</span>static defaults=<span class="cstat-no" title="statement not covered" >{datasetElementType:"line",dataElementType:"point",showLine:!0,spanGaps:!1};</span>static overrides=<span class="cstat-no" title="statement not covered" >{scales:{_index_:{type:"category"},_value_:{type:"linear"}}};<span class="fstat-no" title="function not covered" ></span>in</span>itialize(){<span class="cstat-no" title="statement not covered" >this.enableOptionSharing=!0,this.supportsDecimation=!0,super.initialize()}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>{dataset:i,data:s=<span class="branch-0 cbranch-no" title="branch not covered" >[],</span>_dataset:n}=<span class="cstat-no" title="statement not covered" >e,</span>o=<span class="cstat-no" title="statement not covered" >this.chart._animationsDisabled;</span>let{start:r,count:a}=<span class="cstat-no" title="statement not covered" >Ht(e,s,o);<span class="cstat-no" title="statement not covered" ></span>this._drawStart=r,this._drawCount=a,Vt(e)&amp;&amp;(r=0,a=s.length),i._chart=this.chart,i._datasetIndex=this.index,i._decimated=!!n._decimated,i.points=s;c</span>onst h=<span class="cstat-no" title="statement not covered" >this.resolveDatasetElementOptions(t);<span class="cstat-no" title="statement not covered" ></span>this.options.showLine||(h.borderWidth=0),h.segment=this.options.segment,this.updateElement(i,void 0,{animated:!o,options:h},t),this.updateElements(s,r,a,t)}<span class="fstat-no" title="function not covered" ></span>up</span>dateElements(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >"reset"===s,</span>{iScale:o,vScale:r,_stacked:a,_dataset:h}=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>{sharedOptions:l,includeOptions:c}=<span class="cstat-no" title="statement not covered" >this._getSharedOptions(e,s),</span>d=<span class="cstat-no" title="statement not covered" >o.axis,</span>u=<span class="cstat-no" title="statement not covered" >r.axis,</span>{spanGaps:f,segment:g}=<span class="cstat-no" title="statement not covered" >this.options,</span>p=<span class="cstat-no" title="statement not covered" >bt(f)?f:Number.POSITIVE_INFINITY,</span>x=<span class="cstat-no" title="statement not covered" >this.chart._animationsDisabled||n||"none"===s,</span>m=<span class="cstat-no" title="statement not covered" >e+i,</span>b=<span class="cstat-no" title="statement not covered" >t.length;</span>let _=<span class="cstat-no" title="statement not covered" >e&gt;0&amp;&amp;this.getParsed(e-1);<span class="cstat-no" title="statement not covered" ></span>for(let y=<span class="cstat-no" title="statement not covered" >0;</span>y&lt;b;++y){const i=<span class="cstat-no" title="statement not covered" >t[y],</span>f=<span class="cstat-no" title="statement not covered" >x?i:{};<span class="cstat-no" title="statement not covered" ></span>if(y&lt;e||y&gt;=m){<span class="cstat-no" title="statement not covered" >f.skip=!0;<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>c</span>onst b=<span class="cstat-no" title="statement not covered" >this.getParsed(y),</span>v=<span class="cstat-no" title="statement not covered" >B(b[u]),</span>w=<span class="cstat-no" title="statement not covered" >f[d]=o.getPixelForValue(b[d],y),</span>M=<span class="cstat-no" title="statement not covered" >f[u]=n||v?r.getBasePixel():r.getPixelForValue(a?this.applyStack(r,b,a):b[u],y);<span class="cstat-no" title="statement not covered" ></span>f.skip=isNaN(w)||isNaN(M)||v,f.stop=y&gt;0&amp;&amp;Math.abs(b[d]-_[d])&gt;p,g&amp;&amp;(f.parsed=b,f.raw=h.data[y]),c&amp;&amp;(f.options=l||this.resolveDataElementOptions(y,i.active?"active":s)),x||this.updateElement(i,y,f,s),_=b}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaxOverflow(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>e=<span class="cstat-no" title="statement not covered" >t.dataset,</span>i=<span class="cstat-no" title="statement not covered" >e.options&amp;&amp;e.options.borderWidth||0,</span>s=<span class="cstat-no" title="statement not covered" >t.data||[];<span class="cstat-no" title="statement not covered" ></span>if(!s.length)<span class="cstat-no" title="statement not covered" >return i;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >s[0].size(this.resolveDataElementOptions(0)),</span>o=<span class="cstat-no" title="statement not covered" >s[s.length-1].size(this.resolveDataElementOptions(s.length-1));<span class="cstat-no" title="statement not covered" ></span>return Math.max(i,n,o)/2}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>t.dataset.updateControlPoints(this.chart.chartArea,t.iScale.axis),super.draw()}</span>}class Qi extends Gi{static id=<span class="cstat-no" title="statement not covered" >"pie";</span>static defaults=<span class="cstat-no" title="statement not covered" >{cutout:0,rotation:0,circumference:360,radius:"100%"}}</span>function <span class="fstat-no" title="function not covered" >ts(</span>t,e,i,s){const{controller:n,data:o,_sorted:r}=<span class="cstat-no" title="statement not covered" >t,</span>a=<span class="cstat-no" title="statement not covered" >n._cachedMeta.iScale,</span>h=<span class="cstat-no" title="statement not covered" >t.dataset&amp;&amp;t.dataset.options?t.dataset.options.spanGaps:null;<span class="cstat-no" title="statement not covered" ></span>if(a&amp;&amp;e===a.axis&amp;&amp;"r"!==e&amp;&amp;r&amp;&amp;o.length){const r=<span class="cstat-no" title="statement not covered" >a._reversePixels?Rt:Tt;<span class="cstat-no" title="statement not covered" ></span>if(!s){const s=<span class="cstat-no" title="statement not covered" >r(o,e,i);<span class="cstat-no" title="statement not covered" ></span>if(h){const{vScale:e}=<span class="cstat-no" title="statement not covered" >n._cachedMeta,</span>{_parsed:i}=<span class="cstat-no" title="statement not covered" >t,</span>o=<span class="cstat-no" title="statement not covered" >i.slice(0,s.lo+1).reverse().findIndex((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!B(t[e.axis]))</span>);<span class="cstat-no" title="statement not covered" ></span>s.lo-=Math.max(0,o);c</span>onst r=<span class="cstat-no" title="statement not covered" >i.slice(s.hi).findIndex((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!B(t[e.axis]))</span>);<span class="cstat-no" title="statement not covered" ></span>s.hi+=Math.max(0,r)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}<span class="cstat-no" title="statement not covered" ></span>i</span>f(n._sharedOptions){const t=<span class="cstat-no" title="statement not covered" >o[0],</span>s=<span class="cstat-no" title="statement not covered" >"function"===typeof t.getRange&amp;&amp;t.getRange(e);<span class="cstat-no" title="statement not covered" ></span>if(s){const t=<span class="cstat-no" title="statement not covered" >r(o,e,i-s),</span>n=<span class="cstat-no" title="statement not covered" >r(o,e,i+s);<span class="cstat-no" title="statement not covered" ></span>return{lo:t.lo,hi:n.hi}}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{lo:0,hi:o.length-1}}</span>function <span class="fstat-no" title="function not covered" >es(</span>t,e,i,s,n){const o=<span class="cstat-no" title="statement not covered" >t.getSortedVisibleDatasetMetas(),</span>r=<span class="cstat-no" title="statement not covered" >i[e];<span class="cstat-no" title="statement not covered" ></span>for(let a=<span class="cstat-no" title="statement not covered" >0,</span>h=<span class="cstat-no" title="statement not covered" >o.length;</span>a&lt;h;++a){const{index:t,data:i}=<span class="cstat-no" title="statement not covered" >o[a],</span>{lo:h,hi:l}=<span class="cstat-no" title="statement not covered" >ts(o[a],e,r,n);<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >h;</span>e&lt;=l;++e){const n=<span class="cstat-no" title="statement not covered" >i[e];<span class="cstat-no" title="statement not covered" ></span>n.skip||s(n,t,e)}</span>}</span>}</span>function <span class="fstat-no" title="function not covered" >is(</span>t,e,i,s,n){const o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(!n&amp;&amp;!t.isPointInArea(e))<span class="cstat-no" title="statement not covered" >return o;<span class="cstat-no" title="statement not covered" >r</span></span>eturn es(t,i,e,(<span class="fstat-no" title="function not covered" >fu</span>nction(i,r,a){<span class="cstat-no" title="statement not covered" >(n||ue(i,t.chartArea,0))&amp;&amp;i.inRange(e.x,e.y,s)&amp;&amp;o.push({element:i,datasetIndex:r,index:a})}</span>),!0),o}</span>function <span class="fstat-no" title="function not covered" >ss(</span>t,e,i,s,n,o){let r=<span class="cstat-no" title="statement not covered" >[];</span>const a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >-1!==t.indexOf("x"),</span>i=<span class="cstat-no" title="statement not covered" >-1!==t.indexOf("y");<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(t,s){const n=<span class="cstat-no" title="statement not covered" >e?Math.abs(t.x-s.x):0,</span>o=<span class="cstat-no" title="statement not covered" >i?Math.abs(t.y-s.y):0;<span class="cstat-no" title="statement not covered" ></span>return Math.sqrt(Math.pow(n,2)+Math.pow(o,2))}</span>}</span>(i);</span>let h=<span class="cstat-no" title="statement not covered" >Number.POSITIVE_INFINITY;<span class="cstat-no" title="statement not covered" ></span>return es(t,i,e,(<span class="fstat-no" title="function not covered" >fu</span>nction(i,l,c){const d=<span class="cstat-no" title="statement not covered" >i.inRange(e.x,e.y,n);<span class="cstat-no" title="statement not covered" ></span>if(s&amp;&amp;!d)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst u=<span class="cstat-no" title="statement not covered" >i.getCenterPoint(n);<span class="cstat-no" title="statement not covered" ></span>if(!(!!o||t.isPointInArea(u))&amp;&amp;!d)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst f=<span class="cstat-no" title="statement not covered" >a(e,u);<span class="cstat-no" title="statement not covered" ></span>f&lt;h?(r=[{element:i,datasetIndex:l,index:c}],h=f):f===h&amp;&amp;r.push({element:i,datasetIndex:l,index:c})}</span>)),r}</span>function <span class="fstat-no" title="function not covered" >ns(</span>t,e,i,s,n,o){<span class="cstat-no" title="statement not covered" >return o||t.isPointInArea(e)?"r"!==i||s?ss(t,e,i,s,n,o):<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){let n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return es(t,i,e,(<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,o){const{startAngle:r,endAngle:a}=<span class="cstat-no" title="statement not covered" >t.getProps(["startAngle","endAngle"],s),</span>{angle:h}=<span class="cstat-no" title="statement not covered" >Mt(t,{x:e.x,y:e.y});<span class="cstat-no" title="statement not covered" ></span>Dt(h,r,a)&amp;&amp;n.push({element:t,datasetIndex:i,index:o})}</span>)),n}</span>(t,e,i,n):[]}</span>function <span class="fstat-no" title="function not covered" >os(</span>t,e,i,s,n){const o=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >"x"===i?"inXRange":"inYRange";</span>let a=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return es(t,i,e,(<span class="fstat-no" title="function not covered" >(t</span>,s,h)=&gt;{<span class="cstat-no" title="statement not covered" >t[r]&amp;&amp;t[r](e[i],n)&amp;&amp;(o.push({element:t,datasetIndex:s,index:h}),a=a||t.inRange(e.x,e.y,n))}</span>)),s&amp;&amp;!a?[]:o}</span>var rs=<span class="cstat-no" title="statement not covered" >{evaluateInteractionItems:es,modes:{<span class="fstat-no" title="function not covered" >in</span>dex(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >si(e,t),</span>o=<span class="cstat-no" title="statement not covered" >i.axis||"x",</span>r=<span class="cstat-no" title="statement not covered" >i.includeInvisible||!1,</span>a=<span class="cstat-no" title="statement not covered" >i.intersect?is(t,n,o,s,r):ns(t,n,o,!1,s,r),</span>h=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return a.length?(t.getSortedVisibleDatasetMetas().forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >a[0].index,</span>i=<span class="cstat-no" title="statement not covered" >t.data[e];<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;!i.skip&amp;&amp;h.push({element:i,datasetIndex:t.index,index:e})}</span>)),h):[]}</span>,<span class="fstat-no" title="function not covered" >da</span>taset(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >si(e,t),</span>o=<span class="cstat-no" title="statement not covered" >i.axis||"xy",</span>r=<span class="cstat-no" title="statement not covered" >i.includeInvisible||!1;</span>let a=<span class="cstat-no" title="statement not covered" >i.intersect?is(t,n,o,s,r):ns(t,n,o,!1,s,r);<span class="cstat-no" title="statement not covered" ></span>if(a.length&gt;0){const e=<span class="cstat-no" title="statement not covered" >a[0].datasetIndex,</span>i=<span class="cstat-no" title="statement not covered" >t.getDatasetMeta(e).data;<span class="cstat-no" title="statement not covered" ></span>a=[];<span class="cstat-no" title="statement not covered" >f</span>or(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;i.length;++t)<span class="cstat-no" title="statement not covered" >a.push({element:i[t],datasetIndex:e,index:t})}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn a}</span>,point:<span class="fstat-no" title="function not covered" >(t</span>,e,i,s)=&gt;<span class="cstat-no" title="statement not covered" >is(t,si(e,t),i.axis||"xy",s,i.includeInvisible||!1),<span class="fstat-no" title="function not covered" ></span>ne</span>arest(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >si(e,t),</span>o=<span class="cstat-no" title="statement not covered" >i.axis||"xy",</span>r=<span class="cstat-no" title="statement not covered" >i.includeInvisible||!1;<span class="cstat-no" title="statement not covered" ></span>return ns(t,n,o,i.intersect,s,r)}</span>,x:<span class="fstat-no" title="function not covered" >(t</span>,e,i,s)=&gt;<span class="cstat-no" title="statement not covered" >os(t,si(e,t),"x",i.intersect,s),</span>y:<span class="fstat-no" title="function not covered" >(t</span>,e,i,s)=&gt;<span class="cstat-no" title="statement not covered" >os(t,si(e,t),"y",i.intersect,s)}</span>};</span>const as=<span class="cstat-no" title="statement not covered" >["left","top","right","bottom"];</span>function <span class="fstat-no" title="function not covered" >hs(</span>t,e){<span class="cstat-no" title="statement not covered" >return t.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.pos===e)</span>)}</span>function <span class="fstat-no" title="function not covered" >ls(</span>t,e){<span class="cstat-no" title="statement not covered" >return t.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >-1===as.indexOf(t.pos)&amp;&amp;t.box.axis===e)</span>)}</span>function <span class="fstat-no" title="function not covered" >cs(</span>t,e){<span class="cstat-no" title="statement not covered" >return t.sort((<span class="fstat-no" title="function not covered" >(t</span>,i)=&gt;{const s=<span class="cstat-no" title="statement not covered" >e?i:t,</span>n=<span class="cstat-no" title="statement not covered" >e?t:i;<span class="cstat-no" title="statement not covered" ></span>return s.weight===n.weight?s.index-n.index:s.weight-n.weight}</span>))}</span>function <span class="fstat-no" title="function not covered" >ds(</span>t,e){const i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(const i of t){const{stack:t,pos:s,stackWeight:n}=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>if(!t||!as.includes(s))<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >e[t]||(e[t]={count:0,placed:0,weight:0,size:0});<span class="cstat-no" title="statement not covered" ></span>o.count++,o.weight+=n}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>(t),</span>{vBoxMaxWidth:s,hBoxMaxHeight:n}=<span class="cstat-no" title="statement not covered" >e;</span>let o,r,a;<span class="cstat-no" title="statement not covered" >for(o=0,r=t.length;o&lt;r;++o){<span class="cstat-no" title="statement not covered" >a=t[o];c</span>onst{fullSize:r}=<span class="cstat-no" title="statement not covered" >a.box,</span>h=<span class="cstat-no" title="statement not covered" >i[a.stack],</span>l=<span class="cstat-no" title="statement not covered" >h&amp;&amp;a.stackWeight/h.weight;<span class="cstat-no" title="statement not covered" ></span>a.horizontal?(a.width=l?l*s:r&amp;&amp;e.availableWidth,a.height=n):(a.width=s,a.height=l?l*n:r&amp;&amp;e.availableHeight)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>function <span class="fstat-no" title="function not covered" >us(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return Math.max(t[i],e[i])+Math.max(t[s],e[s])}</span>function <span class="fstat-no" title="function not covered" >fs(</span>t,e){<span class="cstat-no" title="statement not covered" >t.top=Math.max(t.top,e.top),t.left=Math.max(t.left,e.left),t.bottom=Math.max(t.bottom,e.bottom),t.right=Math.max(t.right,e.right)}</span>function <span class="fstat-no" title="function not covered" >gs(</span>t,e,i,s){const{pos:n,box:o}=<span class="cstat-no" title="statement not covered" >i,</span>r=<span class="cstat-no" title="statement not covered" >t.maxPadding;<span class="cstat-no" title="statement not covered" ></span>if(!H(n)){<span class="cstat-no" title="statement not covered" >i.size&amp;&amp;(t[n]-=i.size);c</span>onst e=<span class="cstat-no" title="statement not covered" >s[i.stack]||{size:0,count:1};<span class="cstat-no" title="statement not covered" ></span>e.size=Math.max(e.size,i.horizontal?o.height:o.width),i.size=e.size/e.count,t[n]+=i.size}<span class="cstat-no" title="statement not covered" ></span>o</span>.getPadding&amp;&amp;fs(r,o.getPadding());c</span>onst a=<span class="cstat-no" title="statement not covered" >Math.max(0,e.outerWidth-us(r,t,"left","right")),</span>h=<span class="cstat-no" title="statement not covered" >Math.max(0,e.outerHeight-us(r,t,"top","bottom")),</span>l=<span class="cstat-no" title="statement not covered" >a!==t.w,</span>c=<span class="cstat-no" title="statement not covered" >h!==t.h;<span class="cstat-no" title="statement not covered" ></span>return t.w=a,t.h=h,i.horizontal?{same:l,other:c}:{same:c,other:l}}</span>function <span class="fstat-no" title="function not covered" >ps(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >e.maxPadding;</span>function <span class="fstat-no" title="function not covered" >s(</span>t){const s=<span class="cstat-no" title="statement not covered" >{left:0,top:0,right:0,bottom:0};<span class="cstat-no" title="statement not covered" ></span>return t.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >s[t]=Math.max(e[t],i[t])}</span>)),s}<span class="cstat-no" title="statement not covered" ></span>return s(t?["left","right"]:["top","bottom"])}</span>function <span class="fstat-no" title="function not covered" >xs(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >[];</span>let o,r,a,h,l,c;<span class="cstat-no" title="statement not covered" >for(o=0,r=t.length,l=0;o&lt;r;++o){<span class="cstat-no" title="statement not covered" >a=t[o],h=a.box,h.update(a.width||e.w,a.height||e.h,ps(a.horizontal,e));c</span>onst{same:r,other:d}=<span class="cstat-no" title="statement not covered" >gs(e,i,a,s);<span class="cstat-no" title="statement not covered" ></span>l|=r&amp;&amp;n.length,c=c||d,h.fullSize||n.push(a)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn l&amp;&amp;xs(n,e,i,s)||c}</span>function <span class="fstat-no" title="function not covered" >ms(</span>t,e,i,s,n){<span class="cstat-no" title="statement not covered" >t.top=i,t.left=e,t.right=e+s,t.bottom=i+n,t.width=s,t.height=n}</span>function <span class="fstat-no" title="function not covered" >bs(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >i.padding;</span>let{x:o,y:r}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>for(const a of t){const t=<span class="cstat-no" title="statement not covered" >a.box,</span>h=<span class="cstat-no" title="statement not covered" >s[a.stack]||{count:1,placed:0,weight:1},</span>l=<span class="cstat-no" title="statement not covered" >a.stackWeight/h.weight||1;<span class="cstat-no" title="statement not covered" ></span>if(a.horizontal){const s=<span class="cstat-no" title="statement not covered" >e.w*l,</span>o=<span class="cstat-no" title="statement not covered" >h.size||t.height;<span class="cstat-no" title="statement not covered" ></span>st(h.start)&amp;&amp;(r=h.start),t.fullSize?ms(t,n.left,r,i.outerWidth-n.right-n.left,o):ms(t,e.left+h.placed,r,s,o),h.start=r,h.placed+=s,r=t.bottom}</span>else{const s=<span class="cstat-no" title="statement not covered" >e.h*l,</span>r=<span class="cstat-no" title="statement not covered" >h.size||t.width;<span class="cstat-no" title="statement not covered" ></span>st(h.start)&amp;&amp;(o=h.start),t.fullSize?ms(t,o,n.top,r,i.outerHeight-n.bottom-n.top):ms(t,o,e.top+h.placed,r,s),h.start=o,h.placed+=s,o=t.right}</span>}<span class="cstat-no" title="statement not covered" ></span>e</span>.x=o,e.y=r}</span>var _s=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >ad</span>dBox(t,e){<span class="cstat-no" title="statement not covered" >t.boxes||(t.boxes=[]),e.fullSize=e.fullSize||!1,e.position=e.position||"top",e.weight=e.weight||0,e._layers=e._layers||<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return[{z:0,<span class="fstat-no" title="function not covered" >dr</span>aw(t){<span class="cstat-no" title="statement not covered" >e.draw(t)}</span>}]}</span>,t.boxes.push(e)}</span>,<span class="fstat-no" title="function not covered" >re</span>moveBox(t,e){const i=<span class="cstat-no" title="statement not covered" >t.boxes?t.boxes.indexOf(e):-1;<span class="cstat-no" title="statement not covered" ></span>-1!==i&amp;&amp;t.boxes.splice(i,1)}</span>,<span class="fstat-no" title="function not covered" >co</span>nfigure(t,e,i){<span class="cstat-no" title="statement not covered" >e.fullSize=i.fullSize,e.position=i.position,e.weight=i.weight}</span>,<span class="fstat-no" title="function not covered" >up</span>date(t,e,i,s){<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >De(t.options.layout.padding),</span>o=<span class="cstat-no" title="statement not covered" >Math.max(e-n.width,0),</span>r=<span class="cstat-no" title="statement not covered" >Math.max(i-n.height,0),</span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >[];</span>let i,s,n,o,r,a;<span class="cstat-no" title="statement not covered" >for(i=0,s=(t||[]).length;i&lt;s;++i)<span class="cstat-no" title="statement not covered" >n=t[i],({position:o,options:{stack:r,stackWeight:a=<span class="branch-0 cbranch-no" title="branch not covered" >1}</span>}=n),e.push({index:i,box:n,pos:o,horizontal:n.isHorizontal(),weight:n.weight,stack:r&amp;&amp;o+r,stackWeight:a});<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>(t),</span>i=<span class="cstat-no" title="statement not covered" >cs(e.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.box.fullSize)</span>),!0),</span>s=<span class="cstat-no" title="statement not covered" >cs(hs(e,"left"),!0),</span>n=<span class="cstat-no" title="statement not covered" >cs(hs(e,"right")),</span>o=<span class="cstat-no" title="statement not covered" >cs(hs(e,"top"),!0),</span>r=<span class="cstat-no" title="statement not covered" >cs(hs(e,"bottom")),</span>a=<span class="cstat-no" title="statement not covered" >ls(e,"x"),</span>h=<span class="cstat-no" title="statement not covered" >ls(e,"y");<span class="cstat-no" title="statement not covered" ></span>return{fullSize:i,leftAndTop:s.concat(o),rightAndBottom:n.concat(h).concat(r).concat(a),chartArea:hs(e,"chartArea"),vertical:s.concat(n).concat(h),horizontal:o.concat(r).concat(a)}}</span>(t.boxes),</span>h=<span class="cstat-no" title="statement not covered" >a.vertical,</span>l=<span class="cstat-no" title="statement not covered" >a.horizontal;<span class="cstat-no" title="statement not covered" ></span>U(t.boxes,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >"function"===typeof t.beforeLayout&amp;&amp;t.beforeLayout()}</span>));c</span>onst c=<span class="cstat-no" title="statement not covered" >h.reduce((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e.box.options&amp;&amp;!1===e.box.options.display?t:t+1)</span>,0)||1,</span>d=<span class="cstat-no" title="statement not covered" >Object.freeze({outerWidth:e,outerHeight:i,padding:n,availableWidth:o,availableHeight:r,vBoxMaxWidth:o/2/c,hBoxMaxHeight:r/2}),</span>u=<span class="cstat-no" title="statement not covered" >Object.assign({},n);<span class="cstat-no" title="statement not covered" ></span>fs(u,De(s));c</span>onst f=<span class="cstat-no" title="statement not covered" >Object.assign({maxPadding:u,w:o,h:r,x:n.left,y:n.top},n),</span>g=<span class="cstat-no" title="statement not covered" >ds(h.concat(l),d);<span class="cstat-no" title="statement not covered" ></span>xs(a.fullSize,f,d,g),xs(h,f,d,g),xs(l,f,d,g)&amp;&amp;xs(h,f,d,g),<span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >t.maxPadding;</span>function <span class="fstat-no" title="function not covered" >i(</span>i){const s=<span class="cstat-no" title="statement not covered" >Math.max(e[i]-t[i],0);<span class="cstat-no" title="statement not covered" ></span>return t[i]+=s,s}<span class="cstat-no" title="statement not covered" ></span>t.y+=i("top"),t.x+=i("left"),i("right"),i("bottom")}</span>(f),bs(a.leftAndTop,f,d,g),f.x+=f.w,f.y+=f.h,bs(a.rightAndBottom,f,d,g),t.chartArea={left:f.left,top:f.top,right:f.left+f.w,bottom:f.top+f.h,height:f.h,width:f.w},U(a.chartArea,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >e.box;<span class="cstat-no" title="statement not covered" ></span>Object.assign(i,t.chartArea),i.update(f.w,f.h,{left:0,top:0,right:0,bottom:0})}</span>))}</span>};</span>class ys{<span class="fstat-no" title="function not covered" >ac</span>quireContext(t,e){}<span class="fstat-no" title="function not covered" >re</span>leaseContext(t){<span class="cstat-no" title="statement not covered" >return!1}<span class="fstat-no" title="function not covered" ></span>ad</span>dEventListener(t,e,i){}<span class="fstat-no" title="function not covered" >re</span>moveEventListener(t,e,i){}<span class="fstat-no" title="function not covered" >ge</span>tDevicePixelRatio(){<span class="cstat-no" title="statement not covered" >return 1}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaximumSize(t,e,i,s){<span class="cstat-no" title="statement not covered" >return e=Math.max(0,e||t.width),i=i||t.height,{width:e,height:Math.max(0,s?Math.floor(e/s):i)}}<span class="fstat-no" title="function not covered" ></span>is</span>Attached(t){<span class="cstat-no" title="statement not covered" >return!0}<span class="fstat-no" title="function not covered" ></span>up</span>dateConfig(t){}}class vs extends ys{<span class="fstat-no" title="function not covered" >ac</span>quireContext(t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;t.getContext&amp;&amp;t.getContext("2d")||null}<span class="fstat-no" title="function not covered" ></span>up</span>dateConfig(t){<span class="cstat-no" title="statement not covered" >t.options.animation=!1}</span>}const ws=<span class="cstat-no" title="statement not covered" >{touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup",pointerenter:"mouseenter",pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointerleave:"mouseout",pointerout:"mouseout"},</span>Ms=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >null===t||""===t;</span></span>const ks=<span class="cstat-no" title="statement not covered" >!!ai&amp;&amp;{passive:!0};</span>function <span class="fstat-no" title="function not covered" >Ss(</span>t,e,i){<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.canvas&amp;&amp;t.canvas.removeEventListener(e,i,ks)}</span>function <span class="fstat-no" title="function not covered" >Ps(</span>t,e){<span class="cstat-no" title="statement not covered" >for(const i of t)<span class="cstat-no" title="statement not covered" >if(i===e||i.contains(e))<span class="cstat-no" title="statement not covered" >return!0}</span></span></span>function <span class="fstat-no" title="function not covered" >Ds(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.canvas,</span>n=<span class="cstat-no" title="statement not covered" >new MutationObserver((<span class="fstat-no" title="function not covered" >t=</span>&gt;{let e=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>for(const i of t)<span class="cstat-no" title="statement not covered" >e=e||Ps(i.addedNodes,s),e=e&amp;&amp;!Ps(i.removedNodes,s);<span class="cstat-no" title="statement not covered" >e</span></span>&amp;&amp;i()}</span>));<span class="cstat-no" title="statement not covered" ></span>return n.observe(document,{childList:!0,subtree:!0}),n}</span>function <span class="fstat-no" title="function not covered" >As(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.canvas,</span>n=<span class="cstat-no" title="statement not covered" >new MutationObserver((<span class="fstat-no" title="function not covered" >t=</span>&gt;{let e=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>for(const i of t)<span class="cstat-no" title="statement not covered" >e=e||Ps(i.removedNodes,s),e=e&amp;&amp;!Ps(i.addedNodes,s);<span class="cstat-no" title="statement not covered" >e</span></span>&amp;&amp;i()}</span>));<span class="cstat-no" title="statement not covered" ></span>return n.observe(document,{childList:!0,subtree:!0}),n}</span>const Os=<span class="cstat-no" title="statement not covered" >new Map;</span>let Cs=<span class="cstat-no" title="statement not covered" >0;</span>function <span class="fstat-no" title="function not covered" >Ts(</span>){const t=<span class="cstat-no" title="statement not covered" >window.devicePixelRatio;<span class="cstat-no" title="statement not covered" ></span>t!==Cs&amp;&amp;(Cs=t,Os.forEach((<span class="fstat-no" title="function not covered" >(e</span>,i)=&gt;{<span class="cstat-no" title="statement not covered" >i.currentDevicePixelRatio!==t&amp;&amp;e()}</span>)))}</span>function <span class="fstat-no" title="function not covered" >Rs(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.canvas,</span>n=<span class="cstat-no" title="statement not covered" >s&amp;&amp;Ze(s);<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >Ft((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{const s=<span class="cstat-no" title="statement not covered" >n.clientWidth;<span class="cstat-no" title="statement not covered" ></span>i(t,e),s&lt;n.clientWidth&amp;&amp;i()}</span>),window),</span>r=<span class="cstat-no" title="statement not covered" >new ResizeObserver((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >t[0],</span>i=<span class="cstat-no" title="statement not covered" >e.contentRect.width,</span>s=<span class="cstat-no" title="statement not covered" >e.contentRect.height;<span class="cstat-no" title="statement not covered" ></span>0===i&amp;&amp;0===s||o(i,s)}</span>));<span class="cstat-no" title="statement not covered" ></span>return r.observe(n),<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >Os.size||window.addEventListener("resize",Ts),Os.set(t,e)}</span>(t,o),r}</span>function <span class="fstat-no" title="function not covered" >Is(</span>t,e,i){<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.disconnect(),"resize"===e&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >Os.delete(t),Os.size||window.removeEventListener("resize",Ts)}</span>(t)}</span>function <span class="fstat-no" title="function not covered" >Es(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.canvas,</span>n=<span class="cstat-no" title="statement not covered" >Ft((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >null!==t.ctx&amp;&amp;i(<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >ws[t.type]||t.type,</span>{x:s,y:n}=<span class="cstat-no" title="statement not covered" >si(t,e);<span class="cstat-no" title="statement not covered" ></span>return{type:i,chart:e,native:t,x:void 0!==s?s:null,y:void 0!==n?n:null}}</span>(e,t))}</span>),t);<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.addEventListener(e,i,ks)}</span>(s,e,n),n}</span>class Ls extends ys{<span class="fstat-no" title="function not covered" >ac</span>quireContext(t,e){const i=<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.getContext&amp;&amp;t.getContext("2d");<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;i.canvas===t?(<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >t.style,</span>s=<span class="cstat-no" title="statement not covered" >t.getAttribute("height"),</span>n=<span class="cstat-no" title="statement not covered" >t.getAttribute("width");<span class="cstat-no" title="statement not covered" ></span>if(t.$chartjs={initial:{height:s,width:n,style:{display:i.display,height:i.height,width:i.width}}},i.display=i.display||"block",i.boxSizing=i.boxSizing||"border-box",Ms(n)){const e=<span class="cstat-no" title="statement not covered" >hi(t,"width");<span class="cstat-no" title="statement not covered" ></span>void 0!==e&amp;&amp;(t.width=e)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(Ms(s))<span class="cstat-no" title="statement not covered" >if(""===t.style.height)<span class="cstat-no" title="statement not covered" >t.height=t.width/(e||2);e</span>lse{const e=<span class="cstat-no" title="statement not covered" >hi(t,"height");<span class="cstat-no" title="statement not covered" ></span>void 0!==e&amp;&amp;(t.height=e)}</span>}</span></span>(t,e),i):null}<span class="fstat-no" title="function not covered" ></span>re</span>leaseContext(t){const e=<span class="cstat-no" title="statement not covered" >t.canvas;<span class="cstat-no" title="statement not covered" ></span>if(!e.$chartjs)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >e.$chartjs.initial;<span class="cstat-no" title="statement not covered" ></span>["height","width"].forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >i[t];<span class="cstat-no" title="statement not covered" ></span>B(s)?e.removeAttribute(t):e.setAttribute(t,s)}</span>));c</span>onst s=<span class="cstat-no" title="statement not covered" >i.style||{};<span class="cstat-no" title="statement not covered" ></span>return Object.keys(s).forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.style[t]=s[t]}</span>)),e.width=e.width,delete e.$chartjs,!0}<span class="fstat-no" title="function not covered" ></span>ad</span>dEventListener(t,e,i){<span class="cstat-no" title="statement not covered" >this.removeEventListener(t,e);c</span>onst s=<span class="cstat-no" title="statement not covered" >t.$proxies||(t.$proxies={}),</span>n=<span class="cstat-no" title="statement not covered" >{attach:Ds,detach:As,resize:Rs}[e]||Es;<span class="cstat-no" title="statement not covered" ></span>s[e]=n(t,e,i)}<span class="fstat-no" title="function not covered" ></span>re</span>moveEventListener(t,e){const i=<span class="cstat-no" title="statement not covered" >t.$proxies||(t.$proxies={}),</span>s=<span class="cstat-no" title="statement not covered" >i[e];<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >(</span></span>{attach:Is,detach:Is,resize:Is}[e]||Ss)(t,e,s),i[e]=void 0}<span class="fstat-no" title="function not covered" ></span>ge</span>tDevicePixelRatio(){<span class="cstat-no" title="statement not covered" >return window.devicePixelRatio}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaximumSize(t,e,i,s){<span class="cstat-no" title="statement not covered" >return oi(t,e,i,s)}<span class="fstat-no" title="function not covered" ></span>is</span>Attached(t){const e=<span class="cstat-no" title="statement not covered" >t&amp;&amp;Ze(t);<span class="cstat-no" title="statement not covered" ></span>return!(!e||!e.isConnected)}</span>}class zs{static defaults=<span class="cstat-no" title="statement not covered" >{};</span>static defaultRoutes=<span class="cstat-no" title="statement not covered" >void 0;</span>x;y;active=<span class="cstat-no" title="statement not covered" >!1;</span>options;$animations;<span class="fstat-no" title="function not covered" >to</span>oltipPosition(t){const{x:e,y:i}=<span class="cstat-no" title="statement not covered" >this.getProps(["x","y"],t);<span class="cstat-no" title="statement not covered" ></span>return{x:e,y:i}}<span class="fstat-no" title="function not covered" ></span>ha</span>sValue(){<span class="cstat-no" title="statement not covered" >return bt(this.x)&amp;&amp;bt(this.y)}<span class="fstat-no" title="function not covered" ></span>ge</span>tProps(t,e){const i=<span class="cstat-no" title="statement not covered" >this.$animations;<span class="cstat-no" title="statement not covered" ></span>if(!e||!i)<span class="cstat-no" title="statement not covered" >return this;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>return t.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >s[t]=i[t]&amp;&amp;i[t].active()?i[t]._to:this[t]}</span>)),s}</span>}function <span class="fstat-no" title="function not covered" >Fs(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t.options.ticks,</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >t.options.offset,</span>i=<span class="cstat-no" title="statement not covered" >t._tickSize(),</span>s=<span class="cstat-no" title="statement not covered" >t._length/i+(e?0:1),</span>n=<span class="cstat-no" title="statement not covered" >t._maxLength/i;<span class="cstat-no" title="statement not covered" ></span>return Math.floor(Math.min(s,n))}</span>(t),</span>n=<span class="cstat-no" title="statement not covered" >Math.min(i.maxTicksLimit||s,s),</span>o=<span class="cstat-no" title="statement not covered" >i.major.enabled?<span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >[];</span>let i,s;<span class="cstat-no" title="statement not covered" >for(i=0,s=t.length;i&lt;s;i++)<span class="cstat-no" title="statement not covered" >t[i].major&amp;&amp;e.push(i);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>(e):[],</span>r=<span class="cstat-no" title="statement not covered" >o.length,</span>a=<span class="cstat-no" title="statement not covered" >o[0],</span>h=<span class="cstat-no" title="statement not covered" >o[r-1],</span>l=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(r&gt;n)<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){let n,o=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >i[0];<span class="cstat-no" title="statement not covered" ></span>for(s=Math.ceil(s),n=0;n&lt;t.length;n++)<span class="cstat-no" title="statement not covered" >n===r&amp;&amp;(e.push(t[n]),o++,r=i[o*s])}</span></span>(e,l,o,r/n),l;c</span></span>onst c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >t.length;</span>let i,s;<span class="cstat-no" title="statement not covered" >if(e&lt;2)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(s=t[0],i=1;i&lt;e;++i)<span class="cstat-no" title="statement not covered" >if(t[i]-t[i-1]!==s)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn s}</span>(t),</span>n=<span class="cstat-no" title="statement not covered" >e.length/i;<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return Math.max(n,1);c</span></span>onst o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >[],</span>i=<span class="cstat-no" title="statement not covered" >Math.sqrt(t);</span>let s;<span class="cstat-no" title="statement not covered" >for(s=1;s&lt;i;s++)<span class="cstat-no" title="statement not covered" >t%s===0&amp;&amp;(e.push(s),e.push(t/s));<span class="cstat-no" title="statement not covered" >r</span></span>eturn i===(0|i)&amp;&amp;e.push(i),e.sort((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t-e)</span>).pop(),e}</span>(s);<span class="cstat-no" title="statement not covered" ></span>for(let r=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >o.length-1;</span>r&lt;a;r++){const t=<span class="cstat-no" title="statement not covered" >o[r];<span class="cstat-no" title="statement not covered" ></span>if(t&gt;n)<span class="cstat-no" title="statement not covered" >return t}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn Math.max(n,1)}</span>(o,e,n);<span class="cstat-no" title="statement not covered" ></span>if(r&gt;0){let t,i;const s=<span class="cstat-no" title="statement not covered" >r&gt;1?Math.round((h-a)/(r-1)):null;<span class="cstat-no" title="statement not covered" ></span>for(Bs(e,l,c,B(s)?0:a-s,a),t=0,i=r-1;t&lt;i;t++)<span class="cstat-no" title="statement not covered" >Bs(e,l,c,o[t],o[t+1]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn Bs(e,l,c,h,B(s)?e.length:h+s),l}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Bs(e,l,c),l}</span>function <span class="fstat-no" title="function not covered" >Bs(</span>t,e,i,s,n){const o=<span class="cstat-no" title="statement not covered" >N(s,0),</span>r=<span class="cstat-no" title="statement not covered" >Math.min(N(n,t.length),t.length);</span>let a,h,l,c=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(i=Math.ceil(i),n&amp;&amp;(a=n-s,i=a/Math.floor(a/i)),l=o;l&lt;0;)<span class="cstat-no" title="statement not covered" >c++,l=Math.round(o+c*i);<span class="cstat-no" title="statement not covered" >f</span></span>or(h=Math.max(o,0);h&lt;r;h++)<span class="cstat-no" title="statement not covered" >h===l&amp;&amp;(e.push(t[h]),c++,l=Math.round(o+c*i))}</span></span>const Ws=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >"top"===e||"left"===e?t[e]+i:t[e]-i,</span></span>Hs=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >Math.min(e||t,t);</span></span>function <span class="fstat-no" title="function not covered" >Vs(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >t.length/e,</span>n=<span class="cstat-no" title="statement not covered" >t.length;</span>let o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;o&lt;n;o+=s)<span class="cstat-no" title="statement not covered" >i.push(t[Math.floor(o)]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>function <span class="fstat-no" title="function not covered" >js(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.ticks.length,</span>n=<span class="cstat-no" title="statement not covered" >Math.min(e,s-1),</span>o=<span class="cstat-no" title="statement not covered" >t._startPixel,</span>r=<span class="cstat-no" title="statement not covered" >t._endPixel,</span>a=<span class="cstat-no" title="statement not covered" >1e-6;</span>let h,l=<span class="cstat-no" title="statement not covered" >t.getPixelForTick(n);<span class="cstat-no" title="statement not covered" ></span>if(!(i&amp;&amp;(h=1===s?Math.max(l-o,r-l):0===e?(t.getPixelForTick(1)-l)/2:(l-t.getPixelForTick(n-1))/2,l+=n&lt;e?h:-h,l&lt;o-a||l&gt;r+a)))<span class="cstat-no" title="statement not covered" >return l}</span></span>function <span class="fstat-no" title="function not covered" >Ns(</span>t){<span class="cstat-no" title="statement not covered" >return t.drawTicks?t.tickLength:0}</span>function <span class="fstat-no" title="function not covered" >$s(</span>t,e){<span class="cstat-no" title="statement not covered" >if(!t.display)<span class="cstat-no" title="statement not covered" >return 0;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >Ae(t.font,e),</span>s=<span class="cstat-no" title="statement not covered" >De(t.padding);<span class="cstat-no" title="statement not covered" ></span>return(W(t.text)?t.text.length:1)*i.lineHeight+s.height}</span>function <span class="fstat-no" title="function not covered" >Ys(</span>t,e,i){let s=<span class="cstat-no" title="statement not covered" >Bt(t);<span class="cstat-no" title="statement not covered" ></span>return(i&amp;&amp;"right"!==e||!i&amp;&amp;"right"===e)&amp;&amp;(s=(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"left"===t?"right":"right"===t?"left":t)</span>(s)),s}</span>class Us extends zs{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.id=t.id,this.type=t.type,this.options=void 0,this.ctx=t.ctx,this.chart=t.chart,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this._margins={left:0,right:0,top:0,bottom:0},this.maxWidth=void 0,this.maxHeight=void 0,this.paddingTop=void 0,this.paddingBottom=void 0,this.paddingLeft=void 0,this.paddingRight=void 0,this.axis=void 0,this.labelRotation=void 0,this.min=void 0,this.max=void 0,this._range=void 0,this.ticks=[],this._gridLineItems=null,this._labelItems=null,this._labelSizes=null,this._length=0,this._maxLength=0,this._longestTextCache={},this._startPixel=void 0,this._endPixel=void 0,this._reversePixels=!1,this._userMax=void 0,this._userMin=void 0,this._suggestedMax=void 0,this._suggestedMin=void 0,this._ticksLength=0,this._borderValue=0,this._cache={},this._dataLimitsCached=!1,this.$context=void 0}<span class="fstat-no" title="function not covered" ></span>in</span>it(t){<span class="cstat-no" title="statement not covered" >this.options=t.setContext(this.getContext()),this.axis=t.axis,this._userMin=this.parse(t.min),this._userMax=this.parse(t.max),this._suggestedMin=this.parse(t.suggestedMin),this._suggestedMax=this.parse(t.suggestedMax)}<span class="fstat-no" title="function not covered" ></span>pa</span>rse(t,e){<span class="cstat-no" title="statement not covered" >return t}<span class="fstat-no" title="function not covered" ></span>ge</span>tUserBounds(){let{_userMin:t,_userMax:e,_suggestedMin:i,_suggestedMax:s}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return t=j(t,Number.POSITIVE_INFINITY),e=j(e,Number.NEGATIVE_INFINITY),i=j(i,Number.POSITIVE_INFINITY),s=j(s,Number.NEGATIVE_INFINITY),{min:j(t,i),max:j(e,s),minDefined:V(t),maxDefined:V(e)}}<span class="fstat-no" title="function not covered" ></span>ge</span>tMinMax(t){let e,{min:i,max:s,minDefined:n,maxDefined:o}=<span class="cstat-no" title="statement not covered" >this.getUserBounds();<span class="cstat-no" title="statement not covered" ></span>if(n&amp;&amp;o)<span class="cstat-no" title="statement not covered" >return{min:i,max:s};c</span></span>onst r=<span class="cstat-no" title="statement not covered" >this.getMatchingVisibleMetas();<span class="cstat-no" title="statement not covered" ></span>for(let a=<span class="cstat-no" title="statement not covered" >0,</span>h=<span class="cstat-no" title="statement not covered" >r.length;</span>a&lt;h;++a)<span class="cstat-no" title="statement not covered" >e=r[a].controller.getMinMax(this,t),n||(i=Math.min(i,e.min)),o||(s=Math.max(s,e.max));<span class="cstat-no" title="statement not covered" >r</span></span>eturn i=o&amp;&amp;i&gt;s?s:i,s=n&amp;&amp;i&gt;s?i:s,{min:j(i,j(s,i)),max:j(s,j(i,s))}}<span class="fstat-no" title="function not covered" ></span>ge</span>tPadding(){<span class="cstat-no" title="statement not covered" >return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}}<span class="fstat-no" title="function not covered" ></span>ge</span>tTicks(){<span class="cstat-no" title="statement not covered" >return this.ticks}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabels(){const t=<span class="cstat-no" title="statement not covered" >this.chart.data;<span class="cstat-no" title="statement not covered" ></span>return this.options.labels||(this.isHorizontal()?t.xLabels:t.yLabels)||t.labels||[]}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelItems(t=<span class="branch-0 cbranch-no" title="branch not covered" >this.chart.chartArea)</span>{<span class="cstat-no" title="statement not covered" >return this._labelItems||(this._labelItems=this._computeLabelItems(t))}<span class="fstat-no" title="function not covered" ></span>be</span>foreLayout(){<span class="cstat-no" title="statement not covered" >this._cache={},this._dataLimitsCached=!1}<span class="fstat-no" title="function not covered" ></span>be</span>foreUpdate(){<span class="cstat-no" title="statement not covered" >Y(this.options.beforeUpdate,[this])}<span class="fstat-no" title="function not covered" ></span>up</span>date(t,e,i){const{beginAtZero:s,grace:n,ticks:o}=<span class="cstat-no" title="statement not covered" >this.options,</span>r=<span class="cstat-no" title="statement not covered" >o.sampleSize;<span class="cstat-no" title="statement not covered" ></span>this.beforeUpdate(),this.maxWidth=t,this.maxHeight=e,this._margins=i=Object.assign({left:0,right:0,top:0,bottom:0},i),this.ticks=null,this._labelSizes=null,this._gridLineItems=null,this._labelItems=null,this.beforeSetDimensions(),this.setDimensions(),this.afterSetDimensions(),this._maxLength=this.isHorizontal()?this.width+i.left+i.right:this.height+i.top+i.bottom,this._dataLimitsCached||(this.beforeDataLimits(),this.determineDataLimits(),this.afterDataLimits(),this._range=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const{min:s,max:n}=<span class="cstat-no" title="statement not covered" >t,</span>o=<span class="cstat-no" title="statement not covered" >$(e,(n-s)/2),</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >i&amp;&amp;0===t?0:t+e;<span class="cstat-no" title="statement not covered" ></span></span>return{min:r(s,-Math.abs(o)),max:r(n,o)}}</span>(this,n,s),this._dataLimitsCached=!0),this.beforeBuildTicks(),this.ticks=this.buildTicks()||[],this.afterBuildTicks();c</span>onst a=<span class="cstat-no" title="statement not covered" >r&lt;this.ticks.length;<span class="cstat-no" title="statement not covered" ></span>this._convertTicksToLabels(a?Vs(this.ticks,r):this.ticks),this.configure(),this.beforeCalculateLabelRotation(),this.calculateLabelRotation(),this.afterCalculateLabelRotation(),o.display&amp;&amp;(o.autoSkip||"auto"===o.source)&amp;&amp;(this.ticks=Fs(this,this.ticks),this._labelSizes=null,this.afterAutoSkip()),a&amp;&amp;this._convertTicksToLabels(this.ticks),this.beforeFit(),this.fit(),this.afterFit(),this.afterUpdate()}<span class="fstat-no" title="function not covered" ></span>co</span>nfigure(){let t,e,i=<span class="cstat-no" title="statement not covered" >this.options.reverse;<span class="cstat-no" title="statement not covered" ></span>this.isHorizontal()?(t=this.left,e=this.right):(t=this.top,e=this.bottom,i=!i),this._startPixel=t,this._endPixel=e,this._reversePixels=i,this._length=e-t,this._alignToPixels=this.options.alignToPixels}<span class="fstat-no" title="function not covered" ></span>af</span>terUpdate(){<span class="cstat-no" title="statement not covered" >Y(this.options.afterUpdate,[this])}<span class="fstat-no" title="function not covered" ></span>be</span>foreSetDimensions(){<span class="cstat-no" title="statement not covered" >Y(this.options.beforeSetDimensions,[this])}<span class="fstat-no" title="function not covered" ></span>se</span>tDimensions(){<span class="cstat-no" title="statement not covered" >this.isHorizontal()?(this.width=this.maxWidth,this.left=0,this.right=this.width):(this.height=this.maxHeight,this.top=0,this.bottom=this.height),this.paddingLeft=0,this.paddingTop=0,this.paddingRight=0,this.paddingBottom=0}<span class="fstat-no" title="function not covered" ></span>af</span>terSetDimensions(){<span class="cstat-no" title="statement not covered" >Y(this.options.afterSetDimensions,[this])}<span class="fstat-no" title="function not covered" ></span>_c</span>allHooks(t){<span class="cstat-no" title="statement not covered" >this.chart.notifyPlugins(t,this.getContext()),Y(this.options[t],[this])}<span class="fstat-no" title="function not covered" ></span>be</span>foreDataLimits(){<span class="cstat-no" title="statement not covered" >this._callHooks("beforeDataLimits")}<span class="fstat-no" title="function not covered" ></span>de</span>termineDataLimits(){}<span class="fstat-no" title="function not covered" >af</span>terDataLimits(){<span class="cstat-no" title="statement not covered" >this._callHooks("afterDataLimits")}<span class="fstat-no" title="function not covered" ></span>be</span>foreBuildTicks(){<span class="cstat-no" title="statement not covered" >this._callHooks("beforeBuildTicks")}<span class="fstat-no" title="function not covered" ></span>bu</span>ildTicks(){<span class="cstat-no" title="statement not covered" >return[]}<span class="fstat-no" title="function not covered" ></span>af</span>terBuildTicks(){<span class="cstat-no" title="statement not covered" >this._callHooks("afterBuildTicks")}<span class="fstat-no" title="function not covered" ></span>be</span>foreTickToLabelConversion(){<span class="cstat-no" title="statement not covered" >Y(this.options.beforeTickToLabelConversion,[this])}<span class="fstat-no" title="function not covered" ></span>ge</span>nerateTickLabels(t){const e=<span class="cstat-no" title="statement not covered" >this.options.ticks;</span>let i,s,n;<span class="cstat-no" title="statement not covered" >for(i=0,s=t.length;i&lt;s;i++)<span class="cstat-no" title="statement not covered" >n=t[i],n.label=Y(e.callback,[n.value,i,t],this)}<span class="fstat-no" title="function not covered" ></span></span>af</span>terTickToLabelConversion(){<span class="cstat-no" title="statement not covered" >Y(this.options.afterTickToLabelConversion,[this])}<span class="fstat-no" title="function not covered" ></span>be</span>foreCalculateLabelRotation(){<span class="cstat-no" title="statement not covered" >Y(this.options.beforeCalculateLabelRotation,[this])}<span class="fstat-no" title="function not covered" ></span>ca</span>lculateLabelRotation(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >t.ticks,</span>i=<span class="cstat-no" title="statement not covered" >Hs(this.ticks.length,t.ticks.maxTicksLimit),</span>s=<span class="cstat-no" title="statement not covered" >e.minRotation||0,</span>n=<span class="cstat-no" title="statement not covered" >e.maxRotation;</span>let o,r,a,h=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>if(!this._isVisible()||!e.display||s&gt;=n||i&lt;=1||!this.isHorizontal())<span class="cstat-no" title="statement not covered" >return void(this.labelRotation=s);c</span></span>onst l=<span class="cstat-no" title="statement not covered" >this._getLabelSizes(),</span>c=<span class="cstat-no" title="statement not covered" >l.widest.width,</span>d=<span class="cstat-no" title="statement not covered" >l.highest.height,</span>u=<span class="cstat-no" title="statement not covered" >At(this.chart.width-c,0,this.maxWidth);<span class="cstat-no" title="statement not covered" ></span>o=t.offset?this.maxWidth/i:u/(i-1),c+6&gt;o&amp;&amp;(o=u/(i-(t.offset?.5:1)),r=this.maxHeight-Ns(t.grid)-e.padding-$s(t.title,this.chart.options.font),a=Math.sqrt(c*c+d*d),h=vt(Math.min(Math.asin(At((l.highest.height+6)/o,-1,1)),Math.asin(At(r/a,-1,1))-Math.asin(At(d/a,-1,1)))),h=Math.max(s,Math.min(n,h))),this.labelRotation=h}<span class="fstat-no" title="function not covered" ></span>af</span>terCalculateLabelRotation(){<span class="cstat-no" title="statement not covered" >Y(this.options.afterCalculateLabelRotation,[this])}<span class="fstat-no" title="function not covered" ></span>af</span>terAutoSkip(){}<span class="fstat-no" title="function not covered" >be</span>foreFit(){<span class="cstat-no" title="statement not covered" >Y(this.options.beforeFit,[this])}<span class="fstat-no" title="function not covered" ></span>fi</span>t(){const t=<span class="cstat-no" title="statement not covered" >{width:0,height:0},</span>{chart:e,options:{ticks:i,title:s,grid:n}}=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >this._isVisible(),</span>r=<span class="cstat-no" title="statement not covered" >this.isHorizontal();<span class="cstat-no" title="statement not covered" ></span>if(o){const o=<span class="cstat-no" title="statement not covered" >$s(s,e.options.font);<span class="cstat-no" title="statement not covered" ></span>if(r?(t.width=this.maxWidth,t.height=Ns(n)+o):(t.height=this.maxHeight,t.width=Ns(n)+o),i.display&amp;&amp;this.ticks.length){const{first:e,last:s,widest:n,highest:o}=<span class="cstat-no" title="statement not covered" >this._getLabelSizes(),</span>a=<span class="cstat-no" title="statement not covered" >2*i.padding,</span>h=<span class="cstat-no" title="statement not covered" >yt(this.labelRotation),</span>l=<span class="cstat-no" title="statement not covered" >Math.cos(h),</span>c=<span class="cstat-no" title="statement not covered" >Math.sin(h);<span class="cstat-no" title="statement not covered" ></span>if(r){const e=<span class="cstat-no" title="statement not covered" >i.mirror?0:c*n.width+l*o.height;<span class="cstat-no" title="statement not covered" ></span>t.height=Math.min(this.maxHeight,t.height+e+a)}</span>else{const e=<span class="cstat-no" title="statement not covered" >i.mirror?0:l*n.width+c*o.height;<span class="cstat-no" title="statement not covered" ></span>t.width=Math.min(this.maxWidth,t.width+e+a)}<span class="cstat-no" title="statement not covered" ></span>t</span>his._calculatePadding(e,s,c,l)}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>his._handleMargins(),r?(this.width=this._length=e.width-this._margins.left-this._margins.right,this.height=t.height):(this.width=t.width,this.height=this._length=e.height-this._margins.top-this._margins.bottom)}<span class="fstat-no" title="function not covered" ></span>_c</span>alculatePadding(t,e,i,s){const{ticks:{align:n,padding:o},position:r}=<span class="cstat-no" title="statement not covered" >this.options,</span>a=<span class="cstat-no" title="statement not covered" >0!==this.labelRotation,</span>h=<span class="cstat-no" title="statement not covered" >"top"!==r&amp;&amp;"x"===this.axis;<span class="cstat-no" title="statement not covered" ></span>if(this.isHorizontal()){const r=<span class="cstat-no" title="statement not covered" >this.getPixelForTick(0)-this.left,</span>l=<span class="cstat-no" title="statement not covered" >this.right-this.getPixelForTick(this.ticks.length-1);</span>let c=<span class="cstat-no" title="statement not covered" >0,</span>d=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>a?h?(c=s*t.width,d=i*e.height):(c=i*t.height,d=s*e.width):"start"===n?d=e.width:"end"===n?c=t.width:"inner"!==n&amp;&amp;(c=t.width/2,d=e.width/2),this.paddingLeft=Math.max((c-r+o)*this.width/(this.width-r),0),this.paddingRight=Math.max((d-l+o)*this.width/(this.width-l),0)}</span>else{let i=<span class="cstat-no" title="statement not covered" >e.height/2,</span>s=<span class="cstat-no" title="statement not covered" >t.height/2;<span class="cstat-no" title="statement not covered" ></span>"start"===n?(i=0,s=t.height):"end"===n&amp;&amp;(i=e.height,s=0),this.paddingTop=i+o,this.paddingBottom=s+o}</span>}<span class="fstat-no" title="function not covered" ></span>_h</span>andleMargins(){<span class="cstat-no" title="statement not covered" >this._margins&amp;&amp;(this._margins.left=Math.max(this.paddingLeft,this._margins.left),this._margins.top=Math.max(this.paddingTop,this._margins.top),this._margins.right=Math.max(this.paddingRight,this._margins.right),this._margins.bottom=Math.max(this.paddingBottom,this._margins.bottom))}<span class="fstat-no" title="function not covered" ></span>af</span>terFit(){<span class="cstat-no" title="statement not covered" >Y(this.options.afterFit,[this])}<span class="fstat-no" title="function not covered" ></span>is</span>Horizontal(){const{axis:t,position:e}=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>return"top"===e||"bottom"===e||"x"===t}<span class="fstat-no" title="function not covered" ></span>is</span>FullSize(){<span class="cstat-no" title="statement not covered" >return this.options.fullSize}<span class="fstat-no" title="function not covered" ></span>_c</span>onvertTicksToLabels(t){let e,i;<span class="cstat-no" title="statement not covered" >for(this.beforeTickToLabelConversion(),this.generateTickLabels(t),e=0,i=t.length;e&lt;i;e++)<span class="cstat-no" title="statement not covered" >B(t[e].label)&amp;&amp;(t.splice(e,1),i--,e--);<span class="cstat-no" title="statement not covered" >t</span></span>his.afterTickToLabelConversion()}<span class="fstat-no" title="function not covered" ></span>_g</span>etLabelSizes(){let t=<span class="cstat-no" title="statement not covered" >this._labelSizes;<span class="cstat-no" title="statement not covered" ></span>if(!t){const e=<span class="cstat-no" title="statement not covered" >this.options.ticks.sampleSize;</span>let i=<span class="cstat-no" title="statement not covered" >this.ticks;<span class="cstat-no" title="statement not covered" ></span>e&lt;i.length&amp;&amp;(i=Vs(i,e)),this._labelSizes=t=this._computeLabelSizes(i,i.length,this.options.ticks.maxTicksLimit)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}<span class="fstat-no" title="function not covered" ></span>_c</span>omputeLabelSizes(t,e,i){const{ctx:s,_longestTextCache:n}=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >Math.floor(e/Hs(e,i));</span>let h,l,c,d,u,f,g,p,x,m,b,_=<span class="cstat-no" title="statement not covered" >0,</span>y=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(h=0;h&lt;e;h+=a){<span class="cstat-no" title="statement not covered" >if(d=t[h].label,u=this._resolveTickFontOptions(h),s.font=f=u.string,g=n[f]=n[f]||{data:{},gc:[]},p=u.lineHeight,x=m=0,B(d)||W(d)){<span class="cstat-no" title="statement not covered" >if(W(d))<span class="cstat-no" title="statement not covered" >for(l=0,c=d.length;l&lt;c;++l)<span class="cstat-no" title="statement not covered" >b=d[l],B(b)||W(b)||(x=ae(s,g.data,g.gc,x,b),m+=p)}</span></span></span>else <span class="cstat-no" title="statement not covered" >x=ae(s,g.data,g.gc,x,d),m=p;<span class="cstat-no" title="statement not covered" >o</span></span>.push(x),r.push(m),_=Math.max(x,_),y=Math.max(m,y)}<span class="cstat-no" title="statement not covered" ></span>!<span class="fstat-no" title="function not covered" ></span>fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >U(t,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >t.gc,</span>s=<span class="cstat-no" title="statement not covered" >i.length/2;</span>let n;<span class="cstat-no" title="statement not covered" >if(s&gt;e){<span class="cstat-no" title="statement not covered" >for(n=0;n&lt;s;++n)<span class="cstat-no" title="statement not covered" >delete t.data[i[n]];<span class="cstat-no" title="statement not covered" >i</span></span>.splice(0,s)}</span>}</span>))}</span>(n,e);c</span>onst v=<span class="cstat-no" title="statement not covered" >o.indexOf(_),</span>w=<span class="cstat-no" title="statement not covered" >r.indexOf(y),</span>M=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >{width:o[t]||0,height:r[t]||0})</span>;<span class="cstat-no" title="statement not covered" ></span>return{first:M(0),last:M(e-1),widest:M(v),highest:M(w),widths:o,heights:r}}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelForValue(t){<span class="cstat-no" title="statement not covered" >return t}<span class="fstat-no" title="function not covered" ></span>ge</span>tPixelForValue(t,e){<span class="cstat-no" title="statement not covered" >return NaN}<span class="fstat-no" title="function not covered" ></span>ge</span>tValueForPixel(t){}<span class="fstat-no" title="function not covered" >ge</span>tPixelForTick(t){const e=<span class="cstat-no" title="statement not covered" >this.ticks;<span class="cstat-no" title="statement not covered" ></span>return t&lt;0||t&gt;e.length-1?null:this.getPixelForValue(e[t].value)}<span class="fstat-no" title="function not covered" ></span>ge</span>tPixelForDecimal(t){<span class="cstat-no" title="statement not covered" >this._reversePixels&amp;&amp;(t=1-t);c</span>onst e=<span class="cstat-no" title="statement not covered" >this._startPixel+t*this._length;<span class="cstat-no" title="statement not covered" ></span>return At(this._alignToPixels?he(this.chart,e,0):e,-32768,32767)}<span class="fstat-no" title="function not covered" ></span>ge</span>tDecimalForPixel(t){const e=<span class="cstat-no" title="statement not covered" >(t-this._startPixel)/this._length;<span class="cstat-no" title="statement not covered" ></span>return this._reversePixels?1-e:e}<span class="fstat-no" title="function not covered" ></span>ge</span>tBasePixel(){<span class="cstat-no" title="statement not covered" >return this.getPixelForValue(this.getBaseValue())}<span class="fstat-no" title="function not covered" ></span>ge</span>tBaseValue(){const{min:t,max:e}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return t&lt;0&amp;&amp;e&lt;0?e:t&gt;0&amp;&amp;e&gt;0?t:0}<span class="fstat-no" title="function not covered" ></span>ge</span>tContext(t){const e=<span class="cstat-no" title="statement not covered" >this.ticks||[];<span class="cstat-no" title="statement not covered" ></span>if(t&gt;=0&amp;&amp;t&lt;e.length){const i=<span class="cstat-no" title="statement not covered" >e[t];<span class="cstat-no" title="statement not covered" ></span>return i.$context||(i.$context=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return Ce(t,{tick:i,index:e,type:"tick"})}</span>(this.getContext(),t,i))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.$context||(this.$context=Ce(this.chart.getContext(),{scale:this,type:"scale"}))}<span class="fstat-no" title="function not covered" ></span>_t</span>ickSize(){const t=<span class="cstat-no" title="statement not covered" >this.options.ticks,</span>e=<span class="cstat-no" title="statement not covered" >yt(this.labelRotation),</span>i=<span class="cstat-no" title="statement not covered" >Math.abs(Math.cos(e)),</span>s=<span class="cstat-no" title="statement not covered" >Math.abs(Math.sin(e)),</span>n=<span class="cstat-no" title="statement not covered" >this._getLabelSizes(),</span>o=<span class="cstat-no" title="statement not covered" >t.autoSkipPadding||0,</span>r=<span class="cstat-no" title="statement not covered" >n?n.widest.width+o:0,</span>a=<span class="cstat-no" title="statement not covered" >n?n.highest.height+o:0;<span class="cstat-no" title="statement not covered" ></span>return this.isHorizontal()?a*i&gt;r*s?r/i:a/s:a*s&lt;r*i?a/i:r/s}<span class="fstat-no" title="function not covered" ></span>_i</span>sVisible(){const t=<span class="cstat-no" title="statement not covered" >this.options.display;<span class="cstat-no" title="statement not covered" ></span>return"auto"!==t?!!t:this.getMatchingVisibleMetas().length&gt;0}<span class="fstat-no" title="function not covered" ></span>_c</span>omputeGridLineItems(t){const e=<span class="cstat-no" title="statement not covered" >this.axis,</span>i=<span class="cstat-no" title="statement not covered" >this.chart,</span>s=<span class="cstat-no" title="statement not covered" >this.options,</span>{grid:n,position:o,border:r}=<span class="cstat-no" title="statement not covered" >s,</span>a=<span class="cstat-no" title="statement not covered" >n.offset,</span>h=<span class="cstat-no" title="statement not covered" >this.isHorizontal(),</span>l=<span class="cstat-no" title="statement not covered" >this.ticks.length+(a?1:0),</span>c=<span class="cstat-no" title="statement not covered" >Ns(n),</span>d=<span class="cstat-no" title="statement not covered" >[],</span>u=<span class="cstat-no" title="statement not covered" >r.setContext(this.getContext()),</span>f=<span class="cstat-no" title="statement not covered" >u.display?u.width:0,</span>g=<span class="cstat-no" title="statement not covered" >f/2,</span>p=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return he(i,t,f)}</span>;</span>let x,m,b,_,y,v,w,M,k,S,P,D;<span class="cstat-no" title="statement not covered" >if("top"===o)<span class="cstat-no" title="statement not covered" >x=p(this.bottom),v=this.bottom-c,M=x-g,S=p(t.top)+g,D=t.bottom;e</span>lse <span class="cstat-no" title="statement not covered" >if("bottom"===o)<span class="cstat-no" title="statement not covered" >x=p(this.top),S=t.top,D=p(t.bottom)-g,v=x+g,M=this.top+c;e</span>lse <span class="cstat-no" title="statement not covered" >if("left"===o)<span class="cstat-no" title="statement not covered" >x=p(this.right),y=this.right-c,w=x-g,k=p(t.left)+g,P=t.right;e</span>lse <span class="cstat-no" title="statement not covered" >if("right"===o)<span class="cstat-no" title="statement not covered" >x=p(this.left),k=t.left,P=p(t.right)-g,y=x+g,w=this.left+c;e</span>lse <span class="cstat-no" title="statement not covered" >if("x"===e){<span class="cstat-no" title="statement not covered" >if("center"===o)<span class="cstat-no" title="statement not covered" >x=p((t.top+t.bottom)/2+.5);e</span>lse <span class="cstat-no" title="statement not covered" >if(H(o)){const t=<span class="cstat-no" title="statement not covered" >Object.keys(o)[0],</span>e=<span class="cstat-no" title="statement not covered" >o[t];<span class="cstat-no" title="statement not covered" ></span>x=p(this.chart.scales[t].getPixelForValue(e))}<span class="cstat-no" title="statement not covered" ></span>S</span></span>=t.top,D=t.bottom,v=x+g,M=v+c}</span>else <span class="cstat-no" title="statement not covered" >if("y"===e){<span class="cstat-no" title="statement not covered" >if("center"===o)<span class="cstat-no" title="statement not covered" >x=p((t.left+t.right)/2);e</span>lse <span class="cstat-no" title="statement not covered" >if(H(o)){const t=<span class="cstat-no" title="statement not covered" >Object.keys(o)[0],</span>e=<span class="cstat-no" title="statement not covered" >o[t];<span class="cstat-no" title="statement not covered" ></span>x=p(this.chart.scales[t].getPixelForValue(e))}<span class="cstat-no" title="statement not covered" ></span>y</span></span>=x-g,w=y-c,k=t.left,P=t.right}</span>c</span></span></span></span></span></span>onst A=<span class="cstat-no" title="statement not covered" >N(s.ticks.maxTicksLimit,l),</span>O=<span class="cstat-no" title="statement not covered" >Math.max(1,Math.ceil(l/A));<span class="cstat-no" title="statement not covered" ></span>for(m=0;m&lt;l;m+=O){const t=<span class="cstat-no" title="statement not covered" >this.getContext(m),</span>e=<span class="cstat-no" title="statement not covered" >n.setContext(t),</span>s=<span class="cstat-no" title="statement not covered" >r.setContext(t),</span>o=<span class="cstat-no" title="statement not covered" >e.lineWidth,</span>l=<span class="cstat-no" title="statement not covered" >e.color,</span>c=<span class="cstat-no" title="statement not covered" >s.dash||[],</span>u=<span class="cstat-no" title="statement not covered" >s.dashOffset,</span>f=<span class="cstat-no" title="statement not covered" >e.tickWidth,</span>g=<span class="cstat-no" title="statement not covered" >e.tickColor,</span>p=<span class="cstat-no" title="statement not covered" >e.tickBorderDash||[],</span>x=<span class="cstat-no" title="statement not covered" >e.tickBorderDashOffset;<span class="cstat-no" title="statement not covered" ></span>b=js(this,m,a),void 0!==b&amp;&amp;(_=he(i,b,o),h?y=w=k=P=_:v=M=S=D=_,d.push({tx1:y,ty1:v,tx2:w,ty2:M,x1:k,y1:S,x2:P,y2:D,width:o,color:l,borderDash:c,borderDashOffset:u,tickWidth:f,tickColor:g,tickBorderDash:p,tickBorderDashOffset:x}))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this._ticksLength=l,this._borderValue=x,d}<span class="fstat-no" title="function not covered" ></span>_c</span>omputeLabelItems(t){const e=<span class="cstat-no" title="statement not covered" >this.axis,</span>i=<span class="cstat-no" title="statement not covered" >this.options,</span>{position:s,ticks:n}=<span class="cstat-no" title="statement not covered" >i,</span>o=<span class="cstat-no" title="statement not covered" >this.isHorizontal(),</span>r=<span class="cstat-no" title="statement not covered" >this.ticks,</span>{align:a,crossAlign:h,padding:l,mirror:c}=<span class="cstat-no" title="statement not covered" >n,</span>d=<span class="cstat-no" title="statement not covered" >Ns(i.grid),</span>u=<span class="cstat-no" title="statement not covered" >d+l,</span>f=<span class="cstat-no" title="statement not covered" >c?-l:u,</span>g=<span class="cstat-no" title="statement not covered" >-yt(this.labelRotation),</span>p=<span class="cstat-no" title="statement not covered" >[];</span>let x,m,b,_,y,v,w,M,k,S,P,D,A=<span class="cstat-no" title="statement not covered" >"middle";<span class="cstat-no" title="statement not covered" ></span>if("top"===s)<span class="cstat-no" title="statement not covered" >v=this.bottom-f,w=this._getXAxisLabelAlignment();e</span>lse <span class="cstat-no" title="statement not covered" >if("bottom"===s)<span class="cstat-no" title="statement not covered" >v=this.top+f,w=this._getXAxisLabelAlignment();e</span>lse <span class="cstat-no" title="statement not covered" >if("left"===s){const t=<span class="cstat-no" title="statement not covered" >this._getYAxisLabelAlignment(d);<span class="cstat-no" title="statement not covered" ></span>w=t.textAlign,y=t.x}</span>else <span class="cstat-no" title="statement not covered" >if("right"===s){const t=<span class="cstat-no" title="statement not covered" >this._getYAxisLabelAlignment(d);<span class="cstat-no" title="statement not covered" ></span>w=t.textAlign,y=t.x}</span>else <span class="cstat-no" title="statement not covered" >if("x"===e){<span class="cstat-no" title="statement not covered" >if("center"===s)<span class="cstat-no" title="statement not covered" >v=(t.top+t.bottom)/2+u;e</span>lse <span class="cstat-no" title="statement not covered" >if(H(s)){const t=<span class="cstat-no" title="statement not covered" >Object.keys(s)[0],</span>e=<span class="cstat-no" title="statement not covered" >s[t];<span class="cstat-no" title="statement not covered" ></span>v=this.chart.scales[t].getPixelForValue(e)+u}<span class="cstat-no" title="statement not covered" ></span>w</span></span>=this._getXAxisLabelAlignment()}</span>else <span class="cstat-no" title="statement not covered" >if("y"===e){<span class="cstat-no" title="statement not covered" >if("center"===s)<span class="cstat-no" title="statement not covered" >y=(t.left+t.right)/2-u;e</span>lse <span class="cstat-no" title="statement not covered" >if(H(s)){const t=<span class="cstat-no" title="statement not covered" >Object.keys(s)[0],</span>e=<span class="cstat-no" title="statement not covered" >s[t];<span class="cstat-no" title="statement not covered" ></span>y=this.chart.scales[t].getPixelForValue(e)}<span class="cstat-no" title="statement not covered" ></span>w</span></span>=this._getYAxisLabelAlignment(d).textAlign}<span class="cstat-no" title="statement not covered" ></span>"</span></span></span></span></span></span>y"===e&amp;&amp;("start"===a?A="top":"end"===a&amp;&amp;(A="bottom"));c</span>onst O=<span class="cstat-no" title="statement not covered" >this._getLabelSizes();<span class="cstat-no" title="statement not covered" ></span>for(x=0,m=r.length;x&lt;m;++x){<span class="cstat-no" title="statement not covered" >b=r[x],_=b.label;c</span>onst t=<span class="cstat-no" title="statement not covered" >n.setContext(this.getContext(x));<span class="cstat-no" title="statement not covered" ></span>M=this.getPixelForTick(x)+n.labelOffset,k=this._resolveTickFontOptions(x),S=k.lineHeight,P=W(_)?_.length:1;c</span>onst e=<span class="cstat-no" title="statement not covered" >P/2,</span>i=<span class="cstat-no" title="statement not covered" >t.color,</span>a=<span class="cstat-no" title="statement not covered" >t.textStrokeColor,</span>l=<span class="cstat-no" title="statement not covered" >t.textStrokeWidth;</span>let d,u=<span class="cstat-no" title="statement not covered" >w;<span class="cstat-no" title="statement not covered" ></span>if(o?(y=M,"inner"===w&amp;&amp;(u=x===m-1?this.options.reverse?"left":"right":0===x?this.options.reverse?"right":"left":"center"),D="top"===s?"near"===h||0!==g?-P*S+S/2:"center"===h?-O.highest.height/2-e*S+S:-O.highest.height+S/2:"near"===h||0!==g?S/2:"center"===h?O.highest.height/2-e*S:O.highest.height-P*S,c&amp;&amp;(D*=-1),0===g||t.showLabelBackdrop||(y+=S/2*Math.sin(g))):(v=M,D=(1-P)*S/2),t.showLabelBackdrop){const e=<span class="cstat-no" title="statement not covered" >De(t.backdropPadding),</span>i=<span class="cstat-no" title="statement not covered" >O.heights[x],</span>s=<span class="cstat-no" title="statement not covered" >O.widths[x];</span>let n=<span class="cstat-no" title="statement not covered" >D-e.top,</span>o=<span class="cstat-no" title="statement not covered" >0-e.left;<span class="cstat-no" title="statement not covered" ></span>switch(A){case"middle":<span class="cstat-no" title="statement not covered" >n-=i/2;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"bottom":<span class="cstat-no" title="statement not covered" >n-=i}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(w){case"center":<span class="cstat-no" title="statement not covered" >o-=s/2;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"right":<span class="cstat-no" title="statement not covered" >o-=s;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"inner":<span class="cstat-no" title="statement not covered" >x===m-1?o-=s:x&gt;0&amp;&amp;(o-=s/2)}<span class="cstat-no" title="statement not covered" ></span>d</span>={left:o,top:n,width:s+e.width,height:i+e.height,color:t.backdropColor}}<span class="cstat-no" title="statement not covered" ></span>p</span>.push({label:_,font:k,textOffset:D,options:{rotation:g,color:i,strokeColor:a,strokeWidth:l,textAlign:u,textBaseline:A,translation:[y,v],backdrop:d}})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn p}<span class="fstat-no" title="function not covered" ></span>_g</span>etXAxisLabelAlignment(){const{position:t,ticks:e}=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if(-yt(this.labelRotation))<span class="cstat-no" title="statement not covered" >return"top"===t?"left":"right";l</span></span>et i=<span class="cstat-no" title="statement not covered" >"center";<span class="cstat-no" title="statement not covered" ></span>return"start"===e.align?i="left":"end"===e.align?i="right":"inner"===e.align&amp;&amp;(i="inner"),i}<span class="fstat-no" title="function not covered" ></span>_g</span>etYAxisLabelAlignment(t){const{position:e,ticks:{crossAlign:i,mirror:s,padding:n}}=<span class="cstat-no" title="statement not covered" >this.options,</span>o=<span class="cstat-no" title="statement not covered" >t+n,</span>r=<span class="cstat-no" title="statement not covered" >this._getLabelSizes().widest.width;</span>let a,h;<span class="cstat-no" title="statement not covered" >return"left"===e?s?(h=this.right+n,"near"===i?a="left":"center"===i?(a="center",h+=r/2):(a="right",h+=r)):(h=this.right-o,"near"===i?a="right":"center"===i?(a="center",h-=r/2):(a="left",h=this.left)):"right"===e?s?(h=this.left+n,"near"===i?a="right":"center"===i?(a="center",h-=r/2):(a="left",h-=r)):(h=this.left+o,"near"===i?a="left":"center"===i?(a="center",h+=r/2):(a="right",h=this.right)):a="right",{textAlign:a,x:h}}<span class="fstat-no" title="function not covered" ></span>_c</span>omputeLabelArea(){<span class="cstat-no" title="statement not covered" >if(this.options.ticks.mirror)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this.chart,</span>e=<span class="cstat-no" title="statement not covered" >this.options.position;<span class="cstat-no" title="statement not covered" ></span>return"left"===e||"right"===e?{top:0,left:this.left,bottom:t.height,right:this.right}:"top"===e||"bottom"===e?{top:this.top,left:0,bottom:this.bottom,right:t.width}:void 0}<span class="fstat-no" title="function not covered" ></span>dr</span>awBackground(){const{ctx:t,options:{backgroundColor:e},left:i,top:s,width:n,height:o}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;(t.save(),t.fillStyle=e,t.fillRect(i,s,n,o),t.restore())}<span class="fstat-no" title="function not covered" ></span>ge</span>tLineWidthForValue(t){const e=<span class="cstat-no" title="statement not covered" >this.options.grid;<span class="cstat-no" title="statement not covered" ></span>if(!this._isVisible()||!e.display)<span class="cstat-no" title="statement not covered" >return 0;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >this.ticks.findIndex((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.value===t)</span>);<span class="cstat-no" title="statement not covered" ></span>if(i&gt;=0){<span class="cstat-no" title="statement not covered" >return e.setContext(this.getContext(i)).lineWidth}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn 0}<span class="fstat-no" title="function not covered" ></span>dr</span>awGrid(t){const e=<span class="cstat-no" title="statement not covered" >this.options.grid,</span>i=<span class="cstat-no" title="statement not covered" >this.ctx,</span>s=<span class="cstat-no" title="statement not covered" >this._gridLineItems||(this._gridLineItems=this._computeGridLineItems(t));</span>let n,o;const r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >s.width&amp;&amp;s.color&amp;&amp;(i.save(),i.lineWidth=s.width,i.strokeStyle=s.color,i.setLineDash(s.borderDash||[]),i.lineDashOffset=s.borderDashOffset,i.beginPath(),i.moveTo(t.x,t.y),i.lineTo(e.x,e.y),i.stroke(),i.restore())}</span>;<span class="cstat-no" title="statement not covered" ></span>if(e.display)<span class="cstat-no" title="statement not covered" >for(n=0,o=s.length;n&lt;o;++n){const t=<span class="cstat-no" title="statement not covered" >s[n];<span class="cstat-no" title="statement not covered" ></span>e.drawOnChartArea&amp;&amp;r({x:t.x1,y:t.y1},{x:t.x2,y:t.y2},t),e.drawTicks&amp;&amp;r({x:t.tx1,y:t.ty1},{x:t.tx2,y:t.ty2},{color:t.tickColor,width:t.tickWidth,borderDash:t.tickBorderDash,borderDashOffset:t.tickBorderDashOffset})}</span>}<span class="fstat-no" title="function not covered" ></span></span>dr</span>awBorder(){const{chart:t,ctx:e,options:{border:i,grid:s}}=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >i.setContext(this.getContext()),</span>o=<span class="cstat-no" title="statement not covered" >i.display?n.width:0;<span class="cstat-no" title="statement not covered" ></span>if(!o)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >s.setContext(this.getContext(0)).lineWidth,</span>a=<span class="cstat-no" title="statement not covered" >this._borderValue;</span>let h,l,c,d;<span class="cstat-no" title="statement not covered" >this.isHorizontal()?(h=he(t,this.left,o)-o/2,l=he(t,this.right,r)+r/2,c=d=a):(c=he(t,this.top,o)-o/2,d=he(t,this.bottom,r)+r/2,h=l=a),e.save(),e.lineWidth=n.width,e.strokeStyle=n.color,e.beginPath(),e.moveTo(h,c),e.lineTo(l,d),e.stroke(),e.restore()}<span class="fstat-no" title="function not covered" ></span>dr</span>awLabels(t){<span class="cstat-no" title="statement not covered" >if(!this.options.ticks.display)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.ctx,</span>i=<span class="cstat-no" title="statement not covered" >this._computeLabelArea();<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;fe(e,i);c</span>onst s=<span class="cstat-no" title="statement not covered" >this.getLabelItems(t);<span class="cstat-no" title="statement not covered" ></span>for(const n of s){const t=<span class="cstat-no" title="statement not covered" >n.options,</span>i=<span class="cstat-no" title="statement not covered" >n.font;<span class="cstat-no" title="statement not covered" ></span>_e(e,n.label,0,n.textOffset,i,t)}<span class="cstat-no" title="statement not covered" ></span>i</span>&amp;&amp;ge(e)}<span class="fstat-no" title="function not covered" ></span>dr</span>awTitle(){const{ctx:t,options:{position:e,title:i,reverse:s}}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(!i.display)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >Ae(i.font),</span>o=<span class="cstat-no" title="statement not covered" >De(i.padding),</span>r=<span class="cstat-no" title="statement not covered" >i.align;</span>let a=<span class="cstat-no" title="statement not covered" >n.lineHeight/2;<span class="cstat-no" title="statement not covered" ></span>"bottom"===e||"center"===e||H(e)?(a+=o.bottom,W(i.text)&amp;&amp;(a+=n.lineHeight*(i.text.length-1))):a+=o.top;c</span>onst{titleX:h,titleY:l,maxWidth:c,rotation:d}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const{top:n,left:o,bottom:r,right:a,chart:h}=<span class="cstat-no" title="statement not covered" >t,</span>{chartArea:l,scales:c}=<span class="cstat-no" title="statement not covered" >h;</span>let d,u,f,g=<span class="cstat-no" title="statement not covered" >0;</span>const p=<span class="cstat-no" title="statement not covered" >r-n,</span>x=<span class="cstat-no" title="statement not covered" >a-o;<span class="cstat-no" title="statement not covered" ></span>if(t.isHorizontal()){<span class="cstat-no" title="statement not covered" >if(u=Wt(s,o,a),H(i)){const t=<span class="cstat-no" title="statement not covered" >Object.keys(i)[0],</span>s=<span class="cstat-no" title="statement not covered" >i[t];<span class="cstat-no" title="statement not covered" ></span>f=c[t].getPixelForValue(s)+p-e}</span>else <span class="cstat-no" title="statement not covered" >f="center"===i?(l.bottom+l.top)/2+p-e:Ws(t,i,e);<span class="cstat-no" title="statement not covered" >d</span></span>=a-o}</span>else{<span class="cstat-no" title="statement not covered" >if(H(i)){const t=<span class="cstat-no" title="statement not covered" >Object.keys(i)[0],</span>s=<span class="cstat-no" title="statement not covered" >i[t];<span class="cstat-no" title="statement not covered" ></span>u=c[t].getPixelForValue(s)-x+e}</span>else <span class="cstat-no" title="statement not covered" >u="center"===i?(l.left+l.right)/2-x+e:Ws(t,i,e);<span class="cstat-no" title="statement not covered" >f</span></span>=Wt(s,r,n),g="left"===i?-dt:dt}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{titleX:u,titleY:f,maxWidth:d,rotation:g}}</span>(this,a,e,r);<span class="cstat-no" title="statement not covered" ></span>_e(t,i.text,0,0,n,{color:i.color,maxWidth:c,rotation:d,textAlign:Ys(r,e,s),textBaseline:"middle",translation:[h,l]})}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(t){<span class="cstat-no" title="statement not covered" >this._isVisible()&amp;&amp;(this.drawBackground(),this.drawGrid(t),this.drawBorder(),this.drawTitle(),this.drawLabels(t))}<span class="fstat-no" title="function not covered" ></span>_l</span>ayers(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >t.ticks&amp;&amp;t.ticks.z||0,</span>i=<span class="cstat-no" title="statement not covered" >N(t.grid&amp;&amp;t.grid.z,-1),</span>s=<span class="cstat-no" title="statement not covered" >N(t.border&amp;&amp;t.border.z,0);<span class="cstat-no" title="statement not covered" ></span>return this._isVisible()&amp;&amp;this.draw===Us.prototype.draw?[{z:i,draw:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.drawBackground(),this.drawGrid(t),this.drawTitle()}</span>},{z:s,draw:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.drawBorder()}</span>},{z:e,draw:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.drawLabels(t)}</span>}]:[{z:e,draw:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.draw(t)}</span>}]}<span class="fstat-no" title="function not covered" ></span>ge</span>tMatchingVisibleMetas(t){const e=<span class="cstat-no" title="statement not covered" >this.chart.getSortedVisibleDatasetMetas(),</span>i=<span class="cstat-no" title="statement not covered" >this.axis+"AxisID",</span>s=<span class="cstat-no" title="statement not covered" >[];</span>let n,o;<span class="cstat-no" title="statement not covered" >for(n=0,o=e.length;n&lt;o;++n){const o=<span class="cstat-no" title="statement not covered" >e[n];<span class="cstat-no" title="statement not covered" ></span>o[i]!==this.id||t&amp;&amp;o.type!==t||s.push(o)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>_r</span>esolveTickFontOptions(t){<span class="cstat-no" title="statement not covered" >return Ae(this.options.ticks.setContext(this.getContext(t)).font)}<span class="fstat-no" title="function not covered" ></span>_m</span>axDigits(){const t=<span class="cstat-no" title="statement not covered" >this._resolveTickFontOptions(0).lineHeight;<span class="cstat-no" title="statement not covered" ></span>return(this.isHorizontal()?this.width:this.height)/t}</span>}class Xs{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,i){<span class="cstat-no" title="statement not covered" >this.type=t,this.scope=e,this.override=i,this.items=Object.create(null)}<span class="fstat-no" title="function not covered" ></span>is</span>ForType(t){<span class="cstat-no" title="statement not covered" >return Object.prototype.isPrototypeOf.call(this.type.prototype,t.prototype)}<span class="fstat-no" title="function not covered" ></span>re</span>gister(t){const e=<span class="cstat-no" title="statement not covered" >Object.getPrototypeOf(t);</span>let i;<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"id"in t&amp;&amp;"defaults"in t}</span>)(e)&amp;&amp;(i=this.register(e));c</span>onst s=<span class="cstat-no" title="statement not covered" >this.items,</span>n=<span class="cstat-no" title="statement not covered" >t.id,</span>o=<span class="cstat-no" title="statement not covered" >this.scope+"."+n;<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >throw new Error("class does not have id: "+t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n in s||(s[n]=t,<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const s=<span class="cstat-no" title="statement not covered" >G(Object.create(null),[i?re.get(i):{},re.get(e),t.defaults]);<span class="cstat-no" title="statement not covered" ></span>re.set(e,s),t.defaultRoutes&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >Object.keys(e).forEach((<span class="fstat-no" title="function not covered" >i=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >i.split("."),</span>n=<span class="cstat-no" title="statement not covered" >s.pop(),</span>o=<span class="cstat-no" title="statement not covered" >[t].concat(s).join("."),</span>r=<span class="cstat-no" title="statement not covered" >e[i].split("."),</span>a=<span class="cstat-no" title="statement not covered" >r.pop(),</span>h=<span class="cstat-no" title="statement not covered" >r.join(".");<span class="cstat-no" title="statement not covered" ></span>re.route(o,n,h,a)}</span>))}</span>(e,t.defaultRoutes);<span class="cstat-no" title="statement not covered" >t</span>.descriptors&amp;&amp;re.describe(e,t.descriptors)}</span>(t,o,i),this.override&amp;&amp;re.override(t.id,t.overrides)),o}<span class="fstat-no" title="function not covered" ></span>ge</span>t(t){<span class="cstat-no" title="statement not covered" >return this.items[t]}<span class="fstat-no" title="function not covered" ></span>un</span>register(t){const e=<span class="cstat-no" title="statement not covered" >this.items,</span>i=<span class="cstat-no" title="statement not covered" >t.id,</span>s=<span class="cstat-no" title="statement not covered" >this.scope;<span class="cstat-no" title="statement not covered" ></span>i in e&amp;&amp;delete e[i],s&amp;&amp;i in re[s]&amp;&amp;(delete re[s][i],this.override&amp;&amp;delete ee[i])}</span>}class qs{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.controllers=new Xs(Vi,"datasets",!0),this.elements=new Xs(zs,"elements"),this.plugins=new Xs(Object,"plugins"),this.scales=new Xs(Us,"scales"),this._typedRegistries=[this.controllers,this.scales,this.elements]}<span class="fstat-no" title="function not covered" ></span>ad</span>d(...t){<span class="cstat-no" title="statement not covered" >this._each("register",t)}<span class="fstat-no" title="function not covered" ></span>re</span>move(...t){<span class="cstat-no" title="statement not covered" >this._each("unregister",t)}<span class="fstat-no" title="function not covered" ></span>ad</span>dControllers(...t){<span class="cstat-no" title="statement not covered" >this._each("register",t,this.controllers)}<span class="fstat-no" title="function not covered" ></span>ad</span>dElements(...t){<span class="cstat-no" title="statement not covered" >this._each("register",t,this.elements)}<span class="fstat-no" title="function not covered" ></span>ad</span>dPlugins(...t){<span class="cstat-no" title="statement not covered" >this._each("register",t,this.plugins)}<span class="fstat-no" title="function not covered" ></span>ad</span>dScales(...t){<span class="cstat-no" title="statement not covered" >this._each("register",t,this.scales)}<span class="fstat-no" title="function not covered" ></span>ge</span>tController(t){<span class="cstat-no" title="statement not covered" >return this._get(t,this.controllers,"controller")}<span class="fstat-no" title="function not covered" ></span>ge</span>tElement(t){<span class="cstat-no" title="statement not covered" >return this._get(t,this.elements,"element")}<span class="fstat-no" title="function not covered" ></span>ge</span>tPlugin(t){<span class="cstat-no" title="statement not covered" >return this._get(t,this.plugins,"plugin")}<span class="fstat-no" title="function not covered" ></span>ge</span>tScale(t){<span class="cstat-no" title="statement not covered" >return this._get(t,this.scales,"scale")}<span class="fstat-no" title="function not covered" ></span>re</span>moveControllers(...t){<span class="cstat-no" title="statement not covered" >this._each("unregister",t,this.controllers)}<span class="fstat-no" title="function not covered" ></span>re</span>moveElements(...t){<span class="cstat-no" title="statement not covered" >this._each("unregister",t,this.elements)}<span class="fstat-no" title="function not covered" ></span>re</span>movePlugins(...t){<span class="cstat-no" title="statement not covered" >this._each("unregister",t,this.plugins)}<span class="fstat-no" title="function not covered" ></span>re</span>moveScales(...t){<span class="cstat-no" title="statement not covered" >this._each("unregister",t,this.scales)}<span class="fstat-no" title="function not covered" ></span>_e</span>ach(t,e,i){<span class="cstat-no" title="statement not covered" >[...e].forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >i||this._getRegistryForType(e);<span class="cstat-no" title="statement not covered" ></span>i||s.isForType(e)||s===this.plugins&amp;&amp;e.id?this._exec(t,s,e):U(e,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >i||this._getRegistryForType(e);<span class="cstat-no" title="statement not covered" ></span>this._exec(t,s,e)}</span>))}</span>))}<span class="fstat-no" title="function not covered" ></span>_e</span>xec(t,e,i){const s=<span class="cstat-no" title="statement not covered" >it(t);<span class="cstat-no" title="statement not covered" ></span>Y(i["before"+s],[],i),e[t](i),Y(i["after"+s],[],i)}<span class="fstat-no" title="function not covered" ></span>_g</span>etRegistryForType(t){<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this._typedRegistries.length;e++){const i=<span class="cstat-no" title="statement not covered" >this._typedRegistries[e];<span class="cstat-no" title="statement not covered" ></span>if(i.isForType(t))<span class="cstat-no" title="statement not covered" >return i}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn this.plugins}<span class="fstat-no" title="function not covered" ></span>_g</span>et(t,e,i){const s=<span class="cstat-no" title="statement not covered" >e.get(t);<span class="cstat-no" title="statement not covered" ></span>if(void 0===s)<span class="cstat-no" title="statement not covered" >throw new Error('"'+t+'" is not a registered '+i+".");<span class="cstat-no" title="statement not covered" >r</span></span>eturn s}</span>}var Ks=<span class="cstat-no" title="statement not covered" >new qs;</span>class Js{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this._init=void 0}<span class="fstat-no" title="function not covered" ></span>no</span>tify(t,e,i,s){<span class="cstat-no" title="statement not covered" >if("beforeInit"===e&amp;&amp;(this._init=this._createDescriptors(t,!0),this._notify(this._init,t,"install")),void 0===this._init)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >s?this._descriptors(t).filter(s):this._descriptors(t),</span>o=<span class="cstat-no" title="statement not covered" >this._notify(n,t,e,i);<span class="cstat-no" title="statement not covered" ></span>return"afterDestroy"===e&amp;&amp;(this._notify(n,t,"stop"),this._notify(this._init,t,"uninstall"),this._init=void 0),o}<span class="fstat-no" title="function not covered" ></span>_n</span>otify(t,e,i,s){<span class="cstat-no" title="statement not covered" >s=s||{};<span class="cstat-no" title="statement not covered" >f</span>or(const n of t){const t=<span class="cstat-no" title="statement not covered" >n.plugin;<span class="cstat-no" title="statement not covered" ></span>if(!1===Y(t[i],[e,s,n.options],t)&amp;&amp;s.cancelable)<span class="cstat-no" title="statement not covered" >return!1}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!0}<span class="fstat-no" title="function not covered" ></span>in</span>validate(){<span class="cstat-no" title="statement not covered" >B(this._cache)||(this._oldCache=this._cache,this._cache=void 0)}<span class="fstat-no" title="function not covered" ></span>_d</span>escriptors(t){<span class="cstat-no" title="statement not covered" >if(this._cache)<span class="cstat-no" title="statement not covered" >return this._cache;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this._cache=this._createDescriptors(t);<span class="cstat-no" title="statement not covered" ></span>return this._notifyStateChanges(t),e}<span class="fstat-no" title="function not covered" ></span>_c</span>reateDescriptors(t,e){const i=<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.config,</span>s=<span class="cstat-no" title="statement not covered" >N(i.options&amp;&amp;i.options.plugins,{}),</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >{},</span>i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >Object.keys(Ks.plugins.items);<span class="cstat-no" title="statement not covered" ></span>for(let o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;s.length;o++)<span class="cstat-no" title="statement not covered" >i.push(Ks.getPlugin(s[o]));c</span></span>onst n=<span class="cstat-no" title="statement not covered" >t.plugins||[];<span class="cstat-no" title="statement not covered" ></span>for(let o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;n.length;o++){const t=<span class="cstat-no" title="statement not covered" >n[o];<span class="cstat-no" title="statement not covered" ></span>-1===i.indexOf(t)&amp;&amp;(i.push(t),e[t.id]=!0)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{plugins:i,localIds:e}}</span>(i);<span class="cstat-no" title="statement not covered" ></span>return!1!==s||e?<span class="fstat-no" title="function not covered" >fu</span>nction(t,{plugins:e,localIds:i},s,n){const o=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >t.getContext();<span class="cstat-no" title="statement not covered" ></span>for(const a of e){const e=<span class="cstat-no" title="statement not covered" >a.id,</span>h=<span class="cstat-no" title="statement not covered" >Gs(s[e],n);<span class="cstat-no" title="statement not covered" ></span>null!==h&amp;&amp;o.push({plugin:a,options:Zs(t.config,{plugin:a,local:i[e]},h,r)})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o}</span>(t,n,s,e):[]}<span class="fstat-no" title="function not covered" ></span>_n</span>otifyStateChanges(t){const e=<span class="cstat-no" title="statement not covered" >this._oldCache||[],</span>i=<span class="cstat-no" title="statement not covered" >this._cache,</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!e.some((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >t.plugin.id===e.plugin.id)</span>))</span>);<span class="cstat-no" title="statement not covered" ></span></span>this._notify(s(e,i),t,"stop"),this._notify(s(i,e),t,"start")}</span>}function <span class="fstat-no" title="function not covered" >Gs(</span>t,e){<span class="cstat-no" title="statement not covered" >return e||!1!==t?!0===t?{}:t:null}</span>function <span class="fstat-no" title="function not covered" >Zs(</span>t,{plugin:e,local:i},s,n){const o=<span class="cstat-no" title="statement not covered" >t.pluginScopeKeys(e),</span>r=<span class="cstat-no" title="statement not covered" >t.getOptionScopes(s,o);<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;e.defaults&amp;&amp;r.push(e.defaults),t.createResolver(r,n,[""],{scriptable:!1,indexable:!1,allKeys:!0})}</span>function <span class="fstat-no" title="function not covered" >Qs(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >re.datasets[t]||{};<span class="cstat-no" title="statement not covered" ></span>return((e.datasets||{})[t]||{}).indexAxis||e.indexAxis||i.indexAxis||"x"}</span>function <span class="fstat-no" title="function not covered" >tn(</span>t){<span class="cstat-no" title="statement not covered" >if("x"===t||"y"===t||"r"===t)<span class="cstat-no" title="statement not covered" >return t}</span></span>function <span class="fstat-no" title="function not covered" >en(</span>t,...e){<span class="cstat-no" title="statement not covered" >if(tn(t))<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >f</span></span>or(const s of e){const e=<span class="cstat-no" title="statement not covered" >s.axis||("top"===(i=s.position)||"bottom"===i?"x":"left"===i||"right"===i?"y":void 0)||t.length&gt;1&amp;&amp;tn(t[0].toLowerCase());<span class="cstat-no" title="statement not covered" ></span>if(e)<span class="cstat-no" title="statement not covered" >return e}</span></span>v</span>ar i;<span class="cstat-no" title="statement not covered" >throw new Error(`Cannot determine type of '${t}' axis. Please provide 'axis' or 'position' option.`)}</span>function <span class="fstat-no" title="function not covered" >sn(</span>t,e,i){<span class="cstat-no" title="statement not covered" >if(i[e+"AxisID"]===t)<span class="cstat-no" title="statement not covered" >return{axis:e}}</span></span>function <span class="fstat-no" title="function not covered" >nn(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >ee[t.type]||{scales:{}},</span>s=<span class="cstat-no" title="statement not covered" >e.scales||{},</span>n=<span class="cstat-no" title="statement not covered" >Qs(t.type,e),</span>o=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>return Object.keys(s).forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const r=<span class="cstat-no" title="statement not covered" >s[e];<span class="cstat-no" title="statement not covered" ></span>if(!H(r))<span class="cstat-no" title="statement not covered" >return console.error(`Invalid scale configuration for scale: ${e}`);<span class="cstat-no" title="statement not covered" >i</span></span>f(r._proxy)<span class="cstat-no" title="statement not covered" >return console.warn(`Ignoring resolver passed as options for scale: ${e}`);c</span></span>onst a=<span class="cstat-no" title="statement not covered" >en(e,r,<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(e.data&amp;&amp;e.data.datasets){const i=<span class="cstat-no" title="statement not covered" >e.data.datasets.filter((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.xAxisID===t||e.yAxisID===t)</span>);<span class="cstat-no" title="statement not covered" ></span>if(i.length)<span class="cstat-no" title="statement not covered" >return sn(t,"x",i[0])||sn(t,"y",i[0])}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn{}}</span>(e,t),re.scales[r.type]),</span>h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t===e?"_index_":"_value_"}</span>(a,n),</span>l=<span class="cstat-no" title="statement not covered" >i.scales||{};<span class="cstat-no" title="statement not covered" ></span>o[e]=Z(Object.create(null),[{axis:a},r,l[a],l[h]])}</span>)),t.data.datasets.forEach((<span class="fstat-no" title="function not covered" >i=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >i.type||t.type,</span>r=<span class="cstat-no" title="statement not covered" >i.indexAxis||Qs(n,e),</span>a=<span class="cstat-no" title="statement not covered" >(ee[n]||{}).scales||{};<span class="cstat-no" title="statement not covered" ></span>Object.keys(a).forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){let i=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return"_index_"===t?i=e:"_value_"===t&amp;&amp;(i="x"===e?"y":"x"),i}</span>(t,r),</span>n=<span class="cstat-no" title="statement not covered" >i[e+"AxisID"]||e;<span class="cstat-no" title="statement not covered" ></span>o[n]=o[n]||Object.create(null),Z(o[n],[{axis:e},s[n],a[t]])}</span>))}</span>)),Object.keys(o).forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >o[t];<span class="cstat-no" title="statement not covered" ></span>Z(e,[re.scales[e.type],re.scale])}</span>)),o}</span>function <span class="fstat-no" title="function not covered" >on(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.options||(t.options={});<span class="cstat-no" title="statement not covered" ></span>e.plugins=N(e.plugins,{}),e.scales=nn(t,e)}</span>function <span class="fstat-no" title="function not covered" >rn(</span>t){<span class="cstat-no" title="statement not covered" >return(t=t||{}).datasets=t.datasets||[],t.labels=t.labels||[],t}</span>const an=<span class="cstat-no" title="statement not covered" >new Map,</span>hn=<span class="cstat-no" title="statement not covered" >new Set;</span>function <span class="fstat-no" title="function not covered" >ln(</span>t,e){let i=<span class="cstat-no" title="statement not covered" >an.get(t);<span class="cstat-no" title="statement not covered" ></span>return i||(i=e(),an.set(t,i),hn.add(i)),i}</span>const cn=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{const s=<span class="cstat-no" title="statement not covered" >et(e,i);<span class="cstat-no" title="statement not covered" ></span>void 0!==s&amp;&amp;t.add(s)}</span>;</span>class dn{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this._config=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return(t=t||{}).data=rn(t.data),on(t),t}</span>(t),this._scopeCache=new Map,this._resolverCache=new Map}<span class="fstat-no" title="function not covered" ></span>ge</span>t platform(){<span class="cstat-no" title="statement not covered" >return this._config.platform}<span class="fstat-no" title="function not covered" ></span>ge</span>t type(){<span class="cstat-no" title="statement not covered" >return this._config.type}<span class="fstat-no" title="function not covered" ></span>se</span>t type(t){<span class="cstat-no" title="statement not covered" >this._config.type=t}<span class="fstat-no" title="function not covered" ></span>ge</span>t data(){<span class="cstat-no" title="statement not covered" >return this._config.data}<span class="fstat-no" title="function not covered" ></span>se</span>t data(t){<span class="cstat-no" title="statement not covered" >this._config.data=rn(t)}<span class="fstat-no" title="function not covered" ></span>ge</span>t options(){<span class="cstat-no" title="statement not covered" >return this._config.options}<span class="fstat-no" title="function not covered" ></span>se</span>t options(t){<span class="cstat-no" title="statement not covered" >this._config.options=t}<span class="fstat-no" title="function not covered" ></span>ge</span>t plugins(){<span class="cstat-no" title="statement not covered" >return this._config.plugins}<span class="fstat-no" title="function not covered" ></span>up</span>date(){const t=<span class="cstat-no" title="statement not covered" >this._config;<span class="cstat-no" title="statement not covered" ></span>this.clearCache(),on(t)}<span class="fstat-no" title="function not covered" ></span>cl</span>earCache(){<span class="cstat-no" title="statement not covered" >this._scopeCache.clear(),this._resolverCache.clear()}<span class="fstat-no" title="function not covered" ></span>da</span>tasetScopeKeys(t){<span class="cstat-no" title="statement not covered" >return ln(t,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[[`datasets.${t}`,""]])</span>)}<span class="fstat-no" title="function not covered" ></span>da</span>tasetAnimationScopeKeys(t,e){<span class="cstat-no" title="statement not covered" >return ln(`${t}.transition.${e}`,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[[`datasets.${t}.transitions.${e}`,`transitions.${e}`],[`datasets.${t}`,""]])</span>)}<span class="fstat-no" title="function not covered" ></span>da</span>tasetElementScopeKeys(t,e){<span class="cstat-no" title="statement not covered" >return ln(`${t}-${e}`,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[[`datasets.${t}.elements.${e}`,`datasets.${t}`,`elements.${e}`,""]])</span>)}<span class="fstat-no" title="function not covered" ></span>pl</span>uginScopeKeys(t){const e=<span class="cstat-no" title="statement not covered" >t.id;<span class="cstat-no" title="statement not covered" ></span>return ln(`${this.type}-plugin-${e}`,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[[`plugins.${e}`,...t.additionalOptionScopes||[]]])</span>)}<span class="fstat-no" title="function not covered" ></span>_c</span>achedScopes(t,e){const i=<span class="cstat-no" title="statement not covered" >this._scopeCache;</span>let s=<span class="cstat-no" title="statement not covered" >i.get(t);<span class="cstat-no" title="statement not covered" ></span>return s&amp;&amp;!e||(s=new Map,i.set(t,s)),s}<span class="fstat-no" title="function not covered" ></span>ge</span>tOptionScopes(t,e,i){const{options:s,type:n}=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >this._cachedScopes(t,i),</span>r=<span class="cstat-no" title="statement not covered" >o.get(e);<span class="cstat-no" title="statement not covered" ></span>if(r)<span class="cstat-no" title="statement not covered" >return r;c</span></span>onst a=<span class="cstat-no" title="statement not covered" >new Set;<span class="cstat-no" title="statement not covered" ></span>e.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >t&amp;&amp;(a.add(t),e.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >cn(a,t,e))</span>)),e.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >cn(a,s,t))</span>),e.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >cn(a,ee[n]||{},t))</span>),e.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >cn(a,re,t))</span>),e.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >cn(a,ie,t))</span>)}</span>));c</span>onst h=<span class="cstat-no" title="statement not covered" >Array.from(a);<span class="cstat-no" title="statement not covered" ></span>return 0===h.length&amp;&amp;h.push(Object.create(null)),hn.has(e)&amp;&amp;o.set(e,h),h}<span class="fstat-no" title="function not covered" ></span>ch</span>artOptionScopes(){const{options:t,type:e}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return[t,ee[e]||{},re.datasets[e]||{},{type:e},re,ie]}<span class="fstat-no" title="function not covered" ></span>re</span>solveNamedOptions(t,e,i,s=<span class="branch-0 cbranch-no" title="branch not covered" >[""])</span>{const n=<span class="cstat-no" title="statement not covered" >{$shared:!0},</span>{resolver:o,subPrefixes:r}=<span class="cstat-no" title="statement not covered" >un(this._resolverCache,t,s);</span>let a=<span class="cstat-no" title="statement not covered" >o;<span class="cstat-no" title="statement not covered" ></span>if(<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const{isScriptable:i,isIndexable:s}=<span class="cstat-no" title="statement not covered" >Ie(t);<span class="cstat-no" title="statement not covered" ></span>for(const n of e){const e=<span class="cstat-no" title="statement not covered" >i(n),</span>o=<span class="cstat-no" title="statement not covered" >s(n),</span>r=<span class="cstat-no" title="statement not covered" >(o||e)&amp;&amp;t[n];<span class="cstat-no" title="statement not covered" ></span>if(e&amp;&amp;(nt(r)||fn(r))||o&amp;&amp;W(r))<span class="cstat-no" title="statement not covered" >return!0}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!1}</span>(o,e)){<span class="cstat-no" title="statement not covered" >n.$shared=!1;<span class="cstat-no" title="statement not covered" >a</span>=Re(o,i=nt(i)?i():i,this.createResolver(t,i,r))}<span class="cstat-no" title="statement not covered" ></span>f</span>or(const h of e)<span class="cstat-no" title="statement not covered" >n[h]=a[h];<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}<span class="fstat-no" title="function not covered" ></span>cr</span>eateResolver(t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >[""],</span>s){const{resolver:n}=<span class="cstat-no" title="statement not covered" >un(this._resolverCache,t,i);<span class="cstat-no" title="statement not covered" ></span>return H(e)?Re(n,e,void 0,s):n}</span>}function <span class="fstat-no" title="function not covered" >un(</span>t,e,i){let s=<span class="cstat-no" title="statement not covered" >t.get(e);<span class="cstat-no" title="statement not covered" ></span>s||(s=new Map,t.set(e,s));c</span>onst n=<span class="cstat-no" title="statement not covered" >i.join();</span>let o=<span class="cstat-no" title="statement not covered" >s.get(n);<span class="cstat-no" title="statement not covered" ></span>if(!o){<span class="cstat-no" title="statement not covered" >o={resolver:Te(e,i),subPrefixes:i.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!t.toLowerCase().includes("hover"))</span>)},s.set(n,o)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o}</span>const fn=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >H(t)&amp;&amp;Object.getOwnPropertyNames(t).some((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >nt(t[e]))</span>);</span></span>const gn=<span class="cstat-no" title="statement not covered" >["top","bottom","left","right","chartArea"];</span>function <span class="fstat-no" title="function not covered" >pn(</span>t,e){<span class="cstat-no" title="statement not covered" >return"top"===t||"bottom"===t||-1===gn.indexOf(t)&amp;&amp;"x"===e}</span>function <span class="fstat-no" title="function not covered" >xn(</span>t,e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(i,s){<span class="cstat-no" title="statement not covered" >return i[t]===s[t]?i[e]-s[e]:i[t]-s[t]}</span>}</span>function <span class="fstat-no" title="function not covered" >mn(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.chart,</span>i=<span class="cstat-no" title="statement not covered" >e.options.animation;<span class="cstat-no" title="statement not covered" ></span>e.notifyPlugins("afterRender"),Y(i&amp;&amp;i.onComplete,[t],e)}</span>function <span class="fstat-no" title="function not covered" >bn(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.chart,</span>i=<span class="cstat-no" title="statement not covered" >e.options.animation;<span class="cstat-no" title="statement not covered" ></span>Y(i&amp;&amp;i.onProgress,[t],e)}</span>function <span class="fstat-no" title="function not covered" >_n(</span>t){<span class="cstat-no" title="statement not covered" >return Ge()&amp;&amp;"string"===typeof t?t=document.getElementById(t):t&amp;&amp;t.length&amp;&amp;(t=t[0]),t&amp;&amp;t.canvas&amp;&amp;(t=t.canvas),t}</span>const yn=<span class="cstat-no" title="statement not covered" >{},</span>vn=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >_n(t);<span class="cstat-no" title="statement not covered" ></span>return Object.values(yn).filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.canvas===e)</span>).pop()}</span>;</span>function <span class="fstat-no" title="function not covered" >wn(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >Object.keys(t);<span class="cstat-no" title="statement not covered" ></span>for(const n of s){const s=<span class="cstat-no" title="statement not covered" >+n;<span class="cstat-no" title="statement not covered" ></span>if(s&gt;=e){const o=<span class="cstat-no" title="statement not covered" >t[n];<span class="cstat-no" title="statement not covered" ></span>delete t[n],(i&gt;0||s&gt;e)&amp;&amp;(t[s+i]=o)}</span>}</span>}</span>class Mn{static defaults=<span class="cstat-no" title="statement not covered" >re;</span>static instances=<span class="cstat-no" title="statement not covered" >yn;</span>static overrides=<span class="cstat-no" title="statement not covered" >ee;</span>static registry=<span class="cstat-no" title="statement not covered" >Ks;</span>static version=<span class="cstat-no" title="statement not covered" >"4.5.1";</span>static getChart=<span class="cstat-no" title="statement not covered" >vn;<span class="fstat-no" title="function not covered" ></span>st</span>atic register(...t){<span class="cstat-no" title="statement not covered" >Ks.add(...t),kn()}<span class="fstat-no" title="function not covered" ></span>st</span>atic unregister(...t){<span class="cstat-no" title="statement not covered" >Ks.remove(...t),kn()}<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,e){const i=<span class="cstat-no" title="statement not covered" >this.config=new dn(e),</span>s=<span class="cstat-no" title="statement not covered" >_n(t),</span>n=<span class="cstat-no" title="statement not covered" >vn(s);<span class="cstat-no" title="statement not covered" ></span>if(n)<span class="cstat-no" title="statement not covered" >throw new Error("Canvas is already in use. Chart with ID '"+n.id+"' must be destroyed before the canvas with ID '"+n.canvas.id+"' can be reused.");c</span></span>onst o=<span class="cstat-no" title="statement not covered" >i.createResolver(i.chartOptionScopes(),this.getContext());<span class="cstat-no" title="statement not covered" ></span>this.platform=new(i.platform||<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return!Ge()||"undefined"!==typeof OffscreenCanvas&amp;&amp;t instanceof OffscreenCanvas?vs:Ls}</span>(s)),this.platform.updateConfig(i);c</span>onst r=<span class="cstat-no" title="statement not covered" >this.platform.acquireContext(s,o.aspectRatio),</span>a=<span class="cstat-no" title="statement not covered" >r&amp;&amp;r.canvas,</span>h=<span class="cstat-no" title="statement not covered" >a&amp;&amp;a.height,</span>l=<span class="cstat-no" title="statement not covered" >a&amp;&amp;a.width;<span class="cstat-no" title="statement not covered" ></span>this.id=F(),this.ctx=r,this.canvas=a,this.width=l,this.height=h,this._options=o,this._aspectRatio=this.aspectRatio,this._layers=[],this._metasets=[],this._stacks=void 0,this.boxes=[],this.currentDevicePixelRatio=void 0,this.chartArea=void 0,this._active=[],this._lastEvent=void 0,this._listeners={},this._responsiveListeners=void 0,this._sortedMetasets=[],this.scales={},this._plugins=new Js,this.$proxies={},this._hiddenIndices={},this.attached=!1,this._animationsDisabled=void 0,this.$context=void 0,this._doResize=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){let i;<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(...s){<span class="cstat-no" title="statement not covered" >return e?(clearTimeout(i),i=setTimeout(t,e,s)):t.apply(this,s),e}</span>}</span>((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this.update(t))</span>,o.resizeDelay||0),this._dataChanges=[],yn[this.id]=this,r&amp;&amp;a?(Si.listen(this,"complete",mn),Si.listen(this,"progress",bn),this._initialize(),this.attached&amp;&amp;this.update()):console.error("Failed to create chart: can't acquire context from the given item")}<span class="fstat-no" title="function not covered" ></span>ge</span>t aspectRatio(){const{options:{aspectRatio:t,maintainAspectRatio:e},width:i,height:s,_aspectRatio:n}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return B(t)?e&amp;&amp;n?n:s?i/s:null:t}<span class="fstat-no" title="function not covered" ></span>ge</span>t data(){<span class="cstat-no" title="statement not covered" >return this.config.data}<span class="fstat-no" title="function not covered" ></span>se</span>t data(t){<span class="cstat-no" title="statement not covered" >this.config.data=t}<span class="fstat-no" title="function not covered" ></span>ge</span>t options(){<span class="cstat-no" title="statement not covered" >return this._options}<span class="fstat-no" title="function not covered" ></span>se</span>t options(t){<span class="cstat-no" title="statement not covered" >this.config.options=t}<span class="fstat-no" title="function not covered" ></span>ge</span>t registry(){<span class="cstat-no" title="statement not covered" >return Ks}<span class="fstat-no" title="function not covered" ></span>_i</span>nitialize(){<span class="cstat-no" title="statement not covered" >return this.notifyPlugins("beforeInit"),this.options.responsive?this.resize():ri(this,this.options.devicePixelRatio),this.bindEvents(),this.notifyPlugins("afterInit"),this}<span class="fstat-no" title="function not covered" ></span>cl</span>ear(){<span class="cstat-no" title="statement not covered" >return le(this.canvas,this.ctx),this}<span class="fstat-no" title="function not covered" ></span>st</span>op(){<span class="cstat-no" title="statement not covered" >return Si.stop(this),this}<span class="fstat-no" title="function not covered" ></span>re</span>size(t,e){<span class="cstat-no" title="statement not covered" >Si.running(this)?this._resizeBeforeDraw={width:t,height:e}:this._resize(t,e)}<span class="fstat-no" title="function not covered" ></span>_r</span>esize(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options,</span>s=<span class="cstat-no" title="statement not covered" >this.canvas,</span>n=<span class="cstat-no" title="statement not covered" >i.maintainAspectRatio&amp;&amp;this.aspectRatio,</span>o=<span class="cstat-no" title="statement not covered" >this.platform.getMaximumSize(s,t,e,n),</span>r=<span class="cstat-no" title="statement not covered" >i.devicePixelRatio||this.platform.getDevicePixelRatio(),</span>a=<span class="cstat-no" title="statement not covered" >this.width?"resize":"attach";<span class="cstat-no" title="statement not covered" ></span>this.width=o.width,this.height=o.height,this._aspectRatio=this.aspectRatio,ri(this,r,!0)&amp;&amp;(this.notifyPlugins("resize",{size:o}),Y(i.onResize,[this,o],this),this.attached&amp;&amp;this._doResize(a)&amp;&amp;this.render())}<span class="fstat-no" title="function not covered" ></span>en</span>sureScalesHaveIDs(){<span class="cstat-no" title="statement not covered" >U(this.options.scales||{},(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >t.id=e}</span>))}<span class="fstat-no" title="function not covered" ></span>bu</span>ildOrUpdateScales(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >t.scales,</span>i=<span class="cstat-no" title="statement not covered" >this.scales,</span>s=<span class="cstat-no" title="statement not covered" >Object.keys(i).reduce((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;(<span class="cstat-no" title="statement not covered" >t[e]=!1,t)</span>),{});</span>let n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;(n=n.concat(Object.keys(e).map((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >e[t],</span>s=<span class="cstat-no" title="statement not covered" >en(t,i),</span>n=<span class="cstat-no" title="statement not covered" >"r"===s,</span>o=<span class="cstat-no" title="statement not covered" >"x"===s;<span class="cstat-no" title="statement not covered" ></span>return{options:i,dposition:n?"chartArea":o?"bottom":"left",dtype:n?"radialLinear":o?"category":"linear"}}</span>)))),U(n,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >e.options,</span>o=<span class="cstat-no" title="statement not covered" >n.id,</span>r=<span class="cstat-no" title="statement not covered" >en(o,n),</span>a=<span class="cstat-no" title="statement not covered" >N(n.type,e.dtype);<span class="cstat-no" title="statement not covered" ></span>void 0!==n.position&amp;&amp;pn(n.position,r)===pn(e.dposition)||(n.position=e.dposition),s[o]=!0;l</span>et h=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(o in i&amp;&amp;i[o].type===a)<span class="cstat-no" title="statement not covered" >h=i[o];e</span>lse{<span class="cstat-no" title="statement not covered" >h=new(Ks.getScale(a))({id:o,type:a,ctx:this.ctx,chart:this}),i[h.id]=h}<span class="cstat-no" title="statement not covered" ></span>h</span>.init(n,t)}</span>)),U(s,(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >t||delete i[e]}</span>)),U(i,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >_s.configure(this,t,t.options),_s.addBox(this,t)}</span>))}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateMetasets(){const t=<span class="cstat-no" title="statement not covered" >this._metasets,</span>e=<span class="cstat-no" title="statement not covered" >this.data.datasets.length,</span>i=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>if(t.sort((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t.index-e.index)</span>),i&gt;e){<span class="cstat-no" title="statement not covered" >for(let t=<span class="cstat-no" title="statement not covered" >e;</span>t&lt;i;++t)<span class="cstat-no" title="statement not covered" >this._destroyDatasetMeta(t);<span class="cstat-no" title="statement not covered" >t</span></span>.splice(e,i-e)}<span class="cstat-no" title="statement not covered" ></span>t</span>his._sortedMetasets=t.slice(0).sort(xn("order","index"))}<span class="fstat-no" title="function not covered" ></span>_r</span>emoveUnreferencedMetasets(){const{_metasets:t,data:{datasets:e}}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>t.length&gt;e.length&amp;&amp;delete this._stacks,t.forEach((<span class="fstat-no" title="function not covered" >(t</span>,i)=&gt;{<span class="cstat-no" title="statement not covered" >0===e.filter((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e===t._dataset)</span>).length&amp;&amp;this._destroyDatasetMeta(i)}</span>))}<span class="fstat-no" title="function not covered" ></span>bu</span>ildOrUpdateControllers(){const t=<span class="cstat-no" title="statement not covered" >[],</span>e=<span class="cstat-no" title="statement not covered" >this.data.datasets;</span>let i,s;<span class="cstat-no" title="statement not covered" >for(this._removeUnreferencedMetasets(),i=0,s=e.length;i&lt;s;i++){const s=<span class="cstat-no" title="statement not covered" >e[i];</span>let n=<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(i);</span>const o=<span class="cstat-no" title="statement not covered" >s.type||this.config.type;<span class="cstat-no" title="statement not covered" ></span>if(n.type&amp;&amp;n.type!==o&amp;&amp;(this._destroyDatasetMeta(i),n=this.getDatasetMeta(i)),n.type=o,n.indexAxis=s.indexAxis||Qs(o,this.options),n.order=s.order||0,n.index=i,n.label=""+s.label,n.visible=this.isDatasetVisible(i),n.controller)<span class="cstat-no" title="statement not covered" >n.controller.updateIndex(i),n.controller.linkScales();e</span>lse{const e=<span class="cstat-no" title="statement not covered" >Ks.getController(o),</span>{datasetElementType:s,dataElementType:r}=<span class="cstat-no" title="statement not covered" >re.datasets[o];<span class="cstat-no" title="statement not covered" ></span>Object.assign(e,{dataElementType:Ks.getElement(r),datasetElementType:s&amp;&amp;Ks.getElement(s)}),n.controller=new e(this,i),t.push(n.controller)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this._updateMetasets(),t}<span class="fstat-no" title="function not covered" ></span>_r</span>esetElements(){<span class="cstat-no" title="statement not covered" >U(this.data.datasets,(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(e).controller.reset()}</span>),this)}<span class="fstat-no" title="function not covered" ></span>re</span>set(){<span class="cstat-no" title="statement not covered" >this._resetElements(),this.notifyPlugins("reset")}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){const e=<span class="cstat-no" title="statement not covered" >this.config;<span class="cstat-no" title="statement not covered" ></span>e.update();c</span>onst i=<span class="cstat-no" title="statement not covered" >this._options=e.createResolver(e.chartOptionScopes(),this.getContext()),</span>s=<span class="cstat-no" title="statement not covered" >this._animationsDisabled=!i.animation;<span class="cstat-no" title="statement not covered" ></span>if(this._updateScales(),this._checkEventBindings(),this._updateHiddenIndices(),this._plugins.invalidate(),!1===this.notifyPlugins("beforeUpdate",{mode:t,cancelable:!0}))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >this.buildOrUpdateControllers();<span class="cstat-no" title="statement not covered" ></span>this.notifyPlugins("beforeElementsUpdate");l</span>et o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let h=<span class="cstat-no" title="statement not covered" >0,</span>l=<span class="cstat-no" title="statement not covered" >this.data.datasets.length;</span>h&lt;l;h++){const{controller:t}=<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(h),</span>e=<span class="cstat-no" title="statement not covered" >!s&amp;&amp;-1===n.indexOf(t);<span class="cstat-no" title="statement not covered" ></span>t.buildOrUpdateElements(e),o=Math.max(+t.getMaxOverflow(),o)}<span class="cstat-no" title="statement not covered" ></span>o</span>=this._minPadding=i.layout.autoPadding?o:0,this._updateLayout(o),s||U(n,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.reset()}</span>)),this._updateDatasets(t),this.notifyPlugins("afterUpdate",{mode:t}),this._layers.sort(xn("z","_idx"));c</span>onst{_active:r,_lastEvent:a}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>a?this._eventHandler(a,!0):r.length&amp;&amp;this._updateHoverStyles(r,r,!0),this.render()}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateScales(){<span class="cstat-no" title="statement not covered" >U(this.scales,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >_s.removeBox(this,t)}</span>)),this.ensureScalesHaveIDs(),this.buildOrUpdateScales()}<span class="fstat-no" title="function not covered" ></span>_c</span>heckEventBindings(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >new Set(Object.keys(this._listeners)),</span>i=<span class="cstat-no" title="statement not covered" >new Set(t.events);<span class="cstat-no" title="statement not covered" ></span>ot(e,i)&amp;&amp;!!this._responsiveListeners===t.responsive||(this.unbindEvents(),this.bindEvents())}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateHiddenIndices(){const{_hiddenIndices:t}=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >this._getUniformDataChanges()||[];<span class="cstat-no" title="statement not covered" ></span>for(const{method:i,start:s,count:n}of e){<span class="cstat-no" title="statement not covered" >wn(t,s,"_removeElements"===i?-n:n)}</span>}<span class="fstat-no" title="function not covered" ></span>_g</span>etUniformDataChanges(){const t=<span class="cstat-no" title="statement not covered" >this._dataChanges;<span class="cstat-no" title="statement not covered" ></span>if(!t||!t.length)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his._dataChanges=[];c</span>onst e=<span class="cstat-no" title="statement not covered" >this.data.datasets.length,</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >new Set(t.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t[0]===e)</span>).map((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e+","+t.splice(1).join(","))</span>)),</span></span>s=<span class="cstat-no" title="statement not covered" >i(0);<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >1;</span>n&lt;e;n++)<span class="cstat-no" title="statement not covered" >if(!ot(s,i(n)))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn Array.from(s).map((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.split(","))</span>).map((<span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >{method:t[1],start:+t[2],count:+t[3]})</span>))}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateLayout(t){<span class="cstat-no" title="statement not covered" >if(!1===this.notifyPlugins("beforeLayout",{cancelable:!0}))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >_</span></span>s.update(this,this.width,this.height,t);c</span>onst e=<span class="cstat-no" title="statement not covered" >this.chartArea,</span>i=<span class="cstat-no" title="statement not covered" >e.width&lt;=0||e.height&lt;=0;<span class="cstat-no" title="statement not covered" ></span>this._layers=[],U(this.boxes,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >i&amp;&amp;"chartArea"===t.position||(t.configure&amp;&amp;t.configure(),this._layers.push(...t._layers()))}</span>),this),this._layers.forEach((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >t._idx=e}</span>)),this.notifyPlugins("afterLayout")}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateDatasets(t){<span class="cstat-no" title="statement not covered" >if(!1!==this.notifyPlugins("beforeDatasetsUpdate",{mode:t,cancelable:!0})){<span class="cstat-no" title="statement not covered" >for(let t=<span class="cstat-no" title="statement not covered" >0,</span>e=<span class="cstat-no" title="statement not covered" >this.data.datasets.length;</span>t&lt;e;++t)<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(t).controller.configure();<span class="cstat-no" title="statement not covered" >f</span></span>or(let e=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >this.data.datasets.length;</span>e&lt;i;++e)<span class="cstat-no" title="statement not covered" >this._updateDataset(e,nt(t)?t({datasetIndex:e}):t);<span class="cstat-no" title="statement not covered" >t</span></span>his.notifyPlugins("afterDatasetsUpdate",{mode:t})}</span>}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateDataset(t,e){const i=<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(t),</span>s=<span class="cstat-no" title="statement not covered" >{meta:i,index:t,mode:e,cancelable:!0};<span class="cstat-no" title="statement not covered" ></span>!1!==this.notifyPlugins("beforeDatasetUpdate",s)&amp;&amp;(i.controller._update(e),s.cancelable=!1,this.notifyPlugins("afterDatasetUpdate",s))}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >!1!==this.notifyPlugins("beforeRender",{cancelable:!0})&amp;&amp;(Si.has(this)?this.attached&amp;&amp;!Si.running(this)&amp;&amp;Si.start(this):(this.draw(),mn({chart:this})))}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(){let t;<span class="cstat-no" title="statement not covered" >if(this._resizeBeforeDraw){const{width:t,height:e}=<span class="cstat-no" title="statement not covered" >this._resizeBeforeDraw;<span class="cstat-no" title="statement not covered" ></span>this._resizeBeforeDraw=null,this._resize(t,e)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.clear(),this.width&lt;=0||this.height&lt;=0)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(!1===this.notifyPlugins("beforeDraw",{cancelable:!0}))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this._layers;<span class="cstat-no" title="statement not covered" ></span>for(t=0;t&lt;e.length&amp;&amp;e[t].z&lt;=0;++t)<span class="cstat-no" title="statement not covered" >e[t].draw(this.chartArea);<span class="cstat-no" title="statement not covered" >f</span></span>or(this._drawDatasets();t&lt;e.length;++t)<span class="cstat-no" title="statement not covered" >e[t].draw(this.chartArea);<span class="cstat-no" title="statement not covered" >t</span></span>his.notifyPlugins("afterDraw")}<span class="fstat-no" title="function not covered" ></span>_g</span>etSortedDatasetMetas(t){const e=<span class="cstat-no" title="statement not covered" >this._sortedMetasets,</span>i=<span class="cstat-no" title="statement not covered" >[];</span>let s,n;<span class="cstat-no" title="statement not covered" >for(s=0,n=e.length;s&lt;n;++s){const n=<span class="cstat-no" title="statement not covered" >e[s];<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;!n.visible||i.push(n)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}<span class="fstat-no" title="function not covered" ></span>ge</span>tSortedVisibleDatasetMetas(){<span class="cstat-no" title="statement not covered" >return this._getSortedDatasetMetas(!0)}<span class="fstat-no" title="function not covered" ></span>_d</span>rawDatasets(){<span class="cstat-no" title="statement not covered" >if(!1===this.notifyPlugins("beforeDatasetsDraw",{cancelable:!0}))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this.getSortedVisibleDatasetMetas();<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >t.length-1;</span>e&gt;=0;--e)<span class="cstat-no" title="statement not covered" >this._drawDataset(t[e]);<span class="cstat-no" title="statement not covered" >t</span></span>his.notifyPlugins("afterDatasetsDraw")}<span class="fstat-no" title="function not covered" ></span>_d</span>rawDataset(t){const e=<span class="cstat-no" title="statement not covered" >this.ctx,</span>i=<span class="cstat-no" title="statement not covered" >{meta:t,index:t.index,cancelable:!0},</span>s=<span class="cstat-no" title="statement not covered" >Mi(this,t);<span class="cstat-no" title="statement not covered" ></span>!1!==this.notifyPlugins("beforeDatasetDraw",i)&amp;&amp;(s&amp;&amp;fe(e,s),t.controller.draw(),s&amp;&amp;ge(e),i.cancelable=!1,this.notifyPlugins("afterDatasetDraw",i))}<span class="fstat-no" title="function not covered" ></span>is</span>PointInArea(t){<span class="cstat-no" title="statement not covered" >return ue(t,this.chartArea,this._minPadding)}<span class="fstat-no" title="function not covered" ></span>ge</span>tElementsAtEventForMode(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >rs.modes[e];<span class="cstat-no" title="statement not covered" ></span>return"function"===typeof n?n(this,t,i,s):[]}<span class="fstat-no" title="function not covered" ></span>ge</span>tDatasetMeta(t){const e=<span class="cstat-no" title="statement not covered" >this.data.datasets[t],</span>i=<span class="cstat-no" title="statement not covered" >this._metasets;</span>let s=<span class="cstat-no" title="statement not covered" >i.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t&amp;&amp;t._dataset===e)</span>).pop();<span class="cstat-no" title="statement not covered" ></span>return s||(s={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null,order:e&amp;&amp;e.order||0,index:t,_dataset:e,_parsed:[],_sorted:!1},i.push(s)),s}<span class="fstat-no" title="function not covered" ></span>ge</span>tContext(){<span class="cstat-no" title="statement not covered" >return this.$context||(this.$context=Ce(null,{chart:this,type:"chart"}))}<span class="fstat-no" title="function not covered" ></span>ge</span>tVisibleDatasetCount(){<span class="cstat-no" title="statement not covered" >return this.getSortedVisibleDatasetMetas().length}<span class="fstat-no" title="function not covered" ></span>is</span>DatasetVisible(t){const e=<span class="cstat-no" title="statement not covered" >this.data.datasets[t];<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(t);<span class="cstat-no" title="statement not covered" ></span>return"boolean"===typeof i.hidden?!i.hidden:!e.hidden}<span class="fstat-no" title="function not covered" ></span>se</span>tDatasetVisibility(t,e){<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(t).hidden=!e}<span class="fstat-no" title="function not covered" ></span>to</span>ggleDataVisibility(t){<span class="cstat-no" title="statement not covered" >this._hiddenIndices[t]=!this._hiddenIndices[t]}<span class="fstat-no" title="function not covered" ></span>ge</span>tDataVisibility(t){<span class="cstat-no" title="statement not covered" >return!this._hiddenIndices[t]}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateVisibility(t,e,i){const s=<span class="cstat-no" title="statement not covered" >i?"show":"hide",</span>n=<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(t),</span>o=<span class="cstat-no" title="statement not covered" >n.controller._resolveAnimations(void 0,s);<span class="cstat-no" title="statement not covered" ></span>st(e)?(n.data[e].hidden=!i,this.update()):(this.setDatasetVisibility(t,i),o.update(n,{visible:i}),this.update((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.datasetIndex===t?s:void 0)</span>))}<span class="fstat-no" title="function not covered" ></span>hi</span>de(t,e){<span class="cstat-no" title="statement not covered" >this._updateVisibility(t,e,!1)}<span class="fstat-no" title="function not covered" ></span>sh</span>ow(t,e){<span class="cstat-no" title="statement not covered" >this._updateVisibility(t,e,!0)}<span class="fstat-no" title="function not covered" ></span>_d</span>estroyDatasetMeta(t){const e=<span class="cstat-no" title="statement not covered" >this._metasets[t];<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;e.controller&amp;&amp;e.controller._destroy(),delete this._metasets[t]}<span class="fstat-no" title="function not covered" ></span>_s</span>top(){let t,e;<span class="cstat-no" title="statement not covered" >for(this.stop(),Si.remove(this),t=0,e=this.data.datasets.length;t&lt;e;++t)<span class="cstat-no" title="statement not covered" >this._destroyDatasetMeta(t)}<span class="fstat-no" title="function not covered" ></span></span>de</span>stroy(){<span class="cstat-no" title="statement not covered" >this.notifyPlugins("beforeDestroy");c</span>onst{canvas:t,ctx:e}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this._stop(),this.config.clearCache(),t&amp;&amp;(this.unbindEvents(),le(t,e),this.platform.releaseContext(e),this.canvas=null,this.ctx=null),delete yn[this.id],this.notifyPlugins("afterDestroy")}<span class="fstat-no" title="function not covered" ></span>to</span>Base64Image(...t){<span class="cstat-no" title="statement not covered" >return this.canvas.toDataURL(...t)}<span class="fstat-no" title="function not covered" ></span>bi</span>ndEvents(){<span class="cstat-no" title="statement not covered" >this.bindUserEvents(),this.options.responsive?this.bindResponsiveEvents():this.attached=!0}<span class="fstat-no" title="function not covered" ></span>bi</span>ndUserEvents(){const t=<span class="cstat-no" title="statement not covered" >this._listeners,</span>e=<span class="cstat-no" title="statement not covered" >this.platform,</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(i</span>,s)=&gt;{<span class="cstat-no" title="statement not covered" >e.addEventListener(this,i,s),t[i]=s}</span>,</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >t.offsetX=e,t.offsetY=i,this._eventHandler(t)}</span>;<span class="cstat-no" title="statement not covered" ></span>U(this.options.events,(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >i(t,s))</span>)}<span class="fstat-no" title="function not covered" ></span>bi</span>ndResponsiveEvents(){<span class="cstat-no" title="statement not covered" >this._responsiveListeners||(this._responsiveListeners={});c</span>onst t=<span class="cstat-no" title="statement not covered" >this._responsiveListeners,</span>e=<span class="cstat-no" title="statement not covered" >this.platform,</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(i</span>,s)=&gt;{<span class="cstat-no" title="statement not covered" >e.addEventListener(this,i,s),t[i]=s}</span>,</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(i</span>,s)=&gt;{<span class="cstat-no" title="statement not covered" >t[i]&amp;&amp;(e.removeEventListener(this,i,s),delete t[i])}</span>,</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >this.canvas&amp;&amp;this.resize(t,e)}</span>;</span>let o;const r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >s("attach",r),this.attached=!0,this.resize(),i("resize",n),i("detach",o)}</span>;<span class="cstat-no" title="statement not covered" ></span>o=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.attached=!1,s("resize",n),this._stop(),this._resize(0,0),i("attach",r)}</span>,e.isAttached(this.canvas)?r():o()}<span class="fstat-no" title="function not covered" ></span>un</span>bindEvents(){<span class="cstat-no" title="statement not covered" >U(this._listeners,(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >this.platform.removeEventListener(this,e,t)}</span>)),this._listeners={},U(this._responsiveListeners,(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >this.platform.removeEventListener(this,e,t)}</span>)),this._responsiveListeners=void 0}<span class="fstat-no" title="function not covered" ></span>up</span>dateHoverStyle(t,e,i){const s=<span class="cstat-no" title="statement not covered" >i?"set":"remove";</span>let n,o,r,a;<span class="cstat-no" title="statement not covered" >for("dataset"===e&amp;&amp;(n=this.getDatasetMeta(t[0].datasetIndex),n.controller["_"+s+"DatasetHoverStyle"]()),r=0,a=t.length;r&lt;a;++r){<span class="cstat-no" title="statement not covered" >o=t[r];c</span>onst e=<span class="cstat-no" title="statement not covered" >o&amp;&amp;this.getDatasetMeta(o.datasetIndex).controller;<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;e[s+"HoverStyle"](o.element,o.datasetIndex,o.index)}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>tActiveElements(){<span class="cstat-no" title="statement not covered" >return this._active||[]}<span class="fstat-no" title="function not covered" ></span>se</span>tActiveElements(t){const e=<span class="cstat-no" title="statement not covered" >this._active||[],</span>i=<span class="cstat-no" title="statement not covered" >t.map((<span class="fstat-no" title="function not covered" >({</span>datasetIndex:t,index:e})=&gt;{const i=<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(t);<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >throw new Error("No dataset found at index "+t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{datasetIndex:t,element:i.data[e],index:e}}</span>));<span class="cstat-no" title="statement not covered" ></span>!X(i,e)&amp;&amp;(this._active=i,this._lastEvent=null,this._updateHoverStyles(i,e))}<span class="fstat-no" title="function not covered" ></span>no</span>tifyPlugins(t,e,i){<span class="cstat-no" title="statement not covered" >return this._plugins.notify(this,t,e,i)}<span class="fstat-no" title="function not covered" ></span>is</span>PluginEnabled(t){<span class="cstat-no" title="statement not covered" >return 1===this._plugins._cache.filter((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.plugin.id===t)</span>).length}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateHoverStyles(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.options.hover,</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!e.some((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >t.datasetIndex===e.datasetIndex&amp;&amp;t.index===e.index)</span>))</span>),</span></span>o=<span class="cstat-no" title="statement not covered" >n(e,t),</span>r=<span class="cstat-no" title="statement not covered" >i?t:n(t,e);<span class="cstat-no" title="statement not covered" ></span>o.length&amp;&amp;this.updateHoverStyle(o,s.mode,!1),r.length&amp;&amp;s.mode&amp;&amp;this.updateHoverStyle(r,s.mode,!0)}<span class="fstat-no" title="function not covered" ></span>_e</span>ventHandler(t,e){const i=<span class="cstat-no" title="statement not covered" >{event:t,replay:e,cancelable:!0,inChartArea:this.isPointInArea(t)},</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >(e.options.events||this.options.events).includes(t.native.type);<span class="cstat-no" title="statement not covered" ></span></span>if(!1===this.notifyPlugins("beforeEvent",i,s))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >this._handleEvent(t,e,i.inChartArea);<span class="cstat-no" title="statement not covered" ></span>return i.cancelable=!1,this.notifyPlugins("afterEvent",i,s),(n||i.changed)&amp;&amp;this.render(),this}<span class="fstat-no" title="function not covered" ></span>_h</span>andleEvent(t,e,i){const{_active:s=<span class="branch-0 cbranch-no" title="branch not covered" >[],</span>options:n}=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >e,</span>r=<span class="cstat-no" title="statement not covered" >this._getActiveElements(t,s,i,o),</span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"mouseup"===t.type||"click"===t.type||"contextmenu"===t.type}</span>(t),</span>h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){<span class="cstat-no" title="statement not covered" >return i&amp;&amp;"mouseout"!==t.type?s?e:t:null}</span>(t,this._lastEvent,i,a);<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;(this._lastEvent=null,Y(n.onHover,[t,r,this],this),a&amp;&amp;Y(n.onClick,[t,r,this],this));c</span>onst l=<span class="cstat-no" title="statement not covered" >!X(r,s);<span class="cstat-no" title="statement not covered" ></span>return(l||e)&amp;&amp;(this._active=r,this._updateHoverStyles(r,s,e)),this._lastEvent=h,l}<span class="fstat-no" title="function not covered" ></span>_g</span>etActiveElements(t,e,i,s){<span class="cstat-no" title="statement not covered" >if("mouseout"===t.type)<span class="cstat-no" title="statement not covered" >return[];<span class="cstat-no" title="statement not covered" >i</span></span>f(!i)<span class="cstat-no" title="statement not covered" >return e;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >this.options.hover;<span class="cstat-no" title="statement not covered" ></span>return this.getElementsAtEventForMode(t,n.mode,n,s)}</span>}function <span class="fstat-no" title="function not covered" >kn(</span>){<span class="cstat-no" title="statement not covered" >return U(Mn.instances,(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t._plugins.invalidate())</span>)}</span>function <span class="fstat-no" title="function not covered" >Sn(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >ke(t.options.borderRadius,["outerStart","outerEnd","innerStart","innerEnd"]);</span>const o=<span class="cstat-no" title="statement not covered" >(i-e)/2,</span>r=<span class="cstat-no" title="statement not covered" >Math.min(o,s*e/2),</span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >(i-Math.min(o,t))*s/2;<span class="cstat-no" title="statement not covered" ></span>return At(t,0,Math.min(o,e))}</span>;<span class="cstat-no" title="statement not covered" ></span>return{outerStart:a(n.outerStart),outerEnd:a(n.outerEnd),innerStart:At(n.innerStart,0,r),innerEnd:At(n.innerEnd,0,r)}}</span>function <span class="fstat-no" title="function not covered" >Pn(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return{x:i+t*Math.cos(e),y:s+t*Math.sin(e)}}</span>function <span class="fstat-no" title="function not covered" >Dn(</span>t,e,i,s,n,o){const{x:r,y:a,startAngle:h,pixelMargin:l,innerRadius:c}=<span class="cstat-no" title="statement not covered" >e,</span>d=<span class="cstat-no" title="statement not covered" >Math.max(e.outerRadius+s+i-l,0),</span>u=<span class="cstat-no" title="statement not covered" >c&gt;0?c+s+i+l:0;</span>let f=<span class="cstat-no" title="statement not covered" >0;</span>const g=<span class="cstat-no" title="statement not covered" >n-h;<span class="cstat-no" title="statement not covered" ></span>if(s){const t=<span class="cstat-no" title="statement not covered" >((c&gt;0?c-s:0)+(d&gt;0?d-s:0))/2;<span class="cstat-no" title="statement not covered" ></span>f=(g-(0!==t?g*t/(t+s):g))/2}</span>c</span>onst p=<span class="cstat-no" title="statement not covered" >(g-Math.max(.001,g*d-i/rt)/d)/2,</span>x=<span class="cstat-no" title="statement not covered" >h+p+f,</span>m=<span class="cstat-no" title="statement not covered" >n-p-f,</span>{outerStart:b,outerEnd:_,innerStart:y,innerEnd:v}=<span class="cstat-no" title="statement not covered" >Sn(e,u,d,m-x),</span>w=<span class="cstat-no" title="statement not covered" >d-b,</span>M=<span class="cstat-no" title="statement not covered" >d-_,</span>k=<span class="cstat-no" title="statement not covered" >x+b/w,</span>S=<span class="cstat-no" title="statement not covered" >m-_/M,</span>P=<span class="cstat-no" title="statement not covered" >u+y,</span>D=<span class="cstat-no" title="statement not covered" >u+v,</span>A=<span class="cstat-no" title="statement not covered" >x+y/P,</span>O=<span class="cstat-no" title="statement not covered" >m-v/D;<span class="cstat-no" title="statement not covered" ></span>if(t.beginPath(),o){const e=<span class="cstat-no" title="statement not covered" >(k+S)/2;<span class="cstat-no" title="statement not covered" ></span>if(t.arc(r,a,d,k,e),t.arc(r,a,d,e,S),_&gt;0){const e=<span class="cstat-no" title="statement not covered" >Pn(M,S,r,a);<span class="cstat-no" title="statement not covered" ></span>t.arc(e.x,e.y,_,S,m+dt)}</span>c</span>onst i=<span class="cstat-no" title="statement not covered" >Pn(D,m,r,a);<span class="cstat-no" title="statement not covered" ></span>if(t.lineTo(i.x,i.y),v&gt;0){const e=<span class="cstat-no" title="statement not covered" >Pn(D,O,r,a);<span class="cstat-no" title="statement not covered" ></span>t.arc(e.x,e.y,v,m+dt,O+Math.PI)}</span>c</span>onst s=<span class="cstat-no" title="statement not covered" >(m-v/u+(x+y/u))/2;<span class="cstat-no" title="statement not covered" ></span>if(t.arc(r,a,u,m-v/u,s,!0),t.arc(r,a,u,s,x+y/u,!0),y&gt;0){const e=<span class="cstat-no" title="statement not covered" >Pn(P,A,r,a);<span class="cstat-no" title="statement not covered" ></span>t.arc(e.x,e.y,y,A+Math.PI,x-dt)}</span>c</span>onst n=<span class="cstat-no" title="statement not covered" >Pn(w,x,r,a);<span class="cstat-no" title="statement not covered" ></span>if(t.lineTo(n.x,n.y),b&gt;0){const e=<span class="cstat-no" title="statement not covered" >Pn(w,k,r,a);<span class="cstat-no" title="statement not covered" ></span>t.arc(e.x,e.y,b,x-dt,k)}</span>}</span>else{<span class="cstat-no" title="statement not covered" >t.moveTo(r,a);c</span>onst e=<span class="cstat-no" title="statement not covered" >Math.cos(k)*d+r,</span>i=<span class="cstat-no" title="statement not covered" >Math.sin(k)*d+a;<span class="cstat-no" title="statement not covered" ></span>t.lineTo(e,i);c</span>onst s=<span class="cstat-no" title="statement not covered" >Math.cos(S)*d+r,</span>n=<span class="cstat-no" title="statement not covered" >Math.sin(S)*d+a;<span class="cstat-no" title="statement not covered" ></span>t.lineTo(s,n)}<span class="cstat-no" title="statement not covered" ></span>t</span>.closePath()}</span>function <span class="fstat-no" title="function not covered" >An(</span>t,e,i,s,n){const{fullCircles:o,startAngle:r,circumference:a,options:h}=<span class="cstat-no" title="statement not covered" >e,</span>{borderWidth:l,borderJoinStyle:c,borderDash:d,borderDashOffset:u,borderRadius:f}=<span class="cstat-no" title="statement not covered" >h,</span>g=<span class="cstat-no" title="statement not covered" >"inner"===h.borderAlign;<span class="cstat-no" title="statement not covered" ></span>if(!l)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>.setLineDash(d||[]),t.lineDashOffset=u,g?(t.lineWidth=2*l,t.lineJoin=c||"round"):(t.lineWidth=l,t.lineJoin=c||"bevel");l</span>et p=<span class="cstat-no" title="statement not covered" >e.endAngle;<span class="cstat-no" title="statement not covered" ></span>if(o){<span class="cstat-no" title="statement not covered" >Dn(t,e,i,s,p,n);<span class="cstat-no" title="statement not covered" >f</span>or(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;o;++e)<span class="cstat-no" title="statement not covered" >t.stroke();<span class="cstat-no" title="statement not covered" >i</span></span>sNaN(a)||(p=r+(a%at||at))}<span class="cstat-no" title="statement not covered" ></span>g</span>&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const{startAngle:s,pixelMargin:n,x:o,y:r,outerRadius:a,innerRadius:h}=<span class="cstat-no" title="statement not covered" >e;</span>let l=<span class="cstat-no" title="statement not covered" >n/a;<span class="cstat-no" title="statement not covered" ></span>t.beginPath(),t.arc(o,r,a,s-l,i+l),h&gt;n?(l=n/h,t.arc(o,r,h,i+l,s-l,!0)):t.arc(o,r,n,i+dt,s-dt),t.closePath(),t.clip()}</span>(t,e,p),h.selfJoin&amp;&amp;p-r&gt;=rt&amp;&amp;0===f&amp;&amp;"miter"!==c&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const{startAngle:s,x:n,y:o,outerRadius:r,innerRadius:a,options:h}=<span class="cstat-no" title="statement not covered" >e,</span>{borderWidth:l,borderJoinStyle:c}=<span class="cstat-no" title="statement not covered" >h,</span>d=<span class="cstat-no" title="statement not covered" >Math.min(l/r,Pt(s-i));<span class="cstat-no" title="statement not covered" ></span>if(t.beginPath(),t.arc(n,o,r-l/2,s+d/2,i-d/2),a&gt;0){const e=<span class="cstat-no" title="statement not covered" >Math.min(l/a,Pt(s-i));<span class="cstat-no" title="statement not covered" ></span>t.arc(n,o,a+l/2,i-e/2,s+e/2,!0)}</span>else{const e=<span class="cstat-no" title="statement not covered" >Math.min(l/2,r*Pt(s-i));<span class="cstat-no" title="statement not covered" ></span>if("round"===c)<span class="cstat-no" title="statement not covered" >t.arc(n,o,e,i-rt/2,s+rt/2,!0);e</span>lse <span class="cstat-no" title="statement not covered" >if("bevel"===c){const r=<span class="cstat-no" title="statement not covered" >2*e*e,</span>a=<span class="cstat-no" title="statement not covered" >-r*Math.cos(i+rt/2)+n,</span>h=<span class="cstat-no" title="statement not covered" >-r*Math.sin(i+rt/2)+o,</span>l=<span class="cstat-no" title="statement not covered" >r*Math.cos(s+rt/2)+n,</span>c=<span class="cstat-no" title="statement not covered" >r*Math.sin(s+rt/2)+o;<span class="cstat-no" title="statement not covered" ></span>t.lineTo(a,h),t.lineTo(l,c)}</span>}<span class="cstat-no" title="statement not covered" ></span></span>t</span>.closePath(),t.moveTo(0,0),t.rect(0,0,t.canvas.width,t.canvas.height),t.clip("evenodd")}</span>(t,e,p),o||(Dn(t,e,i,s,p,n),t.stroke())}</span>class On extends zs{static id=<span class="cstat-no" title="statement not covered" >"arc";</span>static defaults=<span class="cstat-no" title="statement not covered" >{borderAlign:"center",borderColor:"#fff",borderDash:[],borderDashOffset:0,borderJoinStyle:void 0,borderRadius:0,borderWidth:2,offset:0,spacing:0,angle:void 0,circular:!0,selfJoin:!1};</span>static defaultRoutes=<span class="cstat-no" title="statement not covered" >{backgroundColor:"backgroundColor"};</span>static descriptors=<span class="cstat-no" title="statement not covered" >{_scriptable:!0,_indexable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"borderDash"!==t}</span>;</span>circumference;endAngle;fullCircles;innerRadius;outerRadius;pixelMargin;startAngle;<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.options=void 0,this.circumference=void 0,this.startAngle=void 0,this.endAngle=void 0,this.innerRadius=void 0,this.outerRadius=void 0,this.pixelMargin=0,this.fullCircles=0,t&amp;&amp;Object.assign(this,t)}<span class="fstat-no" title="function not covered" ></span>in</span>Range(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.getProps(["x","y"],i),</span>{angle:n,distance:o}=<span class="cstat-no" title="statement not covered" >Mt(s,{x:t,y:e}),</span>{startAngle:r,endAngle:a,innerRadius:h,outerRadius:l,circumference:c}=<span class="cstat-no" title="statement not covered" >this.getProps(["startAngle","endAngle","innerRadius","outerRadius","circumference"],i),</span>d=<span class="cstat-no" title="statement not covered" >(this.options.spacing+this.options.borderWidth)/2,</span>u=<span class="cstat-no" title="statement not covered" >N(c,a-r),</span>f=<span class="cstat-no" title="statement not covered" >Dt(n,r,a)&amp;&amp;r!==a,</span>g=<span class="cstat-no" title="statement not covered" >u&gt;=at||f,</span>p=<span class="cstat-no" title="statement not covered" >Ot(o,h+d,l+d);<span class="cstat-no" title="statement not covered" ></span>return g&amp;&amp;p}<span class="fstat-no" title="function not covered" ></span>ge</span>tCenterPoint(t){const{x:e,y:i,startAngle:s,endAngle:n,innerRadius:o,outerRadius:r}=<span class="cstat-no" title="statement not covered" >this.getProps(["x","y","startAngle","endAngle","innerRadius","outerRadius"],t),</span>{offset:a,spacing:h}=<span class="cstat-no" title="statement not covered" >this.options,</span>l=<span class="cstat-no" title="statement not covered" >(s+n)/2,</span>c=<span class="cstat-no" title="statement not covered" >(o+r+h+a)/2;<span class="cstat-no" title="statement not covered" ></span>return{x:e+Math.cos(l)*c,y:i+Math.sin(l)*c}}<span class="fstat-no" title="function not covered" ></span>to</span>oltipPosition(t){<span class="cstat-no" title="statement not covered" >return this.getCenterPoint(t)}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(t){const{options:e,circumference:i}=<span class="cstat-no" title="statement not covered" >this,</span>s=<span class="cstat-no" title="statement not covered" >(e.offset||0)/4,</span>n=<span class="cstat-no" title="statement not covered" >(e.spacing||0)/2,</span>o=<span class="cstat-no" title="statement not covered" >e.circular;<span class="cstat-no" title="statement not covered" ></span>if(this.pixelMargin="inner"===e.borderAlign?.33:0,this.fullCircles=i&gt;at?Math.floor(i/at):0,0===i||this.innerRadius&lt;0||this.outerRadius&lt;0)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>.save();c</span>onst r=<span class="cstat-no" title="statement not covered" >(this.startAngle+this.endAngle)/2;<span class="cstat-no" title="statement not covered" ></span>t.translate(Math.cos(r)*s,Math.sin(r)*s);c</span>onst a=<span class="cstat-no" title="statement not covered" >s*(1-Math.sin(Math.min(rt,i||0)));<span class="cstat-no" title="statement not covered" ></span>t.fillStyle=e.backgroundColor,t.strokeStyle=e.borderColor,<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s,n){const{fullCircles:o,startAngle:r,circumference:a}=<span class="cstat-no" title="statement not covered" >e;</span>let h=<span class="cstat-no" title="statement not covered" >e.endAngle;<span class="cstat-no" title="statement not covered" ></span>if(o){<span class="cstat-no" title="statement not covered" >Dn(t,e,i,s,h,n);<span class="cstat-no" title="statement not covered" >f</span>or(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;o;++e)<span class="cstat-no" title="statement not covered" >t.fill();<span class="cstat-no" title="statement not covered" >i</span></span>sNaN(a)||(h=r+(a%at||at))}<span class="cstat-no" title="statement not covered" ></span>D</span>n(t,e,i,s,h,n),t.fill()}</span>(t,this,a,n,o),An(t,this,a,n,o),t.restore()}</span>}function <span class="fstat-no" title="function not covered" >Cn(</span>t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >e)</span>{<span class="cstat-no" title="statement not covered" >t.lineCap=N(i.borderCapStyle,e.borderCapStyle),t.setLineDash(N(i.borderDash,e.borderDash)),t.lineDashOffset=N(i.borderDashOffset,e.borderDashOffset),t.lineJoin=N(i.borderJoinStyle,e.borderJoinStyle),t.lineWidth=N(i.borderWidth,e.borderWidth),t.strokeStyle=N(i.borderColor,e.borderColor)}</span>function <span class="fstat-no" title="function not covered" >Tn(</span>t,e,i){<span class="cstat-no" title="statement not covered" >t.lineTo(i.x,i.y)}</span>function <span class="fstat-no" title="function not covered" >Rn(</span>t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const s=<span class="cstat-no" title="statement not covered" >t.length,</span>{start:n=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>end:o=<span class="branch-0 cbranch-no" title="branch not covered" >s-1}</span>=<span class="cstat-no" title="statement not covered" >i,</span>{start:r,end:a}=<span class="cstat-no" title="statement not covered" >e,</span>h=<span class="cstat-no" title="statement not covered" >Math.max(n,r),</span>l=<span class="cstat-no" title="statement not covered" >Math.min(o,a),</span>c=<span class="cstat-no" title="statement not covered" >n&lt;r&amp;&amp;o&lt;r||n&gt;a&amp;&amp;o&gt;a;<span class="cstat-no" title="statement not covered" ></span>return{count:s,start:h,loop:e.loop,ilen:l&lt;h&amp;&amp;!c?s+l-h:l-h}}</span>function <span class="fstat-no" title="function not covered" >In(</span>t,e,i,s){const{points:n,options:o}=<span class="cstat-no" title="statement not covered" >e,</span>{count:r,start:a,loop:h,ilen:l}=<span class="cstat-no" title="statement not covered" >Rn(n,i,s),</span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.stepped?pe:t.tension||"monotone"===t.cubicInterpolationMode?xe:Tn}</span>(o);</span>let d,u,f,{move:g=<span class="branch-0 cbranch-no" title="branch not covered" >!0,</span>reverse:p}=<span class="cstat-no" title="statement not covered" >s||{};<span class="cstat-no" title="statement not covered" ></span>for(d=0;d&lt;=l;++d)<span class="cstat-no" title="statement not covered" >u=n[(a+(p?l-d:d))%r],u.skip||(g?(t.moveTo(u.x,u.y),g=!1):c(t,f,u,p,o.stepped),f=u);<span class="cstat-no" title="statement not covered" >r</span></span>eturn h&amp;&amp;(u=n[(a+(p?l:0))%r],c(t,f,u,p,o.stepped)),!!h}</span>function <span class="fstat-no" title="function not covered" >En(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >e.points,</span>{count:o,start:r,ilen:a}=<span class="cstat-no" title="statement not covered" >Rn(n,i,s),</span>{move:h=<span class="branch-0 cbranch-no" title="branch not covered" >!0,</span>reverse:l}=<span class="cstat-no" title="statement not covered" >s||{};</span>let c,d,u,f,g,p,x=<span class="cstat-no" title="statement not covered" >0,</span>m=<span class="cstat-no" title="statement not covered" >0;</span>const b=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(r+(l?a-t:t))%o,</span></span>_=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >f!==g&amp;&amp;(t.lineTo(x,g),t.lineTo(x,f),t.lineTo(x,p))}</span>;<span class="cstat-no" title="statement not covered" ></span>for(h&amp;&amp;(d=n[b(0)],t.moveTo(d.x,d.y)),c=0;c&lt;=a;++c){<span class="cstat-no" title="statement not covered" >if(d=n[b(c)],d.skip)<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >d.x,</span>i=<span class="cstat-no" title="statement not covered" >d.y,</span>s=<span class="cstat-no" title="statement not covered" >0|e;<span class="cstat-no" title="statement not covered" ></span>s===u?(i&lt;f?f=i:i&gt;g&amp;&amp;(g=i),x=(m*x+e)/++m):(_(),t.lineTo(e,i),u=s,m=0,f=g=i),p=i}<span class="cstat-no" title="statement not covered" ></span>_</span>()}</span>function <span class="fstat-no" title="function not covered" >Ln(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.options,</span>i=<span class="cstat-no" title="statement not covered" >e.borderDash&amp;&amp;e.borderDash.length;<span class="cstat-no" title="statement not covered" ></span>return!t._decimated&amp;&amp;!t._loop&amp;&amp;!e.tension&amp;&amp;"monotone"!==e.cubicInterpolationMode&amp;&amp;!e.stepped&amp;&amp;!i?En:In}</span>const zn=<span class="cstat-no" title="statement not covered" >"function"===typeof Path2D;</span>function <span class="fstat-no" title="function not covered" >Fn(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >zn&amp;&amp;!e.options.segment?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){let n=<span class="cstat-no" title="statement not covered" >e._path;<span class="cstat-no" title="statement not covered" ></span>n||(n=e._path=new Path2D,e.path(n,i,s)&amp;&amp;n.closePath()),Cn(t,e.options),t.stroke(n)}</span>(t,e,i,s):<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const{segments:n,options:o}=<span class="cstat-no" title="statement not covered" >e,</span>r=<span class="cstat-no" title="statement not covered" >Ln(e);<span class="cstat-no" title="statement not covered" ></span>for(const a of n)<span class="cstat-no" title="statement not covered" >Cn(t,o,a.style),t.beginPath(),r(t,e,a,{start:i,end:i+s-1})&amp;&amp;t.closePath(),t.stroke()}</span></span>(t,e,i,s)}</span>class Bn extends zs{static id=<span class="cstat-no" title="statement not covered" >"line";</span>static defaults=<span class="cstat-no" title="statement not covered" >{borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",borderWidth:3,capBezierPoints:!0,cubicInterpolationMode:"default",fill:!1,spanGaps:!1,stepped:!1,tension:0};</span>static defaultRoutes=<span class="cstat-no" title="statement not covered" >{backgroundColor:"backgroundColor",borderColor:"borderColor"};</span>static descriptors=<span class="cstat-no" title="statement not covered" >{_scriptable:!0,_indexable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"borderDash"!==t&amp;&amp;"fill"!==t}</span>;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.animated=!0,this.options=void 0,this._chart=void 0,this._loop=void 0,this._fullLoop=void 0,this._path=void 0,this._points=void 0,this._segments=void 0,this._decimated=!1,this._pointsUpdated=!1,this._datasetIndex=void 0,t&amp;&amp;Object.assign(this,t)}<span class="fstat-no" title="function not covered" ></span>up</span>dateControlPoints(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if((i.tension||"monotone"===i.cubicInterpolationMode)&amp;&amp;!i.stepped&amp;&amp;!this._pointsUpdated){const s=<span class="cstat-no" title="statement not covered" >i.spanGaps?this._loop:this._fullLoop;<span class="cstat-no" title="statement not covered" ></span>Je(this._points,i,t,s,e),this._pointsUpdated=!0}</span>}<span class="fstat-no" title="function not covered" ></span>se</span>t points(t){<span class="cstat-no" title="statement not covered" >this._points=t,delete this._segments,delete this._path,this._pointsUpdated=!1}<span class="fstat-no" title="function not covered" ></span>ge</span>t points(){<span class="cstat-no" title="statement not covered" >return this._points}<span class="fstat-no" title="function not covered" ></span>ge</span>t segments(){<span class="cstat-no" title="statement not covered" >return this._segments||(this._segments=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >t.points,</span>s=<span class="cstat-no" title="statement not covered" >t.options.spanGaps,</span>n=<span class="cstat-no" title="statement not covered" >i.length;<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >return[];c</span></span>onst o=<span class="cstat-no" title="statement not covered" >!!t._loop,</span>{start:r,end:a}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){let n=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >e-1;<span class="cstat-no" title="statement not covered" ></span>if(i&amp;&amp;!s)<span class="cstat-no" title="statement not covered" >for(;n&lt;e&amp;&amp;!t[n].skip;)<span class="cstat-no" title="statement not covered" >n++;<span class="cstat-no" title="statement not covered" >f</span></span></span>or(;n&lt;e&amp;&amp;t[n].skip;)<span class="cstat-no" title="statement not covered" >n++;<span class="cstat-no" title="statement not covered" >f</span></span>or(n%=e,i&amp;&amp;(o+=n);o&gt;n&amp;&amp;t[o%e].skip;)<span class="cstat-no" title="statement not covered" >o--;<span class="cstat-no" title="statement not covered" >r</span></span>eturn o%=e,{start:n,end:o}}</span>(i,n,o,s);<span class="cstat-no" title="statement not covered" ></span>return _i(t,!0===s?[{start:r,end:a,loop:o}]:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >t.length,</span>o=<span class="cstat-no" title="statement not covered" >[];</span>let r,a=<span class="cstat-no" title="statement not covered" >e,</span>h=<span class="cstat-no" title="statement not covered" >t[e];<span class="cstat-no" title="statement not covered" ></span>for(r=e+1;r&lt;=i;++r){const i=<span class="cstat-no" title="statement not covered" >t[r%n];<span class="cstat-no" title="statement not covered" ></span>i.skip||i.stop?h.skip||(s=!1,o.push({start:e%n,end:(r-1)%n,loop:s}),e=a=i.stop?r:null):(a=r,h.skip&amp;&amp;(e=r)),h=i}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null!==a&amp;&amp;o.push({start:e%n,end:a%n,loop:s}),o}</span>(i,r,a&lt;r?a+n:a,!!t._fullLoop&amp;&amp;0===r&amp;&amp;a===n-1),i,e)}</span>(this,this.options.segment))}<span class="fstat-no" title="function not covered" ></span>fi</span>rst(){const t=<span class="cstat-no" title="statement not covered" >this.segments,</span>e=<span class="cstat-no" title="statement not covered" >this.points;<span class="cstat-no" title="statement not covered" ></span>return t.length&amp;&amp;e[t[0].start]}<span class="fstat-no" title="function not covered" ></span>la</span>st(){const t=<span class="cstat-no" title="statement not covered" >this.segments,</span>e=<span class="cstat-no" title="statement not covered" >this.points,</span>i=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;e[t[i-1].end]}<span class="fstat-no" title="function not covered" ></span>in</span>terpolate(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options,</span>s=<span class="cstat-no" title="statement not covered" >t[e],</span>n=<span class="cstat-no" title="statement not covered" >this.points,</span>o=<span class="cstat-no" title="statement not covered" >bi(this,{property:e,start:s,end:s});<span class="cstat-no" title="statement not covered" ></span>if(!o.length)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.stepped?ci:t.tension||"monotone"===t.cubicInterpolationMode?di:li}</span>(i);</span>let h,l;<span class="cstat-no" title="statement not covered" >for(h=0,l=o.length;h&lt;l;++h){const{start:l,end:c}=<span class="cstat-no" title="statement not covered" >o[h],</span>d=<span class="cstat-no" title="statement not covered" >n[l],</span>u=<span class="cstat-no" title="statement not covered" >n[c];<span class="cstat-no" title="statement not covered" ></span>if(d===u){<span class="cstat-no" title="statement not covered" >r.push(d);<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>c</span>onst f=<span class="cstat-no" title="statement not covered" >a(d,u,Math.abs((s-d[e])/(u[e]-d[e])),i.stepped);<span class="cstat-no" title="statement not covered" ></span>f[e]=t[e],r.push(f)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn 1===r.length?r[0]:r}<span class="fstat-no" title="function not covered" ></span>pa</span>thSegment(t,e,i){<span class="cstat-no" title="statement not covered" >return Ln(this)(t,this,e,i)}<span class="fstat-no" title="function not covered" ></span>pa</span>th(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.segments,</span>n=<span class="cstat-no" title="statement not covered" >Ln(this);</span>let o=<span class="cstat-no" title="statement not covered" >this._loop;<span class="cstat-no" title="statement not covered" ></span>e=e||0,i=i||this.points.length-e;<span class="cstat-no" title="statement not covered" >f</span>or(const r of s)<span class="cstat-no" title="statement not covered" >o&amp;=n(t,this,r,{start:e,end:e+i-1});<span class="cstat-no" title="statement not covered" >r</span></span>eturn!!o}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >this.options||{};<span class="cstat-no" title="statement not covered" ></span>(this.points||[]).length&amp;&amp;n.borderWidth&amp;&amp;(t.save(),Fn(t,this,i,s),t.restore()),this.animated&amp;&amp;(this._pointsUpdated=!1,this._path=void 0)}</span>}function <span class="fstat-no" title="function not covered" >Wn(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >t.options,</span>{[i]:o}=<span class="cstat-no" title="statement not covered" >t.getProps([i],s);<span class="cstat-no" title="statement not covered" ></span>return Math.abs(e-o)&lt;n.radius+n.hitRadius}</span>class Hn extends zs{static id=<span class="cstat-no" title="statement not covered" >"point";</span>parsed;skip;stop;static defaults=<span class="cstat-no" title="statement not covered" >{borderWidth:1,hitRadius:1,hoverBorderWidth:1,hoverRadius:4,pointStyle:"circle",radius:3,rotation:0};</span>static defaultRoutes=<span class="cstat-no" title="statement not covered" >{backgroundColor:"backgroundColor",borderColor:"borderColor"};<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.options=void 0,this.parsed=void 0,this.skip=void 0,this.stop=void 0,t&amp;&amp;Object.assign(this,t)}<span class="fstat-no" title="function not covered" ></span>in</span>Range(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.options,</span>{x:n,y:o}=<span class="cstat-no" title="statement not covered" >this.getProps(["x","y"],i);<span class="cstat-no" title="statement not covered" ></span>return Math.pow(t-n,2)+Math.pow(e-o,2)&lt;Math.pow(s.hitRadius+s.radius,2)}<span class="fstat-no" title="function not covered" ></span>in</span>XRange(t,e){<span class="cstat-no" title="statement not covered" >return Wn(this,t,"x",e)}<span class="fstat-no" title="function not covered" ></span>in</span>YRange(t,e){<span class="cstat-no" title="statement not covered" >return Wn(this,t,"y",e)}<span class="fstat-no" title="function not covered" ></span>ge</span>tCenterPoint(t){const{x:e,y:i}=<span class="cstat-no" title="statement not covered" >this.getProps(["x","y"],t);<span class="cstat-no" title="statement not covered" ></span>return{x:e,y:i}}<span class="fstat-no" title="function not covered" ></span>si</span>ze(t){let e=<span class="cstat-no" title="statement not covered" >(t=t||this.options||{}).radius||0;<span class="cstat-no" title="statement not covered" ></span>e=Math.max(e,e&amp;&amp;t.hoverRadius||0);<span class="cstat-no" title="statement not covered" >r</span>eturn 2*(e+(e&amp;&amp;t.borderWidth||0))}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>this.skip||i.radius&lt;.1||!ue(this,e,this.size(i)/2)||(t.strokeStyle=i.borderColor,t.lineWidth=i.borderWidth,t.fillStyle=i.backgroundColor,ce(t,i,this.x,this.y))}<span class="fstat-no" title="function not covered" ></span>ge</span>tRange(){const t=<span class="cstat-no" title="statement not covered" >this.options||{};<span class="cstat-no" title="statement not covered" ></span>return t.radius+t.hitRadius}</span>}function <span class="fstat-no" title="function not covered" >Vn(</span>t,e){const{x:i,y:s,base:n,width:o,height:r}=<span class="cstat-no" title="statement not covered" >t.getProps(["x","y","base","width","height"],e);</span>let a,h,l,c,d;<span class="cstat-no" title="statement not covered" >return t.horizontal?(d=r/2,a=Math.min(i,n),h=Math.max(i,n),l=s-d,c=s+d):(d=o/2,a=i-d,h=i+d,l=Math.min(s,n),c=Math.max(s,n)),{left:a,top:l,right:h,bottom:c}}</span>function <span class="fstat-no" title="function not covered" >jn(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return t?0:At(e,i,s)}</span>function <span class="fstat-no" title="function not covered" >Nn(</span>t){const e=<span class="cstat-no" title="statement not covered" >Vn(t),</span>i=<span class="cstat-no" title="statement not covered" >e.right-e.left,</span>s=<span class="cstat-no" title="statement not covered" >e.bottom-e.top,</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.options.borderWidth,</span>n=<span class="cstat-no" title="statement not covered" >t.borderSkipped,</span>o=<span class="cstat-no" title="statement not covered" >Se(s);<span class="cstat-no" title="statement not covered" ></span>return{t:jn(n.top,o.top,0,i),r:jn(n.right,o.right,0,e),b:jn(n.bottom,o.bottom,0,i),l:jn(n.left,o.left,0,e)}}</span>(t,i/2,s/2),</span>o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const{enableBorderRadius:s}=<span class="cstat-no" title="statement not covered" >t.getProps(["enableBorderRadius"]),</span>n=<span class="cstat-no" title="statement not covered" >t.options.borderRadius,</span>o=<span class="cstat-no" title="statement not covered" >Pe(n),</span>r=<span class="cstat-no" title="statement not covered" >Math.min(e,i),</span>a=<span class="cstat-no" title="statement not covered" >t.borderSkipped,</span>h=<span class="cstat-no" title="statement not covered" >s||H(n);<span class="cstat-no" title="statement not covered" ></span>return{topLeft:jn(!h||a.top||a.left,o.topLeft,0,r),topRight:jn(!h||a.top||a.right,o.topRight,0,r),bottomLeft:jn(!h||a.bottom||a.left,o.bottomLeft,0,r),bottomRight:jn(!h||a.bottom||a.right,o.bottomRight,0,r)}}</span>(t,i/2,s/2);<span class="cstat-no" title="statement not covered" ></span>return{outer:{x:e.left,y:e.top,w:i,h:s,radius:o},inner:{x:e.left+n.l,y:e.top+n.t,w:i-n.l-n.r,h:s-n.t-n.b,radius:{topLeft:Math.max(0,o.topLeft-Math.max(n.t,n.l)),topRight:Math.max(0,o.topRight-Math.max(n.t,n.r)),bottomLeft:Math.max(0,o.bottomLeft-Math.max(n.b,n.l)),bottomRight:Math.max(0,o.bottomRight-Math.max(n.b,n.r))}}}}</span>function <span class="fstat-no" title="function not covered" >$n(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >null===e,</span>o=<span class="cstat-no" title="statement not covered" >null===i,</span>r=<span class="cstat-no" title="statement not covered" >t&amp;&amp;!(n&amp;&amp;o)&amp;&amp;Vn(t,s);<span class="cstat-no" title="statement not covered" ></span>return r&amp;&amp;(n||Ot(e,r.left,r.right))&amp;&amp;(o||Ot(i,r.top,r.bottom))}</span>function <span class="fstat-no" title="function not covered" >Yn(</span>t,e){<span class="cstat-no" title="statement not covered" >t.rect(e.x,e.y,e.w,e.h)}</span>function <span class="fstat-no" title="function not covered" >Un(</span>t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const s=<span class="cstat-no" title="statement not covered" >t.x!==i.x?-e:0,</span>n=<span class="cstat-no" title="statement not covered" >t.y!==i.y?-e:0,</span>o=<span class="cstat-no" title="statement not covered" >(t.x+t.w!==i.x+i.w?e:0)-s,</span>r=<span class="cstat-no" title="statement not covered" >(t.y+t.h!==i.y+i.h?e:0)-n;<span class="cstat-no" title="statement not covered" ></span>return{x:t.x+s,y:t.y+n,w:t.w+o,h:t.h+r,radius:t.radius}}</span>class Xn extends zs{static id=<span class="cstat-no" title="statement not covered" >"bar";</span>static defaults=<span class="cstat-no" title="statement not covered" >{borderSkipped:"start",borderWidth:0,borderRadius:0,inflateAmount:"auto",pointStyle:void 0};</span>static defaultRoutes=<span class="cstat-no" title="statement not covered" >{backgroundColor:"backgroundColor",borderColor:"borderColor"};<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.options=void 0,this.horizontal=void 0,this.base=void 0,this.width=void 0,this.height=void 0,this.inflateAmount=void 0,t&amp;&amp;Object.assign(this,t)}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(t){const{inflateAmount:e,options:{borderColor:i,backgroundColor:s}}=<span class="cstat-no" title="statement not covered" >this,</span>{inner:n,outer:o}=<span class="cstat-no" title="statement not covered" >Nn(this),</span>r=<span class="cstat-no" title="statement not covered" >(a=o.radius).topLeft||a.topRight||a.bottomLeft||a.bottomRight?ye:Yn;</span>var a;<span class="cstat-no" title="statement not covered" >t.save(),o.w===n.w&amp;&amp;o.h===n.h||(t.beginPath(),r(t,Un(o,e,n)),t.clip(),r(t,Un(n,-e,o)),t.fillStyle=i,t.fill("evenodd")),t.beginPath(),r(t,Un(n,e)),t.fillStyle=s,t.fill(),t.restore()}<span class="fstat-no" title="function not covered" ></span>in</span>Range(t,e,i){<span class="cstat-no" title="statement not covered" >return $n(this,t,e,i)}<span class="fstat-no" title="function not covered" ></span>in</span>XRange(t,e){<span class="cstat-no" title="statement not covered" >return $n(this,t,null,e)}<span class="fstat-no" title="function not covered" ></span>in</span>YRange(t,e){<span class="cstat-no" title="statement not covered" >return $n(this,null,t,e)}<span class="fstat-no" title="function not covered" ></span>ge</span>tCenterPoint(t){const{x:e,y:i,base:s,horizontal:n}=<span class="cstat-no" title="statement not covered" >this.getProps(["x","y","base","horizontal"],t);<span class="cstat-no" title="statement not covered" ></span>return{x:n?(e+s)/2:e,y:n?i:(i+s)/2}}<span class="fstat-no" title="function not covered" ></span>ge</span>tRange(t){<span class="cstat-no" title="statement not covered" >return"x"===t?this.width/2:this.height/2}</span>}function <span class="fstat-no" title="function not covered" >qn(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >if(s)<span class="cstat-no" title="statement not covered" >return;l</span></span>et n=<span class="cstat-no" title="statement not covered" >e[t],</span>o=<span class="cstat-no" title="statement not covered" >i[t];<span class="cstat-no" title="statement not covered" ></span>return"angle"===t&amp;&amp;(n=Pt(n),o=Pt(o)),{property:t,start:n,end:o}}</span>function <span class="fstat-no" title="function not covered" >Kn(</span>t,e,i){<span class="cstat-no" title="statement not covered" >for(;e&gt;t;e--){const t=<span class="cstat-no" title="statement not covered" >i[e];<span class="cstat-no" title="statement not covered" ></span>if(!isNaN(t.x)&amp;&amp;!isNaN(t.y))<span class="cstat-no" title="statement not covered" >break}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn e}</span>function <span class="fstat-no" title="function not covered" >Jn(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;e?s(t[i],e[i]):t?t[i]:e?e[i]:0}</span>function <span class="fstat-no" title="function not covered" >Gn(</span>t,e){let i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return W(t)?(s=!0,i=t):i=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const{x:i=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>y:s=<span class="branch-0 cbranch-no" title="branch not covered" >null}</span>=<span class="cstat-no" title="statement not covered" >t||{},</span>n=<span class="cstat-no" title="statement not covered" >e.points,</span>o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return e.segments.forEach((<span class="fstat-no" title="function not covered" >({</span>start:t,end:e})=&gt;{<span class="cstat-no" title="statement not covered" >e=Kn(t,e,n);c</span>onst r=<span class="cstat-no" title="statement not covered" >n[t],</span>a=<span class="cstat-no" title="statement not covered" >n[e];<span class="cstat-no" title="statement not covered" ></span>null!==s?(o.push({x:r.x,y:s}),o.push({x:a.x,y:s})):null!==i&amp;&amp;(o.push({x:i,y:r.y}),o.push({x:i,y:a.y}))}</span>)),o}</span>(t,e),i.length?new Bn({points:i,options:{tension:0},_loop:s,_fullLoop:s}):null}</span>function <span class="fstat-no" title="function not covered" >Zn(</span>t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;!1!==t.fill}</span>function <span class="fstat-no" title="function not covered" >Qn(</span>t,e,i){let s=<span class="cstat-no" title="statement not covered" >t[e].fill;</span>const n=<span class="cstat-no" title="statement not covered" >[e];</span>let o;<span class="cstat-no" title="statement not covered" >if(!i)<span class="cstat-no" title="statement not covered" >return s;<span class="cstat-no" title="statement not covered" >f</span></span>or(;!1!==s&amp;&amp;-1===n.indexOf(s);){<span class="cstat-no" title="statement not covered" >if(!V(s))<span class="cstat-no" title="statement not covered" >return s;<span class="cstat-no" title="statement not covered" >i</span></span>f(o=t[s],!o)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(o.visible)<span class="cstat-no" title="statement not covered" >return s;<span class="cstat-no" title="statement not covered" >n</span></span>.push(s),s=o.fill}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>function <span class="fstat-no" title="function not covered" >to(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >t.options,</span>i=<span class="cstat-no" title="statement not covered" >e.fill;</span>let s=<span class="cstat-no" title="statement not covered" >N(i&amp;&amp;i.target,i);<span class="cstat-no" title="statement not covered" ></span>void 0===s&amp;&amp;(s=!!e.backgroundColor);<span class="cstat-no" title="statement not covered" >i</span>f(!1===s||null===s)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(!0===s)<span class="cstat-no" title="statement not covered" >return"origin";<span class="cstat-no" title="statement not covered" >r</span></span>eturn s}</span>(t);<span class="cstat-no" title="statement not covered" ></span>if(H(s))<span class="cstat-no" title="statement not covered" >return!isNaN(s.value)&amp;&amp;s;l</span></span>et n=<span class="cstat-no" title="statement not covered" >parseFloat(s);<span class="cstat-no" title="statement not covered" ></span>return V(n)&amp;&amp;Math.floor(n)===n?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){<span class="cstat-no" title="statement not covered" >"-"!==t&amp;&amp;"+"!==t||(i=e+i);<span class="cstat-no" title="statement not covered" >i</span>f(i===e||i&lt;0||i&gt;=s)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>(s[0],e,n,i):["origin","start","end","stack","shape"].indexOf(s)&gt;=0&amp;&amp;s}</span>function <span class="fstat-no" title="function not covered" >eo(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;i.length;n++){const o=<span class="cstat-no" title="statement not covered" >i[n],</span>{first:r,last:a,point:h}=<span class="cstat-no" title="statement not covered" >io(o,e,"x");<span class="cstat-no" title="statement not covered" ></span>if(!(!h||r&amp;&amp;a))<span class="cstat-no" title="statement not covered" >if(r)<span class="cstat-no" title="statement not covered" >s.unshift(h);e</span>lse <span class="cstat-no" title="statement not covered" >if(t.push(h),!a)<span class="cstat-no" title="statement not covered" >break}<span class="cstat-no" title="statement not covered" ></span></span></span></span>t</span>.push(...s)}</span>function <span class="fstat-no" title="function not covered" >io(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.interpolate(e,i);<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return{};c</span></span>onst n=<span class="cstat-no" title="statement not covered" >s[i],</span>o=<span class="cstat-no" title="statement not covered" >t.segments,</span>r=<span class="cstat-no" title="statement not covered" >t.points;</span>let a=<span class="cstat-no" title="statement not covered" >!1,</span>h=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>for(let l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;o.length;l++){const t=<span class="cstat-no" title="statement not covered" >o[l],</span>e=<span class="cstat-no" title="statement not covered" >r[t.start][i],</span>s=<span class="cstat-no" title="statement not covered" >r[t.end][i];<span class="cstat-no" title="statement not covered" ></span>if(Ot(n,e,s)){<span class="cstat-no" title="statement not covered" >a=n===e,h=n===s;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{first:a,last:h,point:s}}</span>class so{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.x=t.x,this.y=t.y,this.radius=t.radius}<span class="fstat-no" title="function not covered" ></span>pa</span>thSegment(t,e,i){const{x:s,y:n,radius:o}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return e=e||{start:0,end:at},t.arc(s,n,o,e.end,e.start,!0),!i.bounds}<span class="fstat-no" title="function not covered" ></span>in</span>terpolate(t){const{x:e,y:i,radius:s}=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >t.angle;<span class="cstat-no" title="statement not covered" ></span>return{x:e+Math.cos(n)*s,y:i+Math.sin(n)*s,angle:n}}</span>}function <span class="fstat-no" title="function not covered" >no(</span>t){const{chart:e,fill:i,line:s}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if(V(i))<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >t.getDatasetMeta(e);<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;t.isDatasetVisible(e)?i.dataset:null}</span>(e,i);<span class="cstat-no" title="statement not covered" >i</span></span>f("stack"===i)<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t){const{scale:e,index:i,line:s}=<span class="cstat-no" title="statement not covered" >t,</span>n=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >s.segments,</span>r=<span class="cstat-no" title="statement not covered" >s.points,</span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >t.getMatchingVisibleMetas("line");<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;s.length;n++){const t=<span class="cstat-no" title="statement not covered" >s[n];<span class="cstat-no" title="statement not covered" ></span>if(t.index===e)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >t</span></span>.hidden||i.unshift(t.dataset)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>(e,i);<span class="cstat-no" title="statement not covered" ></span>a.push(Gn({x:null,y:e.bottom},s));<span class="cstat-no" title="statement not covered" >f</span>or(let h=<span class="cstat-no" title="statement not covered" >0;</span>h&lt;o.length;h++){const t=<span class="cstat-no" title="statement not covered" >o[h];<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >t.start;</span>e&lt;=t.end;e++)<span class="cstat-no" title="statement not covered" >eo(n,r[e],a)}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn new Bn({points:n,options:{}})}</span>(t);<span class="cstat-no" title="statement not covered" >i</span></span>f("shape"===i)<span class="cstat-no" title="statement not covered" >return!0;c</span></span>onst n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if((t.scale||{}).getPointPositionForValue)<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t){const{scale:e,fill:i}=<span class="cstat-no" title="statement not covered" >t,</span>s=<span class="cstat-no" title="statement not covered" >e.options,</span>n=<span class="cstat-no" title="statement not covered" >e.getLabels().length,</span>o=<span class="cstat-no" title="statement not covered" >s.reverse?e.max:e.min,</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){let s;<span class="cstat-no" title="statement not covered" >return s="start"===t?i:"end"===t?e.options.reverse?e.min:e.max:H(t)?t.value:e.getBaseValue(),s}</span>(i,e,o),</span>a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(s.grid.circular){const t=<span class="cstat-no" title="statement not covered" >e.getPointPositionForValue(0,o);<span class="cstat-no" title="statement not covered" ></span>return new so({x:t.x,y:t.y,radius:e.getDistanceFromCenterForValue(r)})}<span class="cstat-no" title="statement not covered" ></span>f</span>or(let h=<span class="cstat-no" title="statement not covered" >0;</span>h&lt;n;++h)<span class="cstat-no" title="statement not covered" >a.push(e.getPointPositionForValue(h,r));<span class="cstat-no" title="statement not covered" >r</span></span>eturn a}</span>(t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn <span class="fstat-no" title="function not covered" >fu</span>nction(t){const{scale:e=<span class="branch-0 cbranch-no" title="branch not covered" >{},</span>fill:i}=<span class="cstat-no" title="statement not covered" >t,</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){let i=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>return"start"===t?i=e.bottom:"end"===t?i=e.top:H(t)?i=e.getPixelForValue(t.value):e.getBasePixel&amp;&amp;(i=e.getBasePixel()),i}</span>(i,e);<span class="cstat-no" title="statement not covered" ></span>if(V(s)){const t=<span class="cstat-no" title="statement not covered" >e.isHorizontal();<span class="cstat-no" title="statement not covered" ></span>return{x:t?s:null,y:t?null:s}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null}</span>(t)}</span>(t);<span class="cstat-no" title="statement not covered" ></span>return n instanceof so?n:Gn(n,s)}</span>function <span class="fstat-no" title="function not covered" >oo(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >no(e),</span>{chart:n,index:o,line:r,scale:a,axis:h}=<span class="cstat-no" title="statement not covered" >e,</span>l=<span class="cstat-no" title="statement not covered" >r.options,</span>c=<span class="cstat-no" title="statement not covered" >l.fill,</span>d=<span class="cstat-no" title="statement not covered" >l.backgroundColor,</span>{above:u=<span class="branch-0 cbranch-no" title="branch not covered" >d,</span>below:f=<span class="branch-0 cbranch-no" title="branch not covered" >d}</span>=<span class="cstat-no" title="statement not covered" >c||{},</span>g=<span class="cstat-no" title="statement not covered" >n.getDatasetMeta(o),</span>p=<span class="cstat-no" title="statement not covered" >Mi(n,g);<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;r.points.length&amp;&amp;(fe(t,i),<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const{line:i,target:s,above:n,below:o,area:r,scale:a,clip:h}=<span class="cstat-no" title="statement not covered" >e,</span>l=<span class="cstat-no" title="statement not covered" >i._loop?"angle":e.axis;<span class="cstat-no" title="statement not covered" ></span>t.save();l</span>et c=<span class="cstat-no" title="statement not covered" >o;<span class="cstat-no" title="statement not covered" ></span>o!==n&amp;&amp;("x"===l?(ro(t,s,r.top),ho(t,{line:i,target:s,color:n,scale:a,property:l,clip:h}),t.restore(),t.save(),ro(t,s,r.bottom)):"y"===l&amp;&amp;(ao(t,s,r.left),ho(t,{line:i,target:s,color:o,scale:a,property:l,clip:h}),t.restore(),t.save(),ao(t,s,r.right),c=n));<span class="cstat-no" title="statement not covered" >h</span>o(t,{line:i,target:s,color:c,scale:a,property:l,clip:h}),t.restore()}</span>(t,{line:r,target:s,above:u,below:f,area:i,scale:a,axis:h,clip:p}),ge(t))}</span>function <span class="fstat-no" title="function not covered" >ro(</span>t,e,i){const{segments:s,points:n}=<span class="cstat-no" title="statement not covered" >e;</span>let o=<span class="cstat-no" title="statement not covered" >!0,</span>r=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>t.beginPath();<span class="cstat-no" title="statement not covered" >f</span>or(const a of s){const{start:s,end:h}=<span class="cstat-no" title="statement not covered" >a,</span>l=<span class="cstat-no" title="statement not covered" >n[s],</span>c=<span class="cstat-no" title="statement not covered" >n[Kn(s,h,n)];<span class="cstat-no" title="statement not covered" ></span>o?(t.moveTo(l.x,l.y),o=!1):(t.lineTo(l.x,i),t.lineTo(l.x,l.y)),r=!!e.pathSegment(t,a,{move:r}),r?t.closePath():t.lineTo(c.x,i)}<span class="cstat-no" title="statement not covered" ></span>t</span>.lineTo(e.first().x,i),t.closePath(),t.clip()}</span>function <span class="fstat-no" title="function not covered" >ao(</span>t,e,i){const{segments:s,points:n}=<span class="cstat-no" title="statement not covered" >e;</span>let o=<span class="cstat-no" title="statement not covered" >!0,</span>r=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>t.beginPath();<span class="cstat-no" title="statement not covered" >f</span>or(const a of s){const{start:s,end:h}=<span class="cstat-no" title="statement not covered" >a,</span>l=<span class="cstat-no" title="statement not covered" >n[s],</span>c=<span class="cstat-no" title="statement not covered" >n[Kn(s,h,n)];<span class="cstat-no" title="statement not covered" ></span>o?(t.moveTo(l.x,l.y),o=!1):(t.lineTo(i,l.y),t.lineTo(l.x,l.y)),r=!!e.pathSegment(t,a,{move:r}),r?t.closePath():t.lineTo(i,c.y)}<span class="cstat-no" title="statement not covered" ></span>t</span>.lineTo(i,e.first().y),t.closePath(),t.clip()}</span>function <span class="fstat-no" title="function not covered" >ho(</span>t,e){const{line:i,target:s,property:n,color:o,scale:r,clip:a}=<span class="cstat-no" title="statement not covered" >e,</span>h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.segments,</span>n=<span class="cstat-no" title="statement not covered" >t.points,</span>o=<span class="cstat-no" title="statement not covered" >e.points,</span>r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const a of s){let{start:t,end:s}=<span class="cstat-no" title="statement not covered" >a;<span class="cstat-no" title="statement not covered" ></span>s=Kn(t,s,n);c</span>onst h=<span class="cstat-no" title="statement not covered" >qn(i,n[t],n[s],a.loop);<span class="cstat-no" title="statement not covered" ></span>if(!e.segments){<span class="cstat-no" title="statement not covered" >r.push({source:a,target:h,start:n[t],end:n[s]});<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>c</span>onst l=<span class="cstat-no" title="statement not covered" >bi(e,h);<span class="cstat-no" title="statement not covered" ></span>for(const e of l){const t=<span class="cstat-no" title="statement not covered" >qn(i,o[e.start],o[e.end],e.loop),</span>s=<span class="cstat-no" title="statement not covered" >mi(a,n,t);<span class="cstat-no" title="statement not covered" ></span>for(const n of s)<span class="cstat-no" title="statement not covered" >r.push({source:n,target:e,start:{[i]:Jn(h,t,"start",Math.max)},end:{[i]:Jn(h,t,"end",Math.min)}})}</span></span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>(i,s,n);<span class="cstat-no" title="statement not covered" ></span>for(const{source:l,target:c,start:d,end:u}of h){const{style:{backgroundColor:e=<span class="branch-0 cbranch-no" title="branch not covered" >o}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{}}</span>=<span class="cstat-no" title="statement not covered" >l,</span>h=<span class="cstat-no" title="statement not covered" >!0!==s;<span class="cstat-no" title="statement not covered" ></span>t.save(),t.fillStyle=e,lo(t,r,a,h&amp;&amp;qn(n,d,u)),t.beginPath();c</span>onst f=<span class="cstat-no" title="statement not covered" >!!i.pathSegment(t,l);</span>let g;<span class="cstat-no" title="statement not covered" >if(h){<span class="cstat-no" title="statement not covered" >f?t.closePath():co(t,s,u,n);c</span>onst e=<span class="cstat-no" title="statement not covered" >!!s.pathSegment(t,c,{move:f,reverse:!0});<span class="cstat-no" title="statement not covered" ></span>g=f&amp;&amp;e,g||co(t,s,d,n)}<span class="cstat-no" title="statement not covered" ></span>t</span>.closePath(),t.fill(g?"evenodd":"nonzero"),t.restore()}</span>}</span>function <span class="fstat-no" title="function not covered" >lo(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >e.chart.chartArea,</span>{property:o,start:r,end:a}=<span class="cstat-no" title="statement not covered" >s||{};<span class="cstat-no" title="statement not covered" ></span>if("x"===o||"y"===o){let e,s,h,l;<span class="cstat-no" title="statement not covered" >"x"===o?(e=r,s=n.top,h=a,l=n.bottom):(e=n.left,s=r,h=n.right,l=a),t.beginPath(),i&amp;&amp;(e=Math.max(e,i.left),h=Math.min(h,i.right),s=Math.max(s,i.top),l=Math.min(l,i.bottom)),t.rect(e,s,h-e,l-s),t.clip()}</span>}</span>function <span class="fstat-no" title="function not covered" >co(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >e.interpolate(i,s);<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;t.lineTo(n.x,n.y)}</span>var uo=<span class="cstat-no" title="statement not covered" >{id:"filler",<span class="fstat-no" title="function not covered" >af</span>terDatasetsUpdate(t,e,i){const s=<span class="cstat-no" title="statement not covered" >(t.data.datasets||[]).length,</span>n=<span class="cstat-no" title="statement not covered" >[];</span>let o,r,a,h;<span class="cstat-no" title="statement not covered" >for(r=0;r&lt;s;++r)<span class="cstat-no" title="statement not covered" >o=t.getDatasetMeta(r),a=o.dataset,h=null,a&amp;&amp;a.options&amp;&amp;a instanceof Bn&amp;&amp;(h={visible:t.isDatasetVisible(r),index:r,fill:to(a,r,s),chart:t,axis:o.controller.options.indexAxis,scale:o.vScale,line:a}),o.$filler=h,n.push(h);<span class="cstat-no" title="statement not covered" >f</span></span>or(r=0;r&lt;s;++r)<span class="cstat-no" title="statement not covered" >h=n[r],h&amp;&amp;!1!==h.fill&amp;&amp;(h.fill=Qn(n,r,i.propagate))}</span></span>,<span class="fstat-no" title="function not covered" >be</span>foreDraw(t,e,i){const s=<span class="cstat-no" title="statement not covered" >"beforeDraw"===i.drawTime,</span>n=<span class="cstat-no" title="statement not covered" >t.getSortedVisibleDatasetMetas(),</span>o=<span class="cstat-no" title="statement not covered" >t.chartArea;<span class="cstat-no" title="statement not covered" ></span>for(let r=<span class="cstat-no" title="statement not covered" >n.length-1;</span>r&gt;=0;--r){const e=<span class="cstat-no" title="statement not covered" >n[r].$filler;<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;(e.line.updateControlPoints(o,e.axis),s&amp;&amp;e.fill&amp;&amp;oo(t.ctx,e,o))}</span>}</span>,<span class="fstat-no" title="function not covered" >be</span>foreDatasetsDraw(t,e,i){<span class="cstat-no" title="statement not covered" >if("beforeDatasetsDraw"!==i.drawTime)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >t.getSortedVisibleDatasetMetas();<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >s.length-1;</span>n&gt;=0;--n){const e=<span class="cstat-no" title="statement not covered" >s[n].$filler;<span class="cstat-no" title="statement not covered" ></span>Zn(e)&amp;&amp;oo(t.ctx,e,t.chartArea)}</span>}</span>,<span class="fstat-no" title="function not covered" >be</span>foreDatasetDraw(t,e,i){const s=<span class="cstat-no" title="statement not covered" >e.meta.$filler;<span class="cstat-no" title="statement not covered" ></span>Zn(s)&amp;&amp;"beforeDatasetDraw"===i.drawTime&amp;&amp;oo(t.ctx,s,t.chartArea)}</span>,defaults:{propagate:!0,drawTime:"beforeDatasetDraw"}};</span>const fo=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{let{boxHeight:i=<span class="branch-0 cbranch-no" title="branch not covered" >e,</span>boxWidth:s=<span class="branch-0 cbranch-no" title="branch not covered" >e}</span>=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return t.usePointStyle&amp;&amp;(i=Math.min(i,e),s=t.pointStyleWidth||Math.min(s,e)),{boxWidth:s,boxHeight:i,itemHeight:Math.max(e,i)}}</span>;</span>class go extends zs{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this._added=!1,this.legendHitBoxes=[],this._hoveredItem=null,this.doughnutMode=!1,this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this.legendItems=void 0,this.columnSizes=void 0,this.lineWidths=void 0,this.maxHeight=void 0,this.maxWidth=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.height=void 0,this.width=void 0,this._margins=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}<span class="fstat-no" title="function not covered" ></span>up</span>date(t,e,i){<span class="cstat-no" title="statement not covered" >this.maxWidth=t,this.maxHeight=e,this._margins=i,this.setDimensions(),this.buildLabels(),this.fit()}<span class="fstat-no" title="function not covered" ></span>se</span>tDimensions(){<span class="cstat-no" title="statement not covered" >this.isHorizontal()?(this.width=this.maxWidth,this.left=this._margins.left,this.right=this.width):(this.height=this.maxHeight,this.top=this._margins.top,this.bottom=this.height)}<span class="fstat-no" title="function not covered" ></span>bu</span>ildLabels(){const t=<span class="cstat-no" title="statement not covered" >this.options.labels||{};</span>let e=<span class="cstat-no" title="statement not covered" >Y(t.generateLabels,[this.chart],this)||[];<span class="cstat-no" title="statement not covered" ></span>t.filter&amp;&amp;(e=e.filter((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >t.filter(e,this.chart.data))</span>)),t.sort&amp;&amp;(e=e.sort((<span class="fstat-no" title="function not covered" >(e</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >t.sort(e,i,this.chart.data))</span>)),this.options.reverse&amp;&amp;e.reverse(),this.legendItems=e}<span class="fstat-no" title="function not covered" ></span>fi</span>t(){const{options:t,ctx:e}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(!t.display)<span class="cstat-no" title="statement not covered" >return void(this.width=this.height=0);c</span></span>onst i=<span class="cstat-no" title="statement not covered" >t.labels,</span>s=<span class="cstat-no" title="statement not covered" >Ae(i.font),</span>n=<span class="cstat-no" title="statement not covered" >s.size,</span>o=<span class="cstat-no" title="statement not covered" >this._computeTitleHeight(),</span>{boxWidth:r,itemHeight:a}=<span class="cstat-no" title="statement not covered" >fo(i,n);</span>let h,l;<span class="cstat-no" title="statement not covered" >e.font=s.string,this.isHorizontal()?(h=this.maxWidth,l=this._fitRows(o,n,r,a)+10):(l=this.maxHeight,h=this._fitCols(o,s,r,a)+10),this.width=Math.min(h,t.maxWidth||this.maxWidth),this.height=Math.min(l,t.maxHeight||this.maxHeight)}<span class="fstat-no" title="function not covered" ></span>_f</span>itRows(t,e,i,s){const{ctx:n,maxWidth:o,options:{labels:{padding:r}}}=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" >this.legendHitBoxes=[],</span>h=<span class="cstat-no" title="statement not covered" >this.lineWidths=[0],</span>l=<span class="cstat-no" title="statement not covered" >s+r;</span>let c=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>n.textAlign="left",n.textBaseline="middle";l</span>et d=<span class="cstat-no" title="statement not covered" >-1,</span>u=<span class="cstat-no" title="statement not covered" >-l;<span class="cstat-no" title="statement not covered" ></span>return this.legendItems.forEach((<span class="fstat-no" title="function not covered" >(t</span>,f)=&gt;{const g=<span class="cstat-no" title="statement not covered" >i+e/2+n.measureText(t.text).width;<span class="cstat-no" title="statement not covered" ></span>(0===f||h[h.length-1]+g+2*r&gt;o)&amp;&amp;(c+=l,h[h.length-(f&gt;0?0:1)]=0,u+=l,d++),a[f]={left:0,top:u,row:d,width:g,height:s},h[h.length-1]+=g+r}</span>)),c}<span class="fstat-no" title="function not covered" ></span>_f</span>itCols(t,e,i,s){const{ctx:n,maxHeight:o,options:{labels:{padding:r}}}=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" >this.legendHitBoxes=[],</span>h=<span class="cstat-no" title="statement not covered" >this.columnSizes=[],</span>l=<span class="cstat-no" title="statement not covered" >o-t;</span>let c=<span class="cstat-no" title="statement not covered" >r,</span>d=<span class="cstat-no" title="statement not covered" >0,</span>u=<span class="cstat-no" title="statement not covered" >0,</span>f=<span class="cstat-no" title="statement not covered" >0,</span>g=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return this.legendItems.forEach((<span class="fstat-no" title="function not covered" >(t</span>,o)=&gt;{const{itemWidth:p,itemHeight:x}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s,n){const o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){let n=<span class="cstat-no" title="statement not covered" >t.text;<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;"string"!==typeof n&amp;&amp;(n=n.reduce((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t.length&gt;e.length?t:e)</span>));<span class="cstat-no" title="statement not covered" >r</span>eturn e+i.size/2+s.measureText(n).width}</span>(s,t,e,i),</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){let s=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>"string"!==typeof e.text&amp;&amp;(s=po(e,i));<span class="cstat-no" title="statement not covered" >r</span>eturn s}</span>(n,s,e.lineHeight);<span class="cstat-no" title="statement not covered" ></span>return{itemWidth:o,itemHeight:r}}</span>(i,e,n,t,s);<span class="cstat-no" title="statement not covered" ></span>o&gt;0&amp;&amp;u+x+2*r&gt;l&amp;&amp;(c+=d+r,h.push({width:d,height:u}),f+=d+r,g++,d=u=0),a[o]={left:f,top:u,col:g,width:p,height:x},d=Math.max(d,p),u+=x+r}</span>)),c+=d,h.push({width:d,height:u}),c}<span class="fstat-no" title="function not covered" ></span>ad</span>justHitBoxes(){<span class="cstat-no" title="statement not covered" >if(!this.options.display)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this._computeTitleHeight(),</span>{legendHitBoxes:e,options:{align:i,labels:{padding:s},rtl:n}}=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >ui(n,this.left,this.width);<span class="cstat-no" title="statement not covered" ></span>if(this.isHorizontal()){let n=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >Wt(i,this.left+s,this.right-this.lineWidths[n]);<span class="cstat-no" title="statement not covered" ></span>for(const a of e)<span class="cstat-no" title="statement not covered" >n!==a.row&amp;&amp;(n=a.row,r=Wt(i,this.left+s,this.right-this.lineWidths[n])),a.top+=this.top+t+s,a.left=o.leftForLtr(o.x(r),a.width),r+=a.width+s}</span></span>else{let n=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >Wt(i,this.top+t+s,this.bottom-this.columnSizes[n].height);<span class="cstat-no" title="statement not covered" ></span>for(const a of e)<span class="cstat-no" title="statement not covered" >a.col!==n&amp;&amp;(n=a.col,r=Wt(i,this.top+t+s,this.bottom-this.columnSizes[n].height)),a.top=r,a.left+=this.left+s,a.left=o.leftForLtr(o.x(a.left),a.width),r+=a.height+s}</span></span>}<span class="fstat-no" title="function not covered" ></span>is</span>Horizontal(){<span class="cstat-no" title="statement not covered" >return"top"===this.options.position||"bottom"===this.options.position}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(){<span class="cstat-no" title="statement not covered" >if(this.options.display){const t=<span class="cstat-no" title="statement not covered" >this.ctx;<span class="cstat-no" title="statement not covered" ></span>fe(t,this),this._draw(),ge(t)}</span>}<span class="fstat-no" title="function not covered" ></span>_d</span>raw(){const{options:t,columnSizes:e,lineWidths:i,ctx:s}=<span class="cstat-no" title="statement not covered" >this,</span>{align:n,labels:o}=<span class="cstat-no" title="statement not covered" >t,</span>r=<span class="cstat-no" title="statement not covered" >re.color,</span>a=<span class="cstat-no" title="statement not covered" >ui(t.rtl,this.left,this.width),</span>h=<span class="cstat-no" title="statement not covered" >Ae(o.font),</span>{padding:l}=<span class="cstat-no" title="statement not covered" >o,</span>c=<span class="cstat-no" title="statement not covered" >h.size,</span>d=<span class="cstat-no" title="statement not covered" >c/2;</span>let u;<span class="cstat-no" title="statement not covered" >this.drawTitle(),s.textAlign=a.textAlign("left"),s.textBaseline="middle",s.lineWidth=.5,s.font=h.string;c</span>onst{boxWidth:f,boxHeight:g,itemHeight:p}=<span class="cstat-no" title="statement not covered" >fo(o,c),</span>x=<span class="cstat-no" title="statement not covered" >this.isHorizontal(),</span>m=<span class="cstat-no" title="statement not covered" >this._computeTitleHeight();<span class="cstat-no" title="statement not covered" ></span>u=x?{x:Wt(n,this.left+l,this.right-i[0]),y:this.top+l+m,line:0}:{x:this.left+l,y:Wt(n,this.top+m+l,this.bottom-e[0].height),line:0},fi(this.ctx,t.textDirection);c</span>onst b=<span class="cstat-no" title="statement not covered" >p+l;<span class="cstat-no" title="statement not covered" ></span>this.legendItems.forEach((<span class="fstat-no" title="function not covered" >(_</span>,y)=&gt;{<span class="cstat-no" title="statement not covered" >s.strokeStyle=_.fontColor,s.fillStyle=_.fontColor;c</span>onst v=<span class="cstat-no" title="statement not covered" >s.measureText(_.text).width,</span>w=<span class="cstat-no" title="statement not covered" >a.textAlign(_.textAlign||(_.textAlign=o.textAlign)),</span>M=<span class="cstat-no" title="statement not covered" >f+d+v;</span>let k=<span class="cstat-no" title="statement not covered" >u.x,</span>S=<span class="cstat-no" title="statement not covered" >u.y;<span class="cstat-no" title="statement not covered" ></span>a.setWidth(this.width),x?y&gt;0&amp;&amp;k+M+l&gt;this.right&amp;&amp;(S=u.y+=b,u.line++,k=u.x=Wt(n,this.left+l,this.right-i[u.line])):y&gt;0&amp;&amp;S+b&gt;this.bottom&amp;&amp;(k=u.x=k+e[u.line].width+l,u.line++,S=u.y=Wt(n,this.top+m+l,this.bottom-e[u.line].height));<span class="cstat-no" title="statement not covered" >i</span>f(<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >if(isNaN(f)||f&lt;=0||isNaN(g)||g&lt;0)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >s</span></span>.save();c</span>onst n=<span class="cstat-no" title="statement not covered" >N(i.lineWidth,1);<span class="cstat-no" title="statement not covered" ></span>if(s.fillStyle=N(i.fillStyle,r),s.lineCap=N(i.lineCap,"butt"),s.lineDashOffset=N(i.lineDashOffset,0),s.lineJoin=N(i.lineJoin,"miter"),s.lineWidth=n,s.strokeStyle=N(i.strokeStyle,r),s.setLineDash(N(i.lineDash,[])),o.usePointStyle){const r=<span class="cstat-no" title="statement not covered" >{radius:g*Math.SQRT2/2,pointStyle:i.pointStyle,rotation:i.rotation,borderWidth:n},</span>h=<span class="cstat-no" title="statement not covered" >a.xPlus(t,f/2);<span class="cstat-no" title="statement not covered" ></span>de(s,r,h,e+d,o.pointStyleWidth&amp;&amp;f)}</span>else{const o=<span class="cstat-no" title="statement not covered" >e+Math.max((c-g)/2,0),</span>r=<span class="cstat-no" title="statement not covered" >a.leftForLtr(t,f),</span>h=<span class="cstat-no" title="statement not covered" >Pe(i.borderRadius);<span class="cstat-no" title="statement not covered" ></span>s.beginPath(),Object.values(h).some((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >0!==t)</span>)?ye(s,{x:r,y:o,w:f,h:g,radius:h}):s.rect(r,o,f,g),s.fill(),0!==n&amp;&amp;s.stroke()}<span class="cstat-no" title="statement not covered" ></span>s</span>.restore()}</span>(a.x(k),S,_),k=(<span class="fstat-no" title="function not covered" >(t</span>,e,i,s)=&gt;<span class="cstat-no" title="statement not covered" >t===(s?"left":"right")?i:"center"===t?(e+i)/2:e)</span>(w,k+f+d,x?k+M:this.right,t.rtl),<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >_e(s,i.text,t,e+p/2,h,{strikethrough:i.hidden,textAlign:a.textAlign(i.textAlign)})}</span>(a.x(k),S,_),x)<span class="cstat-no" title="statement not covered" >u.x+=M+l;e</span>lse <span class="cstat-no" title="statement not covered" >if("string"!==typeof _.text){const t=<span class="cstat-no" title="statement not covered" >h.lineHeight;<span class="cstat-no" title="statement not covered" ></span>u.y+=po(_,t)+l}</span>else <span class="cstat-no" title="statement not covered" >u.y+=b}</span></span></span>)),gi(this.ctx,t.textDirection)}<span class="fstat-no" title="function not covered" ></span>dr</span>awTitle(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >t.title,</span>i=<span class="cstat-no" title="statement not covered" >Ae(e.font),</span>s=<span class="cstat-no" title="statement not covered" >De(e.padding);<span class="cstat-no" title="statement not covered" ></span>if(!e.display)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >ui(t.rtl,this.left,this.width),</span>o=<span class="cstat-no" title="statement not covered" >this.ctx,</span>r=<span class="cstat-no" title="statement not covered" >e.position,</span>a=<span class="cstat-no" title="statement not covered" >i.size/2,</span>h=<span class="cstat-no" title="statement not covered" >s.top+a;</span>let l,c=<span class="cstat-no" title="statement not covered" >this.left,</span>d=<span class="cstat-no" title="statement not covered" >this.width;<span class="cstat-no" title="statement not covered" ></span>if(this.isHorizontal())<span class="cstat-no" title="statement not covered" >d=Math.max(...this.lineWidths),l=this.top+h,c=Wt(t.align,c,this.right-d);e</span>lse{const e=<span class="cstat-no" title="statement not covered" >this.columnSizes.reduce((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >Math.max(t,e.height))</span>,0);<span class="cstat-no" title="statement not covered" ></span>l=h+Wt(t.align,this.top,this.bottom-e-t.labels.padding-this._computeTitleHeight())}</span>c</span>onst u=<span class="cstat-no" title="statement not covered" >Wt(r,c,c+d);<span class="cstat-no" title="statement not covered" ></span>o.textAlign=n.textAlign(Bt(r)),o.textBaseline="middle",o.strokeStyle=e.color,o.fillStyle=e.color,o.font=i.string,_e(o,e.text,u,l,i)}<span class="fstat-no" title="function not covered" ></span>_c</span>omputeTitleHeight(){const t=<span class="cstat-no" title="statement not covered" >this.options.title,</span>e=<span class="cstat-no" title="statement not covered" >Ae(t.font),</span>i=<span class="cstat-no" title="statement not covered" >De(t.padding);<span class="cstat-no" title="statement not covered" ></span>return t.display?e.lineHeight+i.height:0}<span class="fstat-no" title="function not covered" ></span>_g</span>etLegendItemAt(t,e){let i,s,n;<span class="cstat-no" title="statement not covered" >if(Ot(t,this.left,this.right)&amp;&amp;Ot(e,this.top,this.bottom))<span class="cstat-no" title="statement not covered" >for(n=this.legendHitBoxes,i=0;i&lt;n.length;++i)<span class="cstat-no" title="statement not covered" >if(s=n[i],Ot(t,s.left,s.left+s.width)&amp;&amp;Ot(e,s.top,s.top+s.height))<span class="cstat-no" title="statement not covered" >return this.legendItems[i];<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn null}<span class="fstat-no" title="function not covered" ></span>ha</span>ndleEvent(t){const e=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if(!<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(("mousemove"===t||"mouseout"===t)&amp;&amp;(e.onHover||e.onLeave))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(e.onClick&amp;&amp;("click"===t||"mouseup"===t))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span>eturn!1}</span>(t.type,e))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >this._getLegendItemAt(t.x,t.y);<span class="cstat-no" title="statement not covered" ></span>if("mousemove"===t.type||"mouseout"===t.type){const o=<span class="cstat-no" title="statement not covered" >this._hoveredItem,</span>r=(<span class="cstat-no" title="statement not covered" >n=i,null!==(s=o)&amp;&amp;null!==n&amp;&amp;s.datasetIndex===n.datasetIndex&amp;&amp;s.index===n.index)</span>;<span class="cstat-no" title="statement not covered" >o&amp;&amp;!r&amp;&amp;Y(e.onLeave,[t,o,this],this),this._hoveredItem=i,i&amp;&amp;!r&amp;&amp;Y(e.onHover,[t,i,this],this)}</span>else <span class="cstat-no" title="statement not covered" >i&amp;&amp;Y(e.onClick,[t,i,this],this);v</span></span>ar s,n}}function <span class="fstat-no" title="function not covered" >po(</span>t,e){<span class="cstat-no" title="statement not covered" >return e*(t.text?t.text.length:0)}</span>var xo=<span class="cstat-no" title="statement not covered" >{id:"legend",_element:go,<span class="fstat-no" title="function not covered" >st</span>art(t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.legend=new go({ctx:t.ctx,options:i,chart:t});<span class="cstat-no" title="statement not covered" ></span>_s.configure(t,s,i),_s.addBox(t,s)}</span>,<span class="fstat-no" title="function not covered" >st</span>op(t){<span class="cstat-no" title="statement not covered" >_s.removeBox(t,t.legend),delete t.legend}</span>,<span class="fstat-no" title="function not covered" >be</span>foreUpdate(t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.legend;<span class="cstat-no" title="statement not covered" ></span>_s.configure(t,s,i),s.options=i}</span>,<span class="fstat-no" title="function not covered" >af</span>terUpdate(t){const e=<span class="cstat-no" title="statement not covered" >t.legend;<span class="cstat-no" title="statement not covered" ></span>e.buildLabels(),e.adjustHitBoxes()}</span>,<span class="fstat-no" title="function not covered" >af</span>terEvent(t,e){<span class="cstat-no" title="statement not covered" >e.replay||t.legend.handleEvent(e.event)}</span>,defaults:{display:!0,position:"top",align:"center",fullSize:!0,reverse:!1,weight:1e3,<span class="fstat-no" title="function not covered" >on</span>Click(t,e,i){const s=<span class="cstat-no" title="statement not covered" >e.datasetIndex,</span>n=<span class="cstat-no" title="statement not covered" >i.chart;<span class="cstat-no" title="statement not covered" ></span>n.isDatasetVisible(s)?(n.hide(s),e.hidden=!0):(n.show(s),e.hidden=!1)}</span>,onHover:null,onLeave:null,labels:{color:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.chart.options.color,</span>boxWidth:40,padding:10,<span class="fstat-no" title="function not covered" >ge</span>nerateLabels(t){const e=<span class="cstat-no" title="statement not covered" >t.data.datasets,</span>{labels:{usePointStyle:i,pointStyle:s,textAlign:n,color:o,useBorderRadius:r,borderRadius:a}}=<span class="cstat-no" title="statement not covered" >t.legend.options;<span class="cstat-no" title="statement not covered" ></span>return t._getSortedDatasetMetas().map((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const h=<span class="cstat-no" title="statement not covered" >t.controller.getStyle(i?0:void 0),</span>l=<span class="cstat-no" title="statement not covered" >De(h.borderWidth);<span class="cstat-no" title="statement not covered" ></span>return{text:e[t.index].label,fillStyle:h.backgroundColor,fontColor:o,hidden:!t.visible,lineCap:h.borderCapStyle,lineDash:h.borderDash,lineDashOffset:h.borderDashOffset,lineJoin:h.borderJoinStyle,lineWidth:(l.width+l.height)/4,strokeStyle:h.borderColor,pointStyle:s||h.pointStyle,rotation:h.rotation,textAlign:n||h.textAlign,borderRadius:r&amp;&amp;(a||h.borderRadius),datasetIndex:t.index}}</span>),this)}</span>},title:{color:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.chart.options.color,</span>display:!1,position:"center",text:""}},descriptors:{_scriptable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!t.startsWith("on"),</span>labels:{_scriptable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!["generateLabels","filter","sort"].includes(t)}</span>}};</span>class mo extends zs{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this._padding=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}<span class="fstat-no" title="function not covered" ></span>up</span>date(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if(this.left=0,this.top=0,!i.display)<span class="cstat-no" title="statement not covered" >return void(this.width=this.height=this.right=this.bottom=0);<span class="cstat-no" title="statement not covered" >t</span></span>his.width=this.right=t,this.height=this.bottom=e;c</span>onst s=<span class="cstat-no" title="statement not covered" >W(i.text)?i.text.length:1;<span class="cstat-no" title="statement not covered" ></span>this._padding=De(i.padding);c</span>onst n=<span class="cstat-no" title="statement not covered" >s*Ae(i.font).lineHeight+this._padding.height;<span class="cstat-no" title="statement not covered" ></span>this.isHorizontal()?this.height=n:this.width=n}<span class="fstat-no" title="function not covered" ></span>is</span>Horizontal(){const t=<span class="cstat-no" title="statement not covered" >this.options.position;<span class="cstat-no" title="statement not covered" ></span>return"top"===t||"bottom"===t}<span class="fstat-no" title="function not covered" ></span>_d</span>rawArgs(t){const{top:e,left:i,bottom:s,right:n,options:o}=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >o.align;</span>let a,h,l,c=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return this.isHorizontal()?(h=Wt(r,i,n),l=e+t,a=n-i):("left"===o.position?(h=i+t,l=Wt(r,s,e),c=-.5*rt):(h=n-t,l=Wt(r,e,s),c=.5*rt),a=s-e),{titleX:h,titleY:l,maxWidth:a,rotation:c}}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(){const t=<span class="cstat-no" title="statement not covered" >this.ctx,</span>e=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if(!e.display)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >Ae(e.font),</span>s=<span class="cstat-no" title="statement not covered" >i.lineHeight/2+this._padding.top,</span>{titleX:n,titleY:o,maxWidth:r,rotation:a}=<span class="cstat-no" title="statement not covered" >this._drawArgs(s);<span class="cstat-no" title="statement not covered" ></span>_e(t,e.text,0,0,i,{color:e.color,maxWidth:r,rotation:a,textAlign:Bt(e.align),textBaseline:"middle",translation:[n,o]})}</span>}var bo=<span class="cstat-no" title="statement not covered" >{id:"title",_element:mo,<span class="fstat-no" title="function not covered" >st</span>art(t,e,i){<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >new mo({ctx:t.ctx,options:e,chart:t});<span class="cstat-no" title="statement not covered" ></span>_s.configure(t,i,e),_s.addBox(t,i),t.titleBlock=i}</span>(t,i)}</span>,<span class="fstat-no" title="function not covered" >st</span>op(t){const e=<span class="cstat-no" title="statement not covered" >t.titleBlock;<span class="cstat-no" title="statement not covered" ></span>_s.removeBox(t,e),delete t.titleBlock}</span>,<span class="fstat-no" title="function not covered" >be</span>foreUpdate(t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.titleBlock;<span class="cstat-no" title="statement not covered" ></span>_s.configure(t,s,i),s.options=i}</span>,defaults:{align:"center",display:!1,font:{weight:"bold"},fullSize:!0,padding:10,position:"top",text:"",weight:2e3},defaultRoutes:{color:"color"},descriptors:{_scriptable:!0,_indexable:!1}};<span class="cstat-no" title="statement not covered" ></span>new WeakMap;c</span>onst _o=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >av</span>erage(t){<span class="cstat-no" title="statement not covered" >if(!t.length)<span class="cstat-no" title="statement not covered" >return!1;l</span></span>et e,i,s=<span class="cstat-no" title="statement not covered" >new Set,</span>n=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(e=0,i=t.length;e&lt;i;++e){const i=<span class="cstat-no" title="statement not covered" >t[e].element;<span class="cstat-no" title="statement not covered" ></span>if(i&amp;&amp;i.hasValue()){const t=<span class="cstat-no" title="statement not covered" >i.tooltipPosition();<span class="cstat-no" title="statement not covered" ></span>s.add(t.x),n+=t.y,++o}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(0===o||0===s.size)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span>eturn{x:[...s].reduce((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t+e)</span>)/s.size,y:n/o}}</span>,<span class="fstat-no" title="function not covered" >ne</span>arest(t,e){<span class="cstat-no" title="statement not covered" >if(!t.length)<span class="cstat-no" title="statement not covered" >return!1;l</span></span>et i,s,n,o=<span class="cstat-no" title="statement not covered" >e.x,</span>r=<span class="cstat-no" title="statement not covered" >e.y,</span>a=<span class="cstat-no" title="statement not covered" >Number.POSITIVE_INFINITY;<span class="cstat-no" title="statement not covered" ></span>for(i=0,s=t.length;i&lt;s;++i){const s=<span class="cstat-no" title="statement not covered" >t[i].element;<span class="cstat-no" title="statement not covered" ></span>if(s&amp;&amp;s.hasValue()){const t=<span class="cstat-no" title="statement not covered" >kt(e,s.getCenterPoint());<span class="cstat-no" title="statement not covered" ></span>t&lt;a&amp;&amp;(a=t,n=s)}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(n){const t=<span class="cstat-no" title="statement not covered" >n.tooltipPosition();<span class="cstat-no" title="statement not covered" ></span>o=t.x,r=t.y}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{x:o,y:r}}</span>};</span>function <span class="fstat-no" title="function not covered" >yo(</span>t,e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;(W(e)?Array.prototype.push.apply(t,e):t.push(e)),t}</span>function <span class="fstat-no" title="function not covered" >vo(</span>t){<span class="cstat-no" title="statement not covered" >return("string"===typeof t||t instanceof String)&amp;&amp;t.indexOf("\n")&gt;-1?t.split("\n"):t}</span>function <span class="fstat-no" title="function not covered" >wo(</span>t,e){const{element:i,datasetIndex:s,index:n}=<span class="cstat-no" title="statement not covered" >e,</span>o=<span class="cstat-no" title="statement not covered" >t.getDatasetMeta(s).controller,</span>{label:r,value:a}=<span class="cstat-no" title="statement not covered" >o.getLabelAndValue(n);<span class="cstat-no" title="statement not covered" ></span>return{chart:t,label:r,parsed:o.getParsed(n),raw:t.data.datasets[s].data[n],formattedValue:a,dataset:o.getDataset(),dataIndex:n,datasetIndex:s,element:i}}</span>function <span class="fstat-no" title="function not covered" >Mo(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t.chart.ctx,</span>{body:s,footer:n,title:o}=<span class="cstat-no" title="statement not covered" >t,</span>{boxWidth:r,boxHeight:a}=<span class="cstat-no" title="statement not covered" >e,</span>h=<span class="cstat-no" title="statement not covered" >Ae(e.bodyFont),</span>l=<span class="cstat-no" title="statement not covered" >Ae(e.titleFont),</span>c=<span class="cstat-no" title="statement not covered" >Ae(e.footerFont),</span>d=<span class="cstat-no" title="statement not covered" >o.length,</span>u=<span class="cstat-no" title="statement not covered" >n.length,</span>f=<span class="cstat-no" title="statement not covered" >s.length,</span>g=<span class="cstat-no" title="statement not covered" >De(e.padding);</span>let p=<span class="cstat-no" title="statement not covered" >g.height,</span>x=<span class="cstat-no" title="statement not covered" >0,</span>m=<span class="cstat-no" title="statement not covered" >s.reduce((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t+e.before.length+e.lines.length+e.after.length)</span>,0);<span class="cstat-no" title="statement not covered" ></span>if(m+=t.beforeBody.length+t.afterBody.length,d&amp;&amp;(p+=d*l.lineHeight+(d-1)*e.titleSpacing+e.titleMarginBottom),m){<span class="cstat-no" title="statement not covered" >p+=f*(e.displayColors?Math.max(a,h.lineHeight):h.lineHeight)+(m-f)*h.lineHeight+(m-1)*e.bodySpacing}<span class="cstat-no" title="statement not covered" ></span>u</span>&amp;&amp;(p+=e.footerMarginTop+u*c.lineHeight+(u-1)*e.footerSpacing);l</span>et b=<span class="cstat-no" title="statement not covered" >0;</span>const _=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >x=Math.max(x,i.measureText(t).width+b)}</span>;<span class="cstat-no" title="statement not covered" ></span>return i.save(),i.font=l.string,U(t.title,_),i.font=h.string,U(t.beforeBody.concat(t.afterBody),_),b=e.displayColors?r+2+e.boxPadding:0,U(s,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >U(t.before,_),U(t.lines,_),U(t.after,_)}</span>)),b=0,i.font=c.string,U(t.footer,_),i.restore(),x+=g.width,{width:x,height:p}}</span>function <span class="fstat-no" title="function not covered" >ko(</span>t,e,i,s){const{x:n,width:o}=<span class="cstat-no" title="statement not covered" >i,</span>{width:r,chartArea:{left:a,right:h}}=<span class="cstat-no" title="statement not covered" >t;</span>let l=<span class="cstat-no" title="statement not covered" >"center";<span class="cstat-no" title="statement not covered" ></span>return"center"===s?l=n&lt;=(a+h)/2?"left":"right":n&lt;=o/2?l="left":n&gt;=r-o/2&amp;&amp;(l="right"),<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const{x:n,width:o}=<span class="cstat-no" title="statement not covered" >s,</span>r=<span class="cstat-no" title="statement not covered" >i.caretSize+i.caretPadding;<span class="cstat-no" title="statement not covered" ></span>return"left"===t&amp;&amp;n+o+r&gt;e.width||"right"===t&amp;&amp;n-o-r&lt;0||void 0}</span>(l,t,e,i)&amp;&amp;(l="center"),l}</span>function <span class="fstat-no" title="function not covered" >So(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >i.yAlign||e.yAlign||<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const{y:i,height:s}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return i&lt;s/2?"top":i&gt;t.height-s/2?"bottom":"center"}</span>(t,i);<span class="cstat-no" title="statement not covered" ></span>return{xAlign:i.xAlign||e.xAlign||ko(t,e,i,s),yAlign:s}}</span>function <span class="fstat-no" title="function not covered" >Po(</span>t,e,i,s){const{caretSize:n,caretPadding:o,cornerRadius:r}=<span class="cstat-no" title="statement not covered" >t,</span>{xAlign:a,yAlign:h}=<span class="cstat-no" title="statement not covered" >i,</span>l=<span class="cstat-no" title="statement not covered" >n+o,</span>{topLeft:c,topRight:d,bottomLeft:u,bottomRight:f}=<span class="cstat-no" title="statement not covered" >Pe(r);</span>let g=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){let{x:i,width:s}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return"right"===e?i-=s:"center"===e&amp;&amp;(i-=s/2),i}</span>(e,a);</span>const p=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){let{y:s,height:n}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return"top"===e?s+=i:s-="bottom"===e?n+i:n/2,s}</span>(e,h,l);<span class="cstat-no" title="statement not covered" ></span>return"center"===h?"left"===a?g+=l:"right"===a&amp;&amp;(g-=l):"left"===a?g-=Math.max(c,u)+n:"right"===a&amp;&amp;(g+=Math.max(d,f)+n),{x:At(g,0,s.width-e.width),y:At(p,0,s.height-e.height)}}</span>function <span class="fstat-no" title="function not covered" >Do(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >De(i.padding);<span class="cstat-no" title="statement not covered" ></span>return"center"===e?t.x+t.width/2:"right"===e?t.x+t.width-s.right:t.x+s.left}</span>function <span class="fstat-no" title="function not covered" >Ao(</span>t){<span class="cstat-no" title="statement not covered" >return yo([],vo(t))}</span>function <span class="fstat-no" title="function not covered" >Oo(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >e&amp;&amp;e.dataset&amp;&amp;e.dataset.tooltip&amp;&amp;e.dataset.tooltip.callbacks;<span class="cstat-no" title="statement not covered" ></span>return i?t.override(i):t}</span>const Co=<span class="cstat-no" title="statement not covered" >{beforeTitle:z,<span class="fstat-no" title="function not covered" >ti</span>tle(t){<span class="cstat-no" title="statement not covered" >if(t.length&gt;0){const e=<span class="cstat-no" title="statement not covered" >t[0],</span>i=<span class="cstat-no" title="statement not covered" >e.chart.data.labels,</span>s=<span class="cstat-no" title="statement not covered" >i?i.length:0;<span class="cstat-no" title="statement not covered" ></span>if(this&amp;&amp;this.options&amp;&amp;"dataset"===this.options.mode)<span class="cstat-no" title="statement not covered" >return e.dataset.label||"";<span class="cstat-no" title="statement not covered" >i</span></span>f(e.label)<span class="cstat-no" title="statement not covered" >return e.label;<span class="cstat-no" title="statement not covered" >i</span></span>f(s&gt;0&amp;&amp;e.dataIndex&lt;s)<span class="cstat-no" title="statement not covered" >return i[e.dataIndex]}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn""}</span>,afterTitle:z,beforeBody:z,beforeLabel:z,<span class="fstat-no" title="function not covered" >la</span>bel(t){<span class="cstat-no" title="statement not covered" >if(this&amp;&amp;this.options&amp;&amp;"dataset"===this.options.mode)<span class="cstat-no" title="statement not covered" >return t.label+": "+t.formattedValue||t.formattedValue;l</span></span>et e=<span class="cstat-no" title="statement not covered" >t.dataset.label||"";<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;(e+=": ");c</span>onst i=<span class="cstat-no" title="statement not covered" >t.formattedValue;<span class="cstat-no" title="statement not covered" ></span>return B(i)||(e+=i),e}</span>,<span class="fstat-no" title="function not covered" >la</span>belColor(t){const e=<span class="cstat-no" title="statement not covered" >t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);<span class="cstat-no" title="statement not covered" ></span>return{borderColor:e.borderColor,backgroundColor:e.backgroundColor,borderWidth:e.borderWidth,borderDash:e.borderDash,borderDashOffset:e.borderDashOffset,borderRadius:0}}</span>,<span class="fstat-no" title="function not covered" >la</span>belTextColor(){<span class="cstat-no" title="statement not covered" >return this.options.bodyColor}</span>,<span class="fstat-no" title="function not covered" >la</span>belPointStyle(t){const e=<span class="cstat-no" title="statement not covered" >t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);<span class="cstat-no" title="statement not covered" ></span>return{pointStyle:e.pointStyle,rotation:e.rotation}}</span>,afterLabel:z,afterBody:z,beforeFooter:z,footer:z,afterFooter:z};</span>function <span class="fstat-no" title="function not covered" >To(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >t[e].call(i,s);<span class="cstat-no" title="statement not covered" ></span>return"undefined"===typeof n?Co[e].call(i,s):n}</span>class Ro extends zs{static positioners=<span class="cstat-no" title="statement not covered" >_o;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.opacity=0,this._active=[],this._eventPosition=void 0,this._size=void 0,this._cachedAnimations=void 0,this._tooltipItems=[],this.$animations=void 0,this.$context=void 0,this.chart=t.chart,this.options=t.options,this.dataPoints=void 0,this.title=void 0,this.beforeBody=void 0,this.body=void 0,this.afterBody=void 0,this.footer=void 0,this.xAlign=void 0,this.yAlign=void 0,this.x=void 0,this.y=void 0,this.height=void 0,this.width=void 0,this.caretX=void 0,this.caretY=void 0,this.labelColors=void 0,this.labelPointStyles=void 0,this.labelTextColors=void 0}<span class="fstat-no" title="function not covered" ></span>in</span>itialize(t){<span class="cstat-no" title="statement not covered" >this.options=t,this._cachedAnimations=void 0,this.$context=void 0}<span class="fstat-no" title="function not covered" ></span>_r</span>esolveAnimations(){const t=<span class="cstat-no" title="statement not covered" >this._cachedAnimations;<span class="cstat-no" title="statement not covered" ></span>if(t)<span class="cstat-no" title="statement not covered" >return t;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.chart,</span>i=<span class="cstat-no" title="statement not covered" >this.options.setContext(this.getContext()),</span>s=<span class="cstat-no" title="statement not covered" >i.enabled&amp;&amp;e.options.animation&amp;&amp;i.animations,</span>n=<span class="cstat-no" title="statement not covered" >new Oi(this.chart,s);<span class="cstat-no" title="statement not covered" ></span>return s._cacheable&amp;&amp;(this._cachedAnimations=Object.freeze(n)),n}<span class="fstat-no" title="function not covered" ></span>ge</span>tContext(){<span class="cstat-no" title="statement not covered" >return this.$context||(this.$context=(t=this.chart.getContext(),e=this,i=this._tooltipItems,Ce(t,{tooltip:e,tooltipItems:i,type:"tooltip"})));v</span>ar t,e,i}<span class="fstat-no" title="function not covered" >ge</span>tTitle(t,e){const{callbacks:i}=<span class="cstat-no" title="statement not covered" >e,</span>s=<span class="cstat-no" title="statement not covered" >To(i,"beforeTitle",this,t),</span>n=<span class="cstat-no" title="statement not covered" >To(i,"title",this,t),</span>o=<span class="cstat-no" title="statement not covered" >To(i,"afterTitle",this,t);</span>let r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return r=yo(r,vo(s)),r=yo(r,vo(n)),r=yo(r,vo(o)),r}<span class="fstat-no" title="function not covered" ></span>ge</span>tBeforeBody(t,e){<span class="cstat-no" title="statement not covered" >return Ao(To(e.callbacks,"beforeBody",this,t))}<span class="fstat-no" title="function not covered" ></span>ge</span>tBody(t,e){const{callbacks:i}=<span class="cstat-no" title="statement not covered" >e,</span>s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return U(t,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >{before:[],lines:[],after:[]},</span>n=<span class="cstat-no" title="statement not covered" >Oo(i,t);<span class="cstat-no" title="statement not covered" ></span>yo(e.before,vo(To(n,"beforeLabel",this,t))),yo(e.lines,To(n,"label",this,t)),yo(e.after,vo(To(n,"afterLabel",this,t))),s.push(e)}</span>)),s}<span class="fstat-no" title="function not covered" ></span>ge</span>tAfterBody(t,e){<span class="cstat-no" title="statement not covered" >return Ao(To(e.callbacks,"afterBody",this,t))}<span class="fstat-no" title="function not covered" ></span>ge</span>tFooter(t,e){const{callbacks:i}=<span class="cstat-no" title="statement not covered" >e,</span>s=<span class="cstat-no" title="statement not covered" >To(i,"beforeFooter",this,t),</span>n=<span class="cstat-no" title="statement not covered" >To(i,"footer",this,t),</span>o=<span class="cstat-no" title="statement not covered" >To(i,"afterFooter",this,t);</span>let r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return r=yo(r,vo(s)),r=yo(r,vo(n)),r=yo(r,vo(o)),r}<span class="fstat-no" title="function not covered" ></span>_c</span>reateItems(t){const e=<span class="cstat-no" title="statement not covered" >this._active,</span>i=<span class="cstat-no" title="statement not covered" >this.chart.data,</span>s=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >[];</span>let r,a,h=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(r=0,a=e.length;r&lt;a;++r)<span class="cstat-no" title="statement not covered" >h.push(wo(this.chart,e[r]));<span class="cstat-no" title="statement not covered" >r</span></span>eturn t.filter&amp;&amp;(h=h.filter((<span class="fstat-no" title="function not covered" >(e</span>,s,n)=&gt;<span class="cstat-no" title="statement not covered" >t.filter(e,s,n,i))</span>)),t.itemSort&amp;&amp;(h=h.sort((<span class="fstat-no" title="function not covered" >(e</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >t.itemSort(e,s,i))</span>)),U(h,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >Oo(t.callbacks,e);<span class="cstat-no" title="statement not covered" ></span>s.push(To(i,"labelColor",this,e)),n.push(To(i,"labelPointStyle",this,e)),o.push(To(i,"labelTextColor",this,e))}</span>)),this.labelColors=s,this.labelPointStyles=n,this.labelTextColors=o,this.dataPoints=h,h}<span class="fstat-no" title="function not covered" ></span>up</span>date(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options.setContext(this.getContext()),</span>s=<span class="cstat-no" title="statement not covered" >this._active;</span>let n,o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(s.length){const t=<span class="cstat-no" title="statement not covered" >_o[i.position].call(this,s,this._eventPosition);<span class="cstat-no" title="statement not covered" ></span>o=this._createItems(i),this.title=this.getTitle(o,i),this.beforeBody=this.getBeforeBody(o,i),this.body=this.getBody(o,i),this.afterBody=this.getAfterBody(o,i),this.footer=this.getFooter(o,i);c</span>onst e=<span class="cstat-no" title="statement not covered" >this._size=Mo(this,i),</span>r=<span class="cstat-no" title="statement not covered" >Object.assign({},t,e),</span>a=<span class="cstat-no" title="statement not covered" >So(this.chart,i,r),</span>h=<span class="cstat-no" title="statement not covered" >Po(i,r,a,this.chart);<span class="cstat-no" title="statement not covered" ></span>this.xAlign=a.xAlign,this.yAlign=a.yAlign,n={opacity:1,x:h.x,y:h.y,width:e.width,height:e.height,caretX:t.x,caretY:t.y}}</span>else <span class="cstat-no" title="statement not covered" >0!==this.opacity&amp;&amp;(n={opacity:0});<span class="cstat-no" title="statement not covered" >t</span></span>his._tooltipItems=o,this.$context=void 0,n&amp;&amp;this._resolveAnimations().update(this,n),t&amp;&amp;i.external&amp;&amp;i.external.call(this,{chart:this.chart,tooltip:this,replay:e})}<span class="fstat-no" title="function not covered" ></span>dr</span>awCaret(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >this.getCaretPosition(t,i,s);<span class="cstat-no" title="statement not covered" ></span>e.lineTo(n.x1,n.y1),e.lineTo(n.x2,n.y2),e.lineTo(n.x3,n.y3)}<span class="fstat-no" title="function not covered" ></span>ge</span>tCaretPosition(t,e,i){const{xAlign:s,yAlign:n}=<span class="cstat-no" title="statement not covered" >this,</span>{caretSize:o,cornerRadius:r}=<span class="cstat-no" title="statement not covered" >i,</span>{topLeft:a,topRight:h,bottomLeft:l,bottomRight:c}=<span class="cstat-no" title="statement not covered" >Pe(r),</span>{x:d,y:u}=<span class="cstat-no" title="statement not covered" >t,</span>{width:f,height:g}=<span class="cstat-no" title="statement not covered" >e;</span>let p,x,m,b,_,y;<span class="cstat-no" title="statement not covered" >return"center"===n?(_=u+g/2,"left"===s?(p=d,x=p-o,b=_+o,y=_-o):(p=d+f,x=p+o,b=_-o,y=_+o),m=p):(x="left"===s?d+Math.max(a,l)+o:"right"===s?d+f-Math.max(h,c)-o:this.caretX,"top"===n?(b=u,_=b-o,p=x-o,m=x+o):(b=u+g,_=b+o,p=x+o,m=x-o),y=b),{x1:p,x2:x,x3:m,y1:b,y2:_,y3:y}}<span class="fstat-no" title="function not covered" ></span>dr</span>awTitle(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.title,</span>n=<span class="cstat-no" title="statement not covered" >s.length;</span>let o,r,a;<span class="cstat-no" title="statement not covered" >if(n){const h=<span class="cstat-no" title="statement not covered" >ui(i.rtl,this.x,this.width);<span class="cstat-no" title="statement not covered" ></span>for(t.x=Do(this,i.titleAlign,i),e.textAlign=h.textAlign(i.titleAlign),e.textBaseline="middle",o=Ae(i.titleFont),r=i.titleSpacing,e.fillStyle=i.titleColor,e.font=o.string,a=0;a&lt;n;++a)<span class="cstat-no" title="statement not covered" >e.fillText(s[a],h.x(t.x),t.y+o.lineHeight/2),t.y+=o.lineHeight+r,a+1===n&amp;&amp;(t.y+=i.titleMarginBottom-r)}</span></span>}<span class="fstat-no" title="function not covered" ></span>_d</span>rawColorBox(t,e,i,s,n){const o=<span class="cstat-no" title="statement not covered" >this.labelColors[i],</span>r=<span class="cstat-no" title="statement not covered" >this.labelPointStyles[i],</span>{boxHeight:a,boxWidth:h}=<span class="cstat-no" title="statement not covered" >n,</span>l=<span class="cstat-no" title="statement not covered" >Ae(n.bodyFont),</span>c=<span class="cstat-no" title="statement not covered" >Do(this,"left",n),</span>d=<span class="cstat-no" title="statement not covered" >s.x(c),</span>u=<span class="cstat-no" title="statement not covered" >a&lt;l.lineHeight?(l.lineHeight-a)/2:0,</span>f=<span class="cstat-no" title="statement not covered" >e.y+u;<span class="cstat-no" title="statement not covered" ></span>if(n.usePointStyle){const e=<span class="cstat-no" title="statement not covered" >{radius:Math.min(h,a)/2,pointStyle:r.pointStyle,rotation:r.rotation,borderWidth:1},</span>i=<span class="cstat-no" title="statement not covered" >s.leftForLtr(d,h)+h/2,</span>l=<span class="cstat-no" title="statement not covered" >f+a/2;<span class="cstat-no" title="statement not covered" ></span>t.strokeStyle=n.multiKeyBackground,t.fillStyle=n.multiKeyBackground,ce(t,e,i,l),t.strokeStyle=o.borderColor,t.fillStyle=o.backgroundColor,ce(t,e,i,l)}</span>else{<span class="cstat-no" title="statement not covered" >t.lineWidth=H(o.borderWidth)?Math.max(...Object.values(o.borderWidth)):o.borderWidth||1,t.strokeStyle=o.borderColor,t.setLineDash(o.borderDash||[]),t.lineDashOffset=o.borderDashOffset||0;c</span>onst e=<span class="cstat-no" title="statement not covered" >s.leftForLtr(d,h),</span>i=<span class="cstat-no" title="statement not covered" >s.leftForLtr(s.xPlus(d,1),h-2),</span>r=<span class="cstat-no" title="statement not covered" >Pe(o.borderRadius);<span class="cstat-no" title="statement not covered" ></span>Object.values(r).some((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >0!==t)</span>)?(t.beginPath(),t.fillStyle=n.multiKeyBackground,ye(t,{x:e,y:f,w:h,h:a,radius:r}),t.fill(),t.stroke(),t.fillStyle=o.backgroundColor,t.beginPath(),ye(t,{x:i,y:f+1,w:h-2,h:a-2,radius:r}),t.fill()):(t.fillStyle=n.multiKeyBackground,t.fillRect(e,f,h,a),t.strokeRect(e,f,h,a),t.fillStyle=o.backgroundColor,t.fillRect(i,f+1,h-2,a-2))}<span class="cstat-no" title="statement not covered" ></span>t</span>.fillStyle=this.labelTextColors[i]}<span class="fstat-no" title="function not covered" ></span>dr</span>awBody(t,e,i){const{body:s}=<span class="cstat-no" title="statement not covered" >this,</span>{bodySpacing:n,bodyAlign:o,displayColors:r,boxHeight:a,boxWidth:h,boxPadding:l}=<span class="cstat-no" title="statement not covered" >i,</span>c=<span class="cstat-no" title="statement not covered" >Ae(i.bodyFont);</span>let d=<span class="cstat-no" title="statement not covered" >c.lineHeight,</span>u=<span class="cstat-no" title="statement not covered" >0;</span>const f=<span class="cstat-no" title="statement not covered" >ui(i.rtl,this.x,this.width),</span>g=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >e.fillText(i,f.x(t.x+u),t.y+d/2),t.y+=d+n}</span>,</span>p=<span class="cstat-no" title="statement not covered" >f.textAlign(o);</span>let x,m,b,_,y,v,w;<span class="cstat-no" title="statement not covered" >for(e.textAlign=o,e.textBaseline="middle",e.font=c.string,t.x=Do(this,p,i),e.fillStyle=i.bodyColor,U(this.beforeBody,g),u=r&amp;&amp;"right"!==p?"center"===o?h/2+l:h+2+l:0,_=0,v=s.length;_&lt;v;++_){<span class="cstat-no" title="statement not covered" >for(x=s[_],m=this.labelTextColors[_],e.fillStyle=m,U(x.before,g),b=x.lines,r&amp;&amp;b.length&amp;&amp;(this._drawColorBox(e,t,_,f,i),d=Math.max(c.lineHeight,a)),y=0,w=b.length;y&lt;w;++y)<span class="cstat-no" title="statement not covered" >g(b[y]),d=c.lineHeight;<span class="cstat-no" title="statement not covered" >U</span></span>(x.after,g)}<span class="cstat-no" title="statement not covered" ></span>u</span>=0,d=c.lineHeight,U(this.afterBody,g),t.y-=n}<span class="fstat-no" title="function not covered" ></span>dr</span>awFooter(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.footer,</span>n=<span class="cstat-no" title="statement not covered" >s.length;</span>let o,r;<span class="cstat-no" title="statement not covered" >if(n){const a=<span class="cstat-no" title="statement not covered" >ui(i.rtl,this.x,this.width);<span class="cstat-no" title="statement not covered" ></span>for(t.x=Do(this,i.footerAlign,i),t.y+=i.footerMarginTop,e.textAlign=a.textAlign(i.footerAlign),e.textBaseline="middle",o=Ae(i.footerFont),e.fillStyle=i.footerColor,e.font=o.string,r=0;r&lt;n;++r)<span class="cstat-no" title="statement not covered" >e.fillText(s[r],a.x(t.x),t.y+o.lineHeight/2),t.y+=o.lineHeight+i.footerSpacing}</span></span>}<span class="fstat-no" title="function not covered" ></span>dr</span>awBackground(t,e,i,s){const{xAlign:n,yAlign:o}=<span class="cstat-no" title="statement not covered" >this,</span>{x:r,y:a}=<span class="cstat-no" title="statement not covered" >t,</span>{width:h,height:l}=<span class="cstat-no" title="statement not covered" >i,</span>{topLeft:c,topRight:d,bottomLeft:u,bottomRight:f}=<span class="cstat-no" title="statement not covered" >Pe(s.cornerRadius);<span class="cstat-no" title="statement not covered" ></span>e.fillStyle=s.backgroundColor,e.strokeStyle=s.borderColor,e.lineWidth=s.borderWidth,e.beginPath(),e.moveTo(r+c,a),"top"===o&amp;&amp;this.drawCaret(t,e,i,s),e.lineTo(r+h-d,a),e.quadraticCurveTo(r+h,a,r+h,a+d),"center"===o&amp;&amp;"right"===n&amp;&amp;this.drawCaret(t,e,i,s),e.lineTo(r+h,a+l-f),e.quadraticCurveTo(r+h,a+l,r+h-f,a+l),"bottom"===o&amp;&amp;this.drawCaret(t,e,i,s),e.lineTo(r+u,a+l),e.quadraticCurveTo(r,a+l,r,a+l-u),"center"===o&amp;&amp;"left"===n&amp;&amp;this.drawCaret(t,e,i,s),e.lineTo(r,a+c),e.quadraticCurveTo(r,a,r+c,a),e.closePath(),e.fill(),s.borderWidth&gt;0&amp;&amp;e.stroke()}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateAnimationTarget(t){const e=<span class="cstat-no" title="statement not covered" >this.chart,</span>i=<span class="cstat-no" title="statement not covered" >this.$animations,</span>s=<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.x,</span>n=<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.y;<span class="cstat-no" title="statement not covered" ></span>if(s||n){const i=<span class="cstat-no" title="statement not covered" >_o[t.position].call(this,this._active,this._eventPosition);<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >this._size=Mo(this,t),</span>r=<span class="cstat-no" title="statement not covered" >Object.assign({},i,this._size),</span>a=<span class="cstat-no" title="statement not covered" >So(e,t,r),</span>h=<span class="cstat-no" title="statement not covered" >Po(t,r,a,e);<span class="cstat-no" title="statement not covered" ></span>s._to===h.x&amp;&amp;n._to===h.y||(this.xAlign=a.xAlign,this.yAlign=a.yAlign,this.width=o.width,this.height=o.height,this.caretX=i.x,this.caretY=i.y,this._resolveAnimations().update(this,h))}</span>}<span class="fstat-no" title="function not covered" ></span>_w</span>illRender(){<span class="cstat-no" title="statement not covered" >return!!this.opacity}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(t){const e=<span class="cstat-no" title="statement not covered" >this.options.setContext(this.getContext());</span>let i=<span class="cstat-no" title="statement not covered" >this.opacity;<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his._updateAnimationTarget(e);c</span>onst s=<span class="cstat-no" title="statement not covered" >{width:this.width,height:this.height},</span>n=<span class="cstat-no" title="statement not covered" >{x:this.x,y:this.y};<span class="cstat-no" title="statement not covered" ></span>i=Math.abs(i)&lt;.001?0:i;c</span>onst o=<span class="cstat-no" title="statement not covered" >De(e.padding),</span>r=<span class="cstat-no" title="statement not covered" >this.title.length||this.beforeBody.length||this.body.length||this.afterBody.length||this.footer.length;<span class="cstat-no" title="statement not covered" ></span>e.enabled&amp;&amp;r&amp;&amp;(t.save(),t.globalAlpha=i,this.drawBackground(n,t,s,e),fi(t,e.textDirection),n.y+=o.top,this.drawTitle(n,t,e),this.drawBody(n,t,e),this.drawFooter(n,t,e),gi(t,e.textDirection),t.restore())}<span class="fstat-no" title="function not covered" ></span>ge</span>tActiveElements(){<span class="cstat-no" title="statement not covered" >return this._active||[]}<span class="fstat-no" title="function not covered" ></span>se</span>tActiveElements(t,e){const i=<span class="cstat-no" title="statement not covered" >this._active,</span>s=<span class="cstat-no" title="statement not covered" >t.map((<span class="fstat-no" title="function not covered" >({</span>datasetIndex:t,index:e})=&gt;{const i=<span class="cstat-no" title="statement not covered" >this.chart.getDatasetMeta(t);<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >throw new Error("Cannot find a dataset at index "+t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{datasetIndex:t,element:i.data[e],index:e}}</span>)),</span>n=<span class="cstat-no" title="statement not covered" >!X(i,s),</span>o=<span class="cstat-no" title="statement not covered" >this._positionChanged(s,e);<span class="cstat-no" title="statement not covered" ></span>(n||o)&amp;&amp;(this._active=s,this._eventPosition=e,this._ignoreReplayEvents=!0,this.update(!0))}<span class="fstat-no" title="function not covered" ></span>ha</span>ndleEvent(t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>{<span class="cstat-no" title="statement not covered" >if(e&amp;&amp;this._ignoreReplayEvents)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >t</span></span>his._ignoreReplayEvents=!1;c</span>onst s=<span class="cstat-no" title="statement not covered" >this.options,</span>n=<span class="cstat-no" title="statement not covered" >this._active||[],</span>o=<span class="cstat-no" title="statement not covered" >this._getActiveElements(t,n,e,i),</span>r=<span class="cstat-no" title="statement not covered" >this._positionChanged(o,t),</span>a=<span class="cstat-no" title="statement not covered" >e||!X(o,n)||r;<span class="cstat-no" title="statement not covered" ></span>return a&amp;&amp;(this._active=o,(s.enabled||s.external)&amp;&amp;(this._eventPosition={x:t.x,y:t.y},this.update(!0,e))),a}<span class="fstat-no" title="function not covered" ></span>_g</span>etActiveElements(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if("mouseout"===t.type)<span class="cstat-no" title="statement not covered" >return[];<span class="cstat-no" title="statement not covered" >i</span></span>f(!s)<span class="cstat-no" title="statement not covered" >return e.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this.chart.data.datasets[t.datasetIndex]&amp;&amp;void 0!==this.chart.getDatasetMeta(t.datasetIndex).controller.getParsed(t.index))</span>);c</span></span>onst o=<span class="cstat-no" title="statement not covered" >this.chart.getElementsAtEventForMode(t,n.mode,n,i);<span class="cstat-no" title="statement not covered" ></span>return n.reverse&amp;&amp;o.reverse(),o}<span class="fstat-no" title="function not covered" ></span>_p</span>ositionChanged(t,e){const{caretX:i,caretY:s,options:n}=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >_o[n.position].call(this,t,e);<span class="cstat-no" title="statement not covered" ></span>return!1!==o&amp;&amp;(i!==o.x||s!==o.y)}</span>}var Io=<span class="cstat-no" title="statement not covered" >{id:"tooltip",_element:Ro,positioners:_o,<span class="fstat-no" title="function not covered" >af</span>terInit(t,e,i){<span class="cstat-no" title="statement not covered" >i&amp;&amp;(t.tooltip=new Ro({chart:t,options:i}))}</span>,<span class="fstat-no" title="function not covered" >be</span>foreUpdate(t,e,i){<span class="cstat-no" title="statement not covered" >t.tooltip&amp;&amp;t.tooltip.initialize(i)}</span>,<span class="fstat-no" title="function not covered" >re</span>set(t,e,i){<span class="cstat-no" title="statement not covered" >t.tooltip&amp;&amp;t.tooltip.initialize(i)}</span>,<span class="fstat-no" title="function not covered" >af</span>terDraw(t){const e=<span class="cstat-no" title="statement not covered" >t.tooltip;<span class="cstat-no" title="statement not covered" ></span>if(e&amp;&amp;e._willRender()){const i=<span class="cstat-no" title="statement not covered" >{tooltip:e};<span class="cstat-no" title="statement not covered" ></span>if(!1===t.notifyPlugins("beforeTooltipDraw",{...i,cancelable:!0}))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >e</span></span>.draw(t.ctx),t.notifyPlugins("afterTooltipDraw",i)}</span>}</span>,<span class="fstat-no" title="function not covered" >af</span>terEvent(t,e){<span class="cstat-no" title="statement not covered" >if(t.tooltip){const i=<span class="cstat-no" title="statement not covered" >e.replay;<span class="cstat-no" title="statement not covered" ></span>t.tooltip.handleEvent(e.event,i,e.inChartArea)&amp;&amp;(e.changed=!0)}</span>}</span>,defaults:{enabled:!0,external:null,position:"average",backgroundColor:"rgba(0,0,0,0.8)",titleColor:"#fff",titleFont:{weight:"bold"},titleSpacing:2,titleMarginBottom:6,titleAlign:"left",bodyColor:"#fff",bodySpacing:2,bodyFont:{},bodyAlign:"left",footerColor:"#fff",footerSpacing:2,footerMarginTop:6,footerFont:{weight:"bold"},footerAlign:"left",padding:6,caretPadding:2,caretSize:5,cornerRadius:6,boxHeight:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e.bodyFont.size,</span>boxWidth:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e.bodyFont.size,</span>multiKeyBackground:"#fff",displayColors:!0,boxPadding:0,borderColor:"rgba(0,0,0,0)",borderWidth:0,animation:{duration:400,easing:"easeOutQuart"},animations:{numbers:{type:"number",properties:["x","y","width","height","caretX","caretY"]},opacity:{easing:"linear",duration:200}},callbacks:Co},defaultRoutes:{bodyFont:"font",footerFont:"font",titleFont:"font"},descriptors:{_scriptable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"filter"!==t&amp;&amp;"itemSort"!==t&amp;&amp;"external"!==t,</span>_indexable:!1,callbacks:{_scriptable:!1,_indexable:!1},animation:{_fallback:!1},animations:{_fallback:"animation"}},additionalOptionScopes:["interaction"]};</span>function <span class="fstat-no" title="function not covered" >Eo(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >t.indexOf(e);<span class="cstat-no" title="statement not covered" ></span>if(-1===n)<span class="cstat-no" title="statement not covered" >return(<span class="fstat-no" title="function not covered" >(t</span>,e,i,s)=&gt;(<span class="cstat-no" title="statement not covered" >"string"===typeof e?(i=t.push(e)-1,s.unshift({index:i,label:e})):isNaN(e)&amp;&amp;(i=null),i)</span>)(t,e,i,s);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n!==t.lastIndexOf(e)?i:n}</span>function <span class="fstat-no" title="function not covered" >Lo(</span>t){const e=<span class="cstat-no" title="statement not covered" >this.getLabels();<span class="cstat-no" title="statement not covered" ></span>return t&gt;=0&amp;&amp;t&lt;e.length?e[t]:t}</span>class zo extends Us{static id=<span class="cstat-no" title="statement not covered" >"category";</span>static defaults=<span class="cstat-no" title="statement not covered" >{ticks:{callback:Lo}};<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t),this._startValue=void 0,this._valueRange=0,this._addedLabels=[]}<span class="fstat-no" title="function not covered" ></span>in</span>it(t){const e=<span class="cstat-no" title="statement not covered" >this._addedLabels;<span class="cstat-no" title="statement not covered" ></span>if(e.length){const t=<span class="cstat-no" title="statement not covered" >this.getLabels();<span class="cstat-no" title="statement not covered" ></span>for(const{index:i,label:s}of e)<span class="cstat-no" title="statement not covered" >t[i]===s&amp;&amp;t.splice(i,1);<span class="cstat-no" title="statement not covered" >t</span></span>his._addedLabels=[]}<span class="cstat-no" title="statement not covered" ></span>s</span>uper.init(t)}<span class="fstat-no" title="function not covered" ></span>pa</span>rse(t,e){<span class="cstat-no" title="statement not covered" >if(B(t))<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >this.getLabels();<span class="cstat-no" title="statement not covered" ></span>return(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >null===t?null:At(Math.round(t),0,e))</span>(e=isFinite(e)&amp;&amp;i[e]===t?e:Eo(i,t,N(e,t),this._addedLabels),i.length-1)}<span class="fstat-no" title="function not covered" ></span>de</span>termineDataLimits(){const{minDefined:t,maxDefined:e}=<span class="cstat-no" title="statement not covered" >this.getUserBounds();</span>let{min:i,max:s}=<span class="cstat-no" title="statement not covered" >this.getMinMax(!0);<span class="cstat-no" title="statement not covered" ></span>"ticks"===this.options.bounds&amp;&amp;(t||(i=0),e||(s=this.getLabels().length-1)),this.min=i,this.max=s}<span class="fstat-no" title="function not covered" ></span>bu</span>ildTicks(){const t=<span class="cstat-no" title="statement not covered" >this.min,</span>e=<span class="cstat-no" title="statement not covered" >this.max,</span>i=<span class="cstat-no" title="statement not covered" >this.options.offset,</span>s=<span class="cstat-no" title="statement not covered" >[];</span>let n=<span class="cstat-no" title="statement not covered" >this.getLabels();<span class="cstat-no" title="statement not covered" ></span>n=0===t&amp;&amp;e===n.length-1?n:n.slice(t,e+1),this._valueRange=Math.max(n.length-(i?0:1),1),this._startValue=this.min-(i?.5:0);<span class="cstat-no" title="statement not covered" >f</span>or(let o=<span class="cstat-no" title="statement not covered" >t;</span>o&lt;=e;o++)<span class="cstat-no" title="statement not covered" >s.push({value:o});<span class="cstat-no" title="statement not covered" >r</span></span>eturn s}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelForValue(t){<span class="cstat-no" title="statement not covered" >return Lo.call(this,t)}<span class="fstat-no" title="function not covered" ></span>co</span>nfigure(){<span class="cstat-no" title="statement not covered" >super.configure(),this.isHorizontal()||(this._reversePixels=!this._reversePixels)}<span class="fstat-no" title="function not covered" ></span>ge</span>tPixelForValue(t){<span class="cstat-no" title="statement not covered" >return"number"!==typeof t&amp;&amp;(t=this.parse(t)),null===t?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}<span class="fstat-no" title="function not covered" ></span>ge</span>tPixelForTick(t){const e=<span class="cstat-no" title="statement not covered" >this.ticks;<span class="cstat-no" title="statement not covered" ></span>return t&lt;0||t&gt;e.length-1?null:this.getPixelForValue(e[t].value)}<span class="fstat-no" title="function not covered" ></span>ge</span>tValueForPixel(t){<span class="cstat-no" title="statement not covered" >return Math.round(this._startValue+this.getDecimalForPixel(t)*this._valueRange)}<span class="fstat-no" title="function not covered" ></span>ge</span>tBasePixel(){<span class="cstat-no" title="statement not covered" >return this.bottom}</span>}function <span class="fstat-no" title="function not covered" >Fo(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >[],</span>{bounds:s,step:n,min:o,max:r,precision:a,count:h,maxTicks:l,maxDigits:c,includeBounds:d}=<span class="cstat-no" title="statement not covered" >t,</span>u=<span class="cstat-no" title="statement not covered" >n||1,</span>f=<span class="cstat-no" title="statement not covered" >l-1,</span>{min:g,max:p}=<span class="cstat-no" title="statement not covered" >e,</span>x=<span class="cstat-no" title="statement not covered" >!B(o),</span>m=<span class="cstat-no" title="statement not covered" >!B(r),</span>b=<span class="cstat-no" title="statement not covered" >!B(h),</span>_=<span class="cstat-no" title="statement not covered" >(p-g)/(c+1);</span>let y,v,w,M,k=<span class="cstat-no" title="statement not covered" >mt((p-g)/f/u)*u;<span class="cstat-no" title="statement not covered" ></span>if(k&lt;1e-14&amp;&amp;!x&amp;&amp;!m)<span class="cstat-no" title="statement not covered" >return[{value:g},{value:p}];<span class="cstat-no" title="statement not covered" >M</span></span>=Math.ceil(p/k)-Math.floor(g/k),M&gt;f&amp;&amp;(k=mt(M*k/f/u)*u),B(a)||(y=Math.pow(10,a),k=Math.ceil(k*y)/y),"ticks"===s?(v=Math.floor(g/k)*k,w=Math.ceil(p/k)*k):(v=g,w=p),x&amp;&amp;m&amp;&amp;n&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >Math.round(t);<span class="cstat-no" title="statement not covered" ></span>return i-e&lt;=t&amp;&amp;i+e&gt;=t}</span>((r-o)/n,k/1e3)?(M=Math.round(Math.min((r-o)/k,l)),k=(r-o)/M,v=o,w=r):b?(v=x?o:v,w=m?r:w,M=h-1,k=(w-v)/M):(M=(w-v)/k,M=xt(M,Math.round(M),k/1e3)?Math.round(M):Math.ceil(M));c</span>onst S=<span class="cstat-no" title="statement not covered" >Math.max(wt(k),wt(v));<span class="cstat-no" title="statement not covered" ></span>y=Math.pow(10,B(a)?S:a),v=Math.round(v*y)/y,w=Math.round(w*y)/y;l</span>et P=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(x&amp;&amp;(d&amp;&amp;v!==o?(i.push({value:o}),v&lt;o&amp;&amp;P++,xt(Math.round((v+P*k)*y)/y,o,Bo(o,_,t))&amp;&amp;P++):v&lt;o&amp;&amp;P++);P&lt;M;++P){const t=<span class="cstat-no" title="statement not covered" >Math.round((v+P*k)*y)/y;<span class="cstat-no" title="statement not covered" ></span>if(m&amp;&amp;t&gt;r)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span></span>.push({value:t})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn m&amp;&amp;d&amp;&amp;w!==r?i.length&amp;&amp;xt(i[i.length-1].value,r,Bo(r,_,t))?i[i.length-1].value=r:i.push({value:r}):m&amp;&amp;w!==r||i.push({value:w}),i}</span>function <span class="fstat-no" title="function not covered" >Bo(</span>t,e,{horizontal:i,minRotation:s}){const n=<span class="cstat-no" title="statement not covered" >yt(s),</span>o=<span class="cstat-no" title="statement not covered" >(i?Math.sin(n):Math.cos(n))||.001,</span>r=<span class="cstat-no" title="statement not covered" >.75*e*(""+t).length;<span class="cstat-no" title="statement not covered" ></span>return Math.min(e/o,r)}</span>class Wo extends Us{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t),this.start=void 0,this.end=void 0,this._startValue=void 0,this._endValue=void 0,this._valueRange=0}<span class="fstat-no" title="function not covered" ></span>pa</span>rse(t,e){<span class="cstat-no" title="statement not covered" >return B(t)||("number"===typeof t||t instanceof Number)&amp;&amp;!isFinite(+t)?null:+t}<span class="fstat-no" title="function not covered" ></span>ha</span>ndleTickRangeOptions(){const{beginAtZero:t}=<span class="cstat-no" title="statement not covered" >this.options,</span>{minDefined:e,maxDefined:i}=<span class="cstat-no" title="statement not covered" >this.getUserBounds();</span>let{min:s,max:n}=<span class="cstat-no" title="statement not covered" >this;</span>const o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >s=e?s:t,</span></span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >n=i?n:t;<span class="cstat-no" title="statement not covered" ></span></span>if(t){const t=<span class="cstat-no" title="statement not covered" >pt(s),</span>e=<span class="cstat-no" title="statement not covered" >pt(n);<span class="cstat-no" title="statement not covered" ></span>t&lt;0&amp;&amp;e&lt;0?r(0):t&gt;0&amp;&amp;e&gt;0&amp;&amp;o(0)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(s===n){let e=<span class="cstat-no" title="statement not covered" >0===n?1:Math.abs(.05*n);<span class="cstat-no" title="statement not covered" ></span>r(n+e),t||o(s-e)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.min=s,this.max=n}<span class="fstat-no" title="function not covered" ></span>ge</span>tTickLimit(){const t=<span class="cstat-no" title="statement not covered" >this.options.ticks;</span>let e,{maxTicksLimit:i,stepSize:s}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return s?(e=Math.ceil(this.max/s)-Math.floor(this.min/s)+1,e&gt;1e3&amp;&amp;(console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${e} ticks. Limiting to 1000.`),e=1e3)):(e=this.computeTickLimit(),i=i||11),i&amp;&amp;(e=Math.min(i,e)),e}<span class="fstat-no" title="function not covered" ></span>co</span>mputeTickLimit(){<span class="cstat-no" title="statement not covered" >return Number.POSITIVE_INFINITY}<span class="fstat-no" title="function not covered" ></span>bu</span>ildTicks(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >t.ticks;</span>let i=<span class="cstat-no" title="statement not covered" >this.getTickLimit();<span class="cstat-no" title="statement not covered" ></span>i=Math.max(2,i);c</span>onst s=<span class="cstat-no" title="statement not covered" >Fo({maxTicks:i,bounds:t.bounds,min:t.min,max:t.max,precision:e.precision,step:e.stepSize,count:e.count,maxDigits:this._maxDigits(),horizontal:this.isHorizontal(),minRotation:e.minRotation||0,includeBounds:!1!==e.includeBounds},this._range||this);<span class="cstat-no" title="statement not covered" ></span>return"ticks"===t.bounds&amp;&amp;_t(s,this,"value"),t.reverse?(s.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),s}<span class="fstat-no" title="function not covered" ></span>co</span>nfigure(){const t=<span class="cstat-no" title="statement not covered" >this.ticks;</span>let e=<span class="cstat-no" title="statement not covered" >this.min,</span>i=<span class="cstat-no" title="statement not covered" >this.max;<span class="cstat-no" title="statement not covered" ></span>if(super.configure(),this.options.offset&amp;&amp;t.length){const s=<span class="cstat-no" title="statement not covered" >(i-e)/Math.max(t.length-1,1)/2;<span class="cstat-no" title="statement not covered" ></span>e-=s,i+=s}<span class="cstat-no" title="statement not covered" ></span>t</span>his._startValue=e,this._endValue=i,this._valueRange=i-e}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelForValue(t){<span class="cstat-no" title="statement not covered" >return Zt(t,this.chart.options.locale,this.options.ticks.format)}</span>}class Ho extends Wo{static id=<span class="cstat-no" title="statement not covered" >"linear";</span>static defaults=<span class="cstat-no" title="statement not covered" >{ticks:{callback:te.formatters.numeric}};<span class="fstat-no" title="function not covered" ></span>de</span>termineDataLimits(){const{min:t,max:e}=<span class="cstat-no" title="statement not covered" >this.getMinMax(!0);<span class="cstat-no" title="statement not covered" ></span>this.min=V(t)?t:0,this.max=V(e)?e:1,this.handleTickRangeOptions()}<span class="fstat-no" title="function not covered" ></span>co</span>mputeTickLimit(){const t=<span class="cstat-no" title="statement not covered" >this.isHorizontal(),</span>e=<span class="cstat-no" title="statement not covered" >t?this.width:this.height,</span>i=<span class="cstat-no" title="statement not covered" >yt(this.options.ticks.minRotation),</span>s=<span class="cstat-no" title="statement not covered" >(t?Math.sin(i):Math.cos(i))||.001,</span>n=<span class="cstat-no" title="statement not covered" >this._resolveTickFontOptions(0);<span class="cstat-no" title="statement not covered" ></span>return Math.ceil(e/Math.min(40,n.lineHeight/s))}<span class="fstat-no" title="function not covered" ></span>ge</span>tPixelForValue(t){<span class="cstat-no" title="statement not covered" >return null===t?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}<span class="fstat-no" title="function not covered" ></span>ge</span>tValueForPixel(t){<span class="cstat-no" title="statement not covered" >return this._startValue+this.getDecimalForPixel(t)*this._valueRange}</span>}<span class="cstat-no" title="statement not covered" >te.formatters.logarithmic;<span class="cstat-no" title="statement not covered" >t</span>e.formatters.numeric}</span>,43223:<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >i.d(e,{$I:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >p,</span>$Q:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >g,</span>by:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >x,</span>x1:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >f}</span>);v</span>ar s=<span class="cstat-no" title="statement not covered" >i(30784),</span>n=<span class="cstat-no" title="statement not covered" >i(9885),</span>o=<span class="cstat-no" title="statement not covered" >i(622);</span>function <span class="fstat-no" title="function not covered" >r(</span>t,e){<span class="cstat-no" title="statement not covered" >"function"===typeof t?t(e):t&amp;&amp;(t.current=e)}</span>function <span class="fstat-no" title="function not covered" >a(</span>t,e){<span class="cstat-no" title="statement not covered" >t.labels=e}</span>function <span class="fstat-no" title="function not covered" >h(</span>t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >"label")</span>{const s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>t.datasets=e.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >t.datasets.find((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t[i]===e[i])</span>);<span class="cstat-no" title="statement not covered" ></span>return n&amp;&amp;e.data&amp;&amp;!s.includes(n)?(s.push(n),Object.assign(n,e),n):{...e}}</span>))}</span>function <span class="fstat-no" title="function not covered" >l(</span>t,e=<span class="branch-0 cbranch-no" title="branch not covered" >"label")</span>{const i=<span class="cstat-no" title="statement not covered" >{labels:[],datasets:[]};<span class="cstat-no" title="statement not covered" ></span>return a(i,t.labels),h(i,t.datasets,e),i}</span>function <span class="fstat-no" title="function not covered" >c(</span>t,e){const{height:i=<span class="branch-0 cbranch-no" title="branch not covered" >150,</span>width:c=<span class="branch-0 cbranch-no" title="branch not covered" >300,</span>redraw:d=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>datasetIdKey:u,type:f,data:g,options:p,plugins:x=<span class="branch-0 cbranch-no" title="branch not covered" >[],</span>fallbackContent:m,updateMode:b,..._}=<span class="cstat-no" title="statement not covered" >t,</span>y=<span class="cstat-no" title="statement not covered" >(0,n.useRef)(null),</span>v=<span class="cstat-no" title="statement not covered" >(0,n.useRef)(null),</span>w=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >y.current&amp;&amp;(v.current=new o.kL(y.current,{type:f,data:l(g,u),options:p&amp;&amp;{...p},plugins:x}),r(e,v.current))}</span>,</span>M=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >r(e,null),v.current&amp;&amp;(v.current.destroy(),v.current=null)}</span>;<span class="cstat-no" title="statement not covered" ></span>return(0,n.useEffect)((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >!d&amp;&amp;v.current&amp;&amp;p&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >t.options;<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;e&amp;&amp;Object.assign(i,e)}</span>(v.current,p)}</span>),[d,p]),(0,n.useEffect)((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >!d&amp;&amp;v.current&amp;&amp;a(v.current.config.data,g.labels)}</span>),[d,g.labels]),(0,n.useEffect)((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >!d&amp;&amp;v.current&amp;&amp;g.datasets&amp;&amp;h(v.current.config.data,g.datasets,u)}</span>),[d,g.datasets]),(0,n.useEffect)((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >v.current&amp;&amp;(d?(M(),setTimeout(w)):v.current.update(b))}</span>),[d,p,g.labels,g.datasets,b]),(0,n.useEffect)((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >v.current&amp;&amp;(M(),setTimeout(w))}</span>),[f]),(0,n.useEffect)((<span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >w(),<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >M())</span></span>),[]),(0,s.jsx)("canvas",{ref:y,role:"img",height:i,width:c,..._,children:m})}</span>const d=<span class="cstat-no" title="statement not covered" >(0,n.forwardRef)(c);</span>function <span class="fstat-no" title="function not covered" >u(</span>t,e){<span class="cstat-no" title="statement not covered" >return o.kL.register(e),(0,n.forwardRef)((<span class="fstat-no" title="function not covered" >(e</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >(0,s.jsx)(d,{...e,ref:i,type:t}))</span>)}</span>const f=<span class="cstat-no" title="statement not covered" >u("line",o.ST),</span>g=<span class="cstat-no" title="statement not covered" >u("bar",o.vn),</span>p=<span class="cstat-no" title="statement not covered" >u("doughnut",o.jI),</span>x=<span class="cstat-no" title="statement not covered" >u("pie",o.tt)}</span>};</span></pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2025-11-10T08:05:28.828Z
            </div>
        <script src="../../../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../../../sorter.js"></script>
        <script src="../../../../../block-navigation.js"></script>
    </body>
</html>
    