
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for novacron/frontend/.next/server/chunks/1920.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../../../index.html">All files</a> / <a href="index.html">novacron/frontend/.next/server/chunks</a> 1920.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/339</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/268</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/69</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/1</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">"use strict";<span class="cstat-no" title="statement not covered" >exports.id=1920,exports.ids=[1920],exports.modules={21920:<span class="fstat-no" title="function not covered" >(e</span>,t,s)=&gt;{<span class="cstat-no" title="statement not covered" >s.r(t),s.d(t,{NetworkTopology:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >f}</span>);v</span>ar i=<span class="cstat-no" title="statement not covered" >s(30784),</span>n=<span class="cstat-no" title="statement not covered" >s(9885),</span>r=<span class="cstat-no" title="statement not covered" >s.n(n),</span>a=<span class="cstat-no" title="statement not covered" >s(97040),</span>l=<span class="cstat-no" title="statement not covered" >s(7950),</span>c=<span class="cstat-no" title="statement not covered" >s(17133),</span>o=<span class="cstat-no" title="statement not covered" >s(45304),</span>h=<span class="cstat-no" title="statement not covered" >s(63712),</span>d=<span class="cstat-no" title="statement not covered" >s(86078),</span>x=<span class="cstat-no" title="statement not covered" >s(89815),</span>u=<span class="cstat-no" title="statement not covered" >s(83475);</span>const f=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>data:e,title:t=<span class="branch-0 cbranch-no" title="branch not covered" >"Network Topology",</span>description:s,height:f=<span class="branch-0 cbranch-no" title="branch not covered" >400,</span>showDistributed:m=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>showBandwidth:g=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>showPerformanceMetrics:y=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>autoRefresh:p=<span class="branch-0 cbranch-no" title="branch not covered" >!0,</span>refreshInterval:v=<span class="branch-0 cbranch-no" title="branch not covered" >5e3,</span>onNodeClick:w,onEdgeClick:M,onClusterClick:b})=&gt;{const j=<span class="cstat-no" title="statement not covered" >(0,n.useRef)(null),</span>N=<span class="cstat-no" title="statement not covered" >(0,n.useRef)(),</span>[k,E]=<span class="cstat-no" title="statement not covered" >r().useState("force"),</span>[S,C]=<span class="cstat-no" title="statement not covered" >r().useState(null),</span>[P,I]=<span class="cstat-no" title="statement not covered" >r().useState(null),</span>[L,z]=<span class="cstat-no" title="statement not covered" >r().useState(!0),</span>[W,D]=<span class="cstat-no" title="statement not covered" >r().useState("medium"),</span>[H,O]=<span class="cstat-no" title="statement not covered" >r().useState(new Set),</span>[T,A]=<span class="cstat-no" title="statement not covered" >r().useState(m),</span>[B,F]=<span class="cstat-no" title="statement not covered" >r().useState(g),</span>[R,q]=<span class="cstat-no" title="statement not covered" >r().useState(y);<span class="cstat-no" title="statement not covered" ></span>(0,n.useEffect)((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >A(m))</span>,[m]),(0,n.useEffect)((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >F(g))</span>,[g]),(0,n.useEffect)((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >q(y))</span>,[y]);c</span>onst{data:Q,isConnected:$}=<span class="cstat-no" title="statement not covered" >T?(0,h.lt)():{data:null,isConnected:!1},</span>U=<span class="cstat-no" title="statement not covered" >r().useMemo((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Q&amp;&amp;T?Q:e||{nodes:[],edges:[],clusters:[]})</span>,[Q,e,T]);<span class="cstat-no" title="statement not covered" ></span>return(0,n.useEffect)((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(!j.current||!U.nodes.length)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >j.current,</span>t=<span class="cstat-no" title="statement not covered" >e.getContext("2d");<span class="cstat-no" title="statement not covered" ></span>if(!t)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{const s=<span class="cstat-no" title="statement not covered" >window.devicePixelRatio||1;<span class="cstat-no" title="statement not covered" ></span>e.width=Math.floor(e.clientWidth*s),e.height=Math.floor(e.clientHeight*s),e.style.width=e.clientWidth+"px",e.style.height=e.clientHeight+"px",t.scale(s,s)}</span>;<span class="cstat-no" title="statement not covered" ></span>window.addEventListener("resize",s),s();c</span>onst i=<span class="cstat-no" title="statement not covered" >new Map;<span class="cstat-no" title="statement not covered" ></span>(<span class="fstat-no" title="function not covered" >()</span>=&gt;{const t=<span class="cstat-no" title="statement not covered" >e.clientWidth,</span>s=<span class="cstat-no" title="statement not covered" >e.clientHeight;<span class="cstat-no" title="statement not covered" ></span>U.nodes.forEach((<span class="fstat-no" title="function not covered" >(e</span>,n)=&gt;{let r,a;<span class="cstat-no" title="statement not covered" >switch(k){case"circular":const i=<span class="cstat-no" title="statement not covered" >n/U.nodes.length*2*Math.PI,</span>l=<span class="cstat-no" title="statement not covered" >.3*Math.min(t,s);<span class="cstat-no" title="statement not covered" ></span>r=t/2+Math.cos(i)*l,a=s/2+Math.sin(i)*l;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"hierarchical":<span class="cstat-no" title="statement not covered" >new Map;l</span>et c=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>c="cluster"===e.type?0:"host"===e.type?1:"vm"===e.type?2:3;c</span>onst o=<span class="cstat-no" title="statement not covered" >U.nodes.filter((<span class="fstat-no" title="function not covered" >e=</span>&gt;{let t=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return t="cluster"===e.type?0:"host"===e.type?1:"vm"===e.type?2:3,t===c}</span>)),</span>h=<span class="cstat-no" title="statement not covered" >o.findIndex((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.id===e.id)</span>);<span class="cstat-no" title="statement not covered" ></span>r=t/(o.length+1)*(h+1),a=s/5*(c+1);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"geographic":const d=<span class="cstat-no" title="statement not covered" >{"us-east-1":{x:.8*t,y:.3*s},"us-west-2":{x:.2*t,y:.4*s},"eu-west-1":{x:.6*t,y:.2*s},"ap-southeast-1":{x:.9*t,y:.7*s}}[e.region];<span class="cstat-no" title="statement not covered" ></span>r=d?.x||Math.random()*t,a=d?.y||Math.random()*s;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"clustered":<span class="cstat-no" title="statement not covered" >if(e.clusterId&amp;&amp;U.clusters){const i=<span class="cstat-no" title="statement not covered" >U.clusters.find((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.id===e.clusterId)</span>);<span class="cstat-no" title="statement not covered" ></span>i?.bounds?(r=i.bounds.x+Math.random()*i.bounds.width,a=i.bounds.y+Math.random()*i.bounds.height):(r=Math.random()*t,a=Math.random()*s)}</span>else <span class="cstat-no" title="statement not covered" >r=Math.random()*t,a=Math.random()*s;<span class="cstat-no" title="statement not covered" >b</span></span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >r=Math.random()*t,a=Math.random()*s}<span class="cstat-no" title="statement not covered" ></span>i</span>.set(e.id,{x:r,y:a,vx:0,vy:0})}</span>))}</span>)();c</span>onst n=<span class="cstat-no" title="statement not covered" >{vm:"#4f46e5",host:"#0891b2",storage:"#7c3aed",network:"#2563eb",service:"#059669",cluster:"#f59e0b",federation:"#ec4899"},</span>r=<span class="cstat-no" title="statement not covered" >{healthy:"#10b981",warning:"#f59e0b",error:"#ef4444",unknown:"#6b7280"},</span>a=<span class="cstat-no" title="statement not covered" >{network:"rgba(37, 99, 235, 0.5)",storage:"rgba(124, 58, 237, 0.5)",dependency:"rgba(156, 163, 175, 0.5)",cluster:"rgba(245, 158, 11, 0.5)",federation:"rgba(236, 72, 153, 0.5)",migration:"rgba(34, 197, 94, 0.5)"},</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!B||!e.metrics?.bandwidth)<span class="cstat-no" title="statement not covered" >return 1;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >Math.max(1,Math.min(8,e.metrics.bandwidth/10));<span class="cstat-no" title="statement not covered" ></span>return e.metrics.utilization?t*(e.metrics.utilization/100):t}</span>,</span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!e.bounds||!T)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{x:s,y:i,width:n,height:r}=<span class="cstat-no" title="statement not covered" >e.bounds;<span class="cstat-no" title="statement not covered" ></span>t.strokeStyle="rgba(245, 158, 11, 0.3)",t.lineWidth=2,t.setLineDash([5,5]),t.strokeRect(s,i,n,r),t.setLineDash([]),t.font="12px sans-serif",t.fillStyle="#f59e0b",t.textAlign="left",t.fillText(`${e.name} (${e.region})`,s+5,i-5);c</span>onst a=<span class="cstat-no" title="statement not covered" >{healthy:"#10b981",degraded:"#f59e0b",error:"#ef4444"}[e.status];<span class="cstat-no" title="statement not covered" ></span>t.fillStyle=a,t.beginPath(),t.arc(s+n-10,i+10,5,0,2*Math.PI),t.fill()}</span>,</span>o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,s)=&gt;{const i=<span class="cstat-no" title="statement not covered" >"host"===e.type||"cluster"===e.type?15:10;<span class="cstat-no" title="statement not covered" ></span>t.beginPath(),t.arc(s.x,s.y,i,0,2*Math.PI),t.fillStyle=n[e.type],t.fill(),t.beginPath(),t.arc(s.x,s.y,i+3,0,2*Math.PI),t.strokeStyle=r[e.status],t.lineWidth=2,t.stroke(),L&amp;&amp;(t.font="10px sans-serif",t.fillStyle="#ffffff",t.textAlign="center",t.textBaseline="middle",t.fillText(e.name.substring(0,2),s.x,s.y),t.font="10px sans-serif",t.fillStyle="#374151",t.textAlign="center",t.textBaseline="top",t.fillText(e.name,s.x,s.y+i+5)),R&amp;&amp;e.metrics&amp;&amp;"low"!==W&amp;&amp;(t.font="9px sans-serif",t.fillStyle="#6b7280",t.textAlign="center",void 0!==e.metrics.cpuUsage&amp;&amp;t.fillText(`CPU: ${e.metrics.cpuUsage}%`,s.x,s.y+i+18),void 0!==e.metrics.memoryUsage&amp;&amp;"high"===W&amp;&amp;t.fillText(`Mem: ${e.metrics.memoryUsage}%`,s.x,s.y+i+28)),"migrating"===e.status&amp;&amp;(t.strokeStyle="rgba(34, 197, 94, 0.8)",t.lineWidth=3,t.setLineDash([2,2]),t.beginPath(),t.arc(s.x,s.y,i+6,0,2*Math.PI),t.stroke(),t.setLineDash([]))}</span>,</span>h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,s,i)=&gt;{const n=<span class="cstat-no" title="statement not covered" >B&amp;&amp;e.metrics?.utilization?(r=e.metrics.utilization)?r&gt;80?"rgba(239, 68, 68, 0.7)":r&gt;60?"rgba(245, 158, 11, 0.7)":"rgba(34, 197, 94, 0.7)":a.network:a[e.type];</span>var r;<span class="cstat-no" title="statement not covered" >if(t.beginPath(),t.moveTo(s.x,s.y),t.lineTo(i.x,i.y),t.strokeStyle=n,t.lineWidth=l(e),"dependency"===e.type?t.setLineDash([5,3]):t.setLineDash([]),t.stroke(),t.setLineDash([]),R&amp;&amp;e.metrics&amp;&amp;"low"!==W){const n=<span class="cstat-no" title="statement not covered" >(s.x+i.x)/2,</span>r=<span class="cstat-no" title="statement not covered" >(s.y+i.y)/2;<span class="cstat-no" title="statement not covered" ></span>t.font="9px sans-serif",t.fillStyle="#6b7280",t.textAlign="center",t.textBaseline="middle";c</span>onst a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(e.metrics.latency&amp;&amp;a.push(`${e.metrics.latency.toFixed(1)}ms`),B&amp;&amp;e.metrics.bandwidth&amp;&amp;a.push(`${e.metrics.bandwidth}Mbps`),e.metrics.utilization&amp;&amp;"high"===W&amp;&amp;a.push(`${e.metrics.utilization}%`),a.length&gt;0&amp;&amp;t.fillText(a.join(" | "),n,r-8),e.metrics.qos){const s=<span class="cstat-no" title="statement not covered" >{high:"#10b981",medium:"#f59e0b",low:"#ef4444"}[e.metrics.qos];<span class="cstat-no" title="statement not covered" ></span>t.fillStyle=s,t.beginPath(),t.arc(n,r+8,3,0,2*Math.PI),t.fill()}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e.animated||"migration"===e.type){const e=<span class="cstat-no" title="statement not covered" >t.createLinearGradient(s.x,s.y,i.x,i.y);<span class="cstat-no" title="statement not covered" ></span>e.addColorStop(0,"rgba(34, 197, 94, 0)"),e.addColorStop(.5,"rgba(34, 197, 94, 0.8)"),e.addColorStop(1,"rgba(34, 197, 94, 0)"),t.strokeStyle=e,t.lineWidth=2,t.stroke()}</span>}</span>;</span>class d{<span class="fstat-no" title="function not covered" >co</span>nstructor(e,t,s,i){<span class="cstat-no" title="statement not covered" >this.x=e,this.y=t,this.width=s,this.height=i,this.nodes=[],this.centerOfMass={x:0,y:0},this.totalMass=0,this.children=[]}<span class="fstat-no" title="function not covered" ></span>in</span>sert(e,t){<span class="cstat-no" title="statement not covered" >if(!this.contains(t.x,t.y))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(0===this.nodes.length&amp;&amp;0===this.children.length)<span class="cstat-no" title="statement not covered" >return this.nodes.push({node:e,position:t}),this.updateCenterOfMass(),!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(0===this.children.length){<span class="cstat-no" title="statement not covered" >this.subdivide();<span class="cstat-no" title="statement not covered" >f</span>or(const e of this.nodes)<span class="cstat-no" title="statement not covered" >for(const t of this.children)<span class="cstat-no" title="statement not covered" >if(t.insert(e.node,e.position))<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >t</span></span></span></span>his.nodes=[]}<span class="cstat-no" title="statement not covered" ></span>f</span>or(const s of this.children)<span class="cstat-no" title="statement not covered" >if(s.insert(e,t))<span class="cstat-no" title="statement not covered" >return this.updateCenterOfMass(),!0;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!1}<span class="fstat-no" title="function not covered" ></span>co</span>ntains(e,t){<span class="cstat-no" title="statement not covered" >return e&gt;=this.x&amp;&amp;e&lt;this.x+this.width&amp;&amp;t&gt;=this.y&amp;&amp;t&lt;this.y+this.height}<span class="fstat-no" title="function not covered" ></span>su</span>bdivide(){const e=<span class="cstat-no" title="statement not covered" >this.width/2,</span>t=<span class="cstat-no" title="statement not covered" >this.height/2;<span class="cstat-no" title="statement not covered" ></span>this.children.push(new d(this.x,this.y,e,t),new d(this.x+e,this.y,e,t),new d(this.x,this.y+t,e,t),new d(this.x+e,this.y+t,e,t))}<span class="fstat-no" title="function not covered" ></span>up</span>dateCenterOfMass(){let e=<span class="cstat-no" title="statement not covered" >0,</span>t=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(const{position:i}of this.nodes)<span class="cstat-no" title="statement not covered" >e+=i.x,t+=i.y,s+=1;<span class="cstat-no" title="statement not covered" >f</span></span>or(const i of this.children)<span class="cstat-no" title="statement not covered" >e+=i.centerOfMass.x*i.totalMass,t+=i.centerOfMass.y*i.totalMass,s+=i.totalMass;<span class="cstat-no" title="statement not covered" >s</span></span>&gt;0&amp;&amp;(this.centerOfMass.x=e/s,this.centerOfMass.y=t/s),this.totalMass=s}<span class="fstat-no" title="function not covered" ></span>ca</span>lculateForce(e,t=<span class="branch-0 cbranch-no" title="branch not covered" >.5)</span>{<span class="cstat-no" title="statement not covered" >if(0===this.totalMass)<span class="cstat-no" title="statement not covered" >return{fx:0,fy:0};c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this.centerOfMass.x-e.x,</span>i=<span class="cstat-no" title="statement not covered" >this.centerOfMass.y-e.y,</span>n=<span class="cstat-no" title="statement not covered" >Math.sqrt(s*s+i*i);<span class="cstat-no" title="statement not covered" ></span>if(0===n)<span class="cstat-no" title="statement not covered" >return{fx:0,fy:0};c</span></span>onst r=<span class="cstat-no" title="statement not covered" >Math.max(this.width,this.height);<span class="cstat-no" title="statement not covered" ></span>if(0===this.children.length||r/n&lt;t){const e=<span class="cstat-no" title="statement not covered" >1e3/(n*n);<span class="cstat-no" title="statement not covered" ></span>return{fx:s/n*e,fy:i/n*e}}</span>l</span>et a=<span class="cstat-no" title="statement not covered" >0,</span>l=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(const c of this.children){const s=<span class="cstat-no" title="statement not covered" >c.calculateForce(e,t);<span class="cstat-no" title="statement not covered" ></span>a+=s.fx,l+=s.fy}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{fx:a,fy:l}}</span>}const x=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.clearRect(0,0,e.width,e.height),U.clusters&amp;&amp;T&amp;&amp;U.clusters.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const t=<span class="cstat-no" title="statement not covered" >U.nodes.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.clusterId===e.id)</span>);<span class="cstat-no" title="statement not covered" ></span>if(t.length&gt;0){const s=<span class="cstat-no" title="statement not covered" >t.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >i.get(e.id))</span>).filter(Boolean);<span class="cstat-no" title="statement not covered" ></span>if(s.length&gt;0){const t=<span class="cstat-no" title="statement not covered" >Math.min(...s.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.x)</span>))-50,</span>i=<span class="cstat-no" title="statement not covered" >Math.max(...s.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.x)</span>))+50,</span>n=<span class="cstat-no" title="statement not covered" >Math.min(...s.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.y)</span>))-50,</span>r=<span class="cstat-no" title="statement not covered" >Math.max(...s.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.y)</span>))+50;<span class="cstat-no" title="statement not covered" ></span>e.bounds={x:t,y:n,width:i-t,height:r-n}}</span>}<span class="cstat-no" title="statement not covered" ></span>c</span>(e)}</span>));c</span>onst s=<span class="cstat-no" title="statement not covered" >U.nodes.length&gt;100?3:10,</span>n=<span class="cstat-no" title="statement not covered" >U.nodes.length&gt;100;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;s;t++){<span class="cstat-no" title="statement not covered" >if(n){const t=<span class="cstat-no" title="statement not covered" >new d(0,0,e.clientWidth,e.clientHeight);<span class="cstat-no" title="statement not covered" ></span>U.nodes.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >i.get(e.id);<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;t.insert(e,s)}</span>)),U.nodes.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >i.get(e.id);<span class="cstat-no" title="statement not covered" ></span>if(s){const e=<span class="cstat-no" title="statement not covered" >t.calculateForce(s);<span class="cstat-no" title="statement not covered" ></span>s.vx-=e.fx,s.vy-=e.fy}</span>}</span>))}</span>else <span class="cstat-no" title="statement not covered" >U.nodes.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >U.nodes.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(e.id===t.id)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >i.get(e.id),</span>n=<span class="cstat-no" title="statement not covered" >i.get(t.id),</span>r=<span class="cstat-no" title="statement not covered" >n.x-s.x,</span>a=<span class="cstat-no" title="statement not covered" >n.y-s.y,</span>l=<span class="cstat-no" title="statement not covered" >Math.sqrt(r*r+a*a);<span class="cstat-no" title="statement not covered" ></span>if(0===l)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst c=<span class="cstat-no" title="statement not covered" >1e3/(l*l),</span>o=<span class="cstat-no" title="statement not covered" >r/l*c,</span>h=<span class="cstat-no" title="statement not covered" >a/l*c;<span class="cstat-no" title="statement not covered" ></span>s.vx-=o,s.vy-=h,n.vx+=o,n.vy+=h}</span>))}</span>));<span class="cstat-no" title="statement not covered" >U</span></span>.edges.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const t=<span class="cstat-no" title="statement not covered" >i.get(e.source),</span>s=<span class="cstat-no" title="statement not covered" >i.get(e.target);<span class="cstat-no" title="statement not covered" ></span>if(!t||!s)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >s.x-t.x,</span>r=<span class="cstat-no" title="statement not covered" >s.y-t.y,</span>a=<span class="cstat-no" title="statement not covered" >Math.sqrt(n*n+r*r);<span class="cstat-no" title="statement not covered" ></span>if(0===a)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst l=<span class="cstat-no" title="statement not covered" >.01*(a-100),</span>c=<span class="cstat-no" title="statement not covered" >n/a*l,</span>o=<span class="cstat-no" title="statement not covered" >r/a*l;<span class="cstat-no" title="statement not covered" ></span>t.vx+=c,t.vy+=o,s.vx-=c,s.vy-=o}</span>)),i.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.x+=.1*t.vx,t.y+=.1*t.vy,t.vx*=.9,t.vy*=.9,t.x=Math.max(50,Math.min(e.clientWidth-50,t.x)),t.y=Math.max(50,Math.min(e.clientHeight-50,t.y))}</span>))}<span class="cstat-no" title="statement not covered" ></span>U</span>.edges.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const t=<span class="cstat-no" title="statement not covered" >i.get(e.source),</span>s=<span class="cstat-no" title="statement not covered" >i.get(e.target);<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;s&amp;&amp;h(e,t,s)}</span>)),U.nodes.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const t=<span class="cstat-no" title="statement not covered" >i.get(e.id);<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;o(e,t)}</span>)),"force"===k&amp;&amp;(N.current=requestAnimationFrame(x))}</span>;<span class="cstat-no" title="statement not covered" ></span>(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(N.current&amp;&amp;cancelAnimationFrame(N.current),"force"===k)<span class="cstat-no" title="statement not covered" >x();e</span>lse{let s;<span class="cstat-no" title="statement not covered" >switch(k){case"circular":<span class="cstat-no" title="statement not covered" >s=(<span class="fstat-no" title="function not covered" >()</span>=&gt;{const t=<span class="cstat-no" title="statement not covered" >e.clientWidth,</span>s=<span class="cstat-no" title="statement not covered" >e.clientHeight,</span>i=<span class="cstat-no" title="statement not covered" >.3*Math.min(t,s),</span>n=<span class="cstat-no" title="statement not covered" >new Map;<span class="cstat-no" title="statement not covered" ></span>return U.nodes.forEach((<span class="fstat-no" title="function not covered" >(e</span>,r)=&gt;{const a=<span class="cstat-no" title="statement not covered" >r/U.nodes.length*2*Math.PI,</span>l=<span class="cstat-no" title="statement not covered" >t/2+Math.cos(a)*i,</span>c=<span class="cstat-no" title="statement not covered" >s/2+Math.sin(a)*i;<span class="cstat-no" title="statement not covered" ></span>n.set(e.id,{x:l,y:c,vx:0,vy:0})}</span>)),n}</span>)();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"hierarchical":<span class="cstat-no" title="statement not covered" >s=(<span class="fstat-no" title="function not covered" >()</span>=&gt;{const t=<span class="cstat-no" title="statement not covered" >e.clientWidth,</span>s=<span class="cstat-no" title="statement not covered" >e.clientHeight,</span>i=<span class="cstat-no" title="statement not covered" >new Map,</span>n=<span class="cstat-no" title="statement not covered" >new Map;<span class="cstat-no" title="statement not covered" ></span>return U.nodes.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{let t=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>t="cluster"===e.type?0:"host"===e.type?1:"vm"===e.type?2:3,n.has(t)||n.set(t,[]),n.get(t).push(e)}</span>)),Array.from(n.entries()).forEach((<span class="fstat-no" title="function not covered" >([</span>e,n])=&gt;{const r=<span class="cstat-no" title="statement not covered" >s/5*(e+1);<span class="cstat-no" title="statement not covered" ></span>n.forEach((<span class="fstat-no" title="function not covered" >(e</span>,s)=&gt;{const a=<span class="cstat-no" title="statement not covered" >t/(n.length+1)*(s+1);<span class="cstat-no" title="statement not covered" ></span>i.set(e.id,{x:a,y:r,vx:0,vy:0})}</span>))}</span>)),i}</span>)();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"geographic":<span class="cstat-no" title="statement not covered" >s=(<span class="fstat-no" title="function not covered" >()</span>=&gt;{const t=<span class="cstat-no" title="statement not covered" >e.clientWidth,</span>s=<span class="cstat-no" title="statement not covered" >e.clientHeight,</span>i=<span class="cstat-no" title="statement not covered" >new Map,</span>n=<span class="cstat-no" title="statement not covered" >{"us-east-1":{x:.8*t,y:.3*s},"us-west-2":{x:.2*t,y:.4*s},"eu-west-1":{x:.6*t,y:.2*s},"ap-southeast-1":{x:.9*t,y:.7*s}};<span class="cstat-no" title="statement not covered" ></span>return U.nodes.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const r=<span class="cstat-no" title="statement not covered" >n[e.region],</span>a=<span class="cstat-no" title="statement not covered" >r?.x||Math.random()*t,</span>l=<span class="cstat-no" title="statement not covered" >r?.y||Math.random()*s;<span class="cstat-no" title="statement not covered" ></span>i.set(e.id,{x:a,y:l,vx:0,vy:0})}</span>)),i}</span>)();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"clustered":<span class="cstat-no" title="statement not covered" >s=(<span class="fstat-no" title="function not covered" >()</span>=&gt;{const t=<span class="cstat-no" title="statement not covered" >e.clientWidth,</span>s=<span class="cstat-no" title="statement not covered" >e.clientHeight,</span>i=<span class="cstat-no" title="statement not covered" >new Map;<span class="cstat-no" title="statement not covered" ></span>return U.nodes.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{let n,r;<span class="cstat-no" title="statement not covered" >if(e.clusterId&amp;&amp;U.clusters){const i=<span class="cstat-no" title="statement not covered" >U.clusters.find((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.id===e.clusterId)</span>);<span class="cstat-no" title="statement not covered" ></span>i?.bounds?(n=i.bounds.x+Math.random()*i.bounds.width,r=i.bounds.y+Math.random()*i.bounds.height):(n=Math.random()*t,r=Math.random()*s)}</span>else <span class="cstat-no" title="statement not covered" >n=Math.random()*t,r=Math.random()*s;<span class="cstat-no" title="statement not covered" >i</span></span>.set(e.id,{x:n,y:r,vx:0,vy:0})}</span>)),i}</span>)();<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >s=new Map}<span class="cstat-no" title="statement not covered" ></span>s</span>.forEach((<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >i.set(t,e)}</span>)),t.clearRect(0,0,e.width,e.height),U.clusters&amp;&amp;T&amp;&amp;U.clusters.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const t=<span class="cstat-no" title="statement not covered" >U.nodes.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.clusterId===e.id)</span>);<span class="cstat-no" title="statement not covered" ></span>if(t.length&gt;0){const s=<span class="cstat-no" title="statement not covered" >t.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >i.get(e.id))</span>).filter(Boolean);<span class="cstat-no" title="statement not covered" ></span>if(s.length&gt;0){const t=<span class="cstat-no" title="statement not covered" >Math.min(...s.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.x)</span>))-50,</span>i=<span class="cstat-no" title="statement not covered" >Math.max(...s.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.x)</span>))+50,</span>n=<span class="cstat-no" title="statement not covered" >Math.min(...s.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.y)</span>))-50,</span>r=<span class="cstat-no" title="statement not covered" >Math.max(...s.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.y)</span>))+50;<span class="cstat-no" title="statement not covered" ></span>e.bounds={x:t,y:n,width:i-t,height:r-n}}</span>}<span class="cstat-no" title="statement not covered" ></span>c</span>(e)}</span>)),U.edges.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const t=<span class="cstat-no" title="statement not covered" >i.get(e.source),</span>s=<span class="cstat-no" title="statement not covered" >i.get(e.target);<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;s&amp;&amp;h(e,t,s)}</span>)),U.nodes.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const t=<span class="cstat-no" title="statement not covered" >i.get(e.id);<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;o(e,t)}</span>))}</span>}</span>)();l</span>et u=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>p&amp;&amp;v&gt;0&amp;&amp;(u=setInterval((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >console.log("Refreshing network topology data...")}</span>),v));c</span>onst f=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >e.getBoundingClientRect(),</span>n=<span class="cstat-no" title="statement not covered" >t.clientX-s.left,</span>r=<span class="cstat-no" title="statement not covered" >t.clientY-s.top;<span class="cstat-no" title="statement not covered" ></span>for(const e of U.nodes){const t=<span class="cstat-no" title="statement not covered" >i.get(e.id);<span class="cstat-no" title="statement not covered" ></span>if(!t)<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >"host"===e.type||"cluster"===e.type?15:10;<span class="cstat-no" title="statement not covered" ></span>if(Math.sqrt(Math.pow(t.x-n,2)+Math.pow(t.y-r,2))&lt;=s+3)<span class="cstat-no" title="statement not covered" >return void(w&amp;&amp;w(e))}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(U.clusters&amp;&amp;T)<span class="cstat-no" title="statement not covered" >for(const e of U.clusters)<span class="cstat-no" title="statement not covered" >if(e.bounds){const{x:t,y:s,width:i,height:a}=<span class="cstat-no" title="statement not covered" >e.bounds;<span class="cstat-no" title="statement not covered" ></span>if(n&gt;=t&amp;&amp;n&lt;=t+i&amp;&amp;r&gt;=s&amp;&amp;r&lt;=s+a){<span class="cstat-no" title="statement not covered" >b&amp;&amp;b(e);c</span>onst t=<span class="cstat-no" title="statement not covered" >H.has(e.id),</span>s=<span class="cstat-no" title="statement not covered" >new Set(H);<span class="cstat-no" title="statement not covered" ></span>return t?s.delete(e.id):s.add(e.id),void O(s)}</span>}<span class="cstat-no" title="statement not covered" ></span>f</span></span></span>or(const e of U.edges){const t=<span class="cstat-no" title="statement not covered" >i.get(e.source),</span>s=<span class="cstat-no" title="statement not covered" >i.get(e.target);<span class="cstat-no" title="statement not covered" ></span>if(!t||!s)<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst a=<span class="cstat-no" title="statement not covered" >n-t.x,</span>c=<span class="cstat-no" title="statement not covered" >r-t.y,</span>o=<span class="cstat-no" title="statement not covered" >s.x-t.x,</span>h=<span class="cstat-no" title="statement not covered" >s.y-t.y,</span>d=<span class="cstat-no" title="statement not covered" >a*o+c*h,</span>x=<span class="cstat-no" title="statement not covered" >o*o+h*h;</span>let u,f,m=<span class="cstat-no" title="statement not covered" >-1;<span class="cstat-no" title="statement not covered" ></span>0!==x&amp;&amp;(m=d/x),m&lt;0?(u=t.x,f=t.y):m&gt;1?(u=s.x,f=s.y):(u=t.x+m*o,f=t.y+m*h);c</span>onst g=<span class="cstat-no" title="statement not covered" >n-u,</span>y=<span class="cstat-no" title="statement not covered" >r-f;<span class="cstat-no" title="statement not covered" ></span>if(Math.sqrt(g*g+y*y)&lt;=l(e)+2)<span class="cstat-no" title="statement not covered" >return void(M&amp;&amp;M(e))}</span></span>}</span>;<span class="cstat-no" title="statement not covered" ></span>return e.addEventListener("click",f),<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >e.removeEventListener("click",f),window.removeEventListener("resize",s),N.current&amp;&amp;cancelAnimationFrame(N.current),u&amp;&amp;clearInterval(u)}</span>}</span>),[U,k,T,B,R,L,W,p,v,w,M,b,H]),(0,i.jsxs)(a.Zb,{children:[(0,i.jsxs)(a.Ol,{className:"flex flex-row items-center justify-between space-y-0 pb-2",children:[(0,i.jsxs)("div",{children:[i.jsx(a.ll,{children:t}),s&amp;&amp;i.jsx("p",{className:"text-sm text-muted-foreground",children:s})]}),(0,i.jsxs)(l.Ph,{value:k,onValueChange:E,children:[i.jsx(l.i4,{className:"w-[180px]",children:i.jsx(l.ki,{placeholder:"Layout Type"})}),(0,i.jsxs)(l.Bw,{children:[i.jsx(l.Ql,{value:"force",children:"Force-Directed"}),i.jsx(l.Ql,{value:"circular",children:"Circular"}),i.jsx(l.Ql,{value:"hierarchical",children:"Hierarchical"}),i.jsx(l.Ql,{value:"geographic",children:"Geographic"}),i.jsx(l.Ql,{value:"clustered",children:"Clustered"})]})]})]}),(0,i.jsxs)(a.aY,{children:[(0,i.jsxs)("div",{className:"flex flex-wrap gap-2 mb-4",children:[(0,i.jsxs)(o.z,{size:"sm",variant:T?"default":"outline",onClick:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >A(!T),</span>children:[i.jsx(d.Z,{className:"h-4 w-4 mr-1"}),"Distributed View"]}),(0,i.jsxs)(o.z,{size:"sm",variant:B?"default":"outline",onClick:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >F(!B),</span>children:[i.jsx(x.Z,{className:"h-4 w-4 mr-1"}),"Bandwidth"]}),(0,i.jsxs)(o.z,{size:"sm",variant:R?"default":"outline",onClick:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >q(!R),</span>children:[i.jsx(u.Z,{className:"h-4 w-4 mr-1"}),"Metrics"]}),(0,i.jsxs)(l.Ph,{value:W,onValueChange:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >D(e),</span>children:[i.jsx(l.i4,{className:"w-[120px] h-8",children:i.jsx(l.ki,{})}),(0,i.jsxs)(l.Bw,{children:[i.jsx(l.Ql,{value:"low",children:"Low Detail"}),i.jsx(l.Ql,{value:"medium",children:"Medium Detail"}),i.jsx(l.Ql,{value:"high",children:"High Detail"})]})]}),T&amp;&amp;$&amp;&amp;(0,i.jsxs)(c.C,{variant:"outline",className:"ml-auto",children:[i.jsx("div",{className:"w-2 h-2 bg-green-500 rounded-full mr-2 animate-pulse"}),"Live Updates"]})]}),i.jsx("div",{className:"relative",style:{height:`${f}px`},children:i.jsx("canvas",{ref:j,className:"w-full h-full",style:{touchAction:"none"}})}),(0,i.jsxs)("div",{className:"flex justify-center mt-4 space-x-4",children:[(0,i.jsxs)("div",{className:"flex items-center",children:[i.jsx("div",{className:"w-3 h-3 rounded-full bg-[#4f46e5] mr-2"}),i.jsx("span",{className:"text-xs",children:"VM"})]}),(0,i.jsxs)("div",{className:"flex items-center",children:[i.jsx("div",{className:"w-3 h-3 rounded-full bg-[#0891b2] mr-2"}),i.jsx("span",{className:"text-xs",children:"Host"})]}),(0,i.jsxs)("div",{className:"flex items-center",children:[i.jsx("div",{className:"w-3 h-3 rounded-full bg-[#7c3aed] mr-2"}),i.jsx("span",{className:"text-xs",children:"Storage"})]}),(0,i.jsxs)("div",{className:"flex items-center",children:[i.jsx("div",{className:"w-3 h-3 rounded-full bg-[#2563eb] mr-2"}),i.jsx("span",{className:"text-xs",children:"Network"})]}),(0,i.jsxs)("div",{className:"flex items-center",children:[i.jsx("div",{className:"w-3 h-3 rounded-full bg-[#059669] mr-2"}),i.jsx("span",{className:"text-xs",children:"Service"})]}),T&amp;&amp;(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)("div",{className:"flex items-center",children:[i.jsx("div",{className:"w-3 h-3 rounded-full bg-[#f59e0b] mr-2"}),i.jsx("span",{className:"text-xs",children:"Cluster"})]}),(0,i.jsxs)("div",{className:"flex items-center",children:[i.jsx("div",{className:"w-3 h-3 rounded-full bg-[#ec4899] mr-2"}),i.jsx("span",{className:"text-xs",children:"Federation"})]})]})]})]})]})}</span>}</span>};</span></pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2025-11-10T08:05:28.828Z
            </div>
        <script src="../../../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../../../sorter.js"></script>
        <script src="../../../../../block-navigation.js"></script>
    </body>
</html>
    