
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for novacron/frontend/.next/static/chunks/ca377847-cec4f8feafbe8c3e.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../../../index.html">All files</a> / <a href="index.html">novacron/frontend/.next/static/chunks</a> ca377847-cec4f8feafbe8c3e.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/3339</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/2991</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/859</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/1</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">"use strict";<span class="cstat-no" title="statement not covered" >(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[7674],{96704:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >i.d(e,{De:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return Qe}</span>,Dx:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return Ke}</span>,Gu:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return $e}</span>,ST:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return E}</span>,ZL:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return De}</span>,f$:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return mi}</span>,jI:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return O}</span>,jn:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return me}</span>,kL:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return ie}</span>,od:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return _e}</span>,qi:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return he}</span>,tt:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return R}</span>,u:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return di}</span>,uw:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return fi}</span>,vn:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return T}</span>});v</span>ar s=<span class="cstat-no" title="statement not covered" >i(78273);</span>class n{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this._request=null,this._charts=new Map,this._running=!1,this._lastDate=void 0}<span class="fstat-no" title="function not covered" ></span>_n</span>otify(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >e.listeners[s],</span>o=<span class="cstat-no" title="statement not covered" >e.duration;<span class="cstat-no" title="statement not covered" ></span>n.forEach((<span class="fstat-no" title="function not covered" >s=</span>&gt;<span class="cstat-no" title="statement not covered" >s({chart:t,initial:e.initial,numSteps:o,currentStep:Math.min(i-e.start,o)}))</span>)}<span class="fstat-no" title="function not covered" ></span>_r</span>efresh(){<span class="cstat-no" title="statement not covered" >this._request||(this._running=!0,this._request=s.r.call(window,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this._update(),this._request=null,this._running&amp;&amp;this._refresh()}</span>)))}<span class="fstat-no" title="function not covered" ></span>_u</span>pdate(t=<span class="branch-0 cbranch-no" title="branch not covered" >Date.now())</span>{let e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>this._charts.forEach((<span class="fstat-no" title="function not covered" >(i</span>,s)=&gt;{<span class="cstat-no" title="statement not covered" >if(!i.running||!i.items.length)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >i.items;</span>let o,a=<span class="cstat-no" title="statement not covered" >n.length-1,</span>r=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>for(;a&gt;=0;--a)<span class="cstat-no" title="statement not covered" >o=n[a],o._active?(o._total&gt;i.duration&amp;&amp;(i.duration=o._total),o.tick(t),r=!0):(n[a]=n[n.length-1],n.pop());<span class="cstat-no" title="statement not covered" >r</span></span>&amp;&amp;(s.draw(),this._notify(s,i,t,"progress")),n.length||(i.running=!1,this._notify(s,i,t,"complete"),i.initial=!1),e+=n.length}</span>)),this._lastDate=t,0===e&amp;&amp;(this._running=!1)}<span class="fstat-no" title="function not covered" ></span>_g</span>etAnims(t){const e=<span class="cstat-no" title="statement not covered" >this._charts;</span>let i=<span class="cstat-no" title="statement not covered" >e.get(t);<span class="cstat-no" title="statement not covered" ></span>return i||(i={running:!1,initial:!0,items:[],listeners:{complete:[],progress:[]}},e.set(t,i)),i}<span class="fstat-no" title="function not covered" ></span>li</span>sten(t,e,i){<span class="cstat-no" title="statement not covered" >this._getAnims(t).listeners[e].push(i)}<span class="fstat-no" title="function not covered" ></span>ad</span>d(t,e){<span class="cstat-no" title="statement not covered" >e&amp;&amp;e.length&amp;&amp;this._getAnims(t).items.push(...e)}<span class="fstat-no" title="function not covered" ></span>ha</span>s(t){<span class="cstat-no" title="statement not covered" >return this._getAnims(t).items.length&gt;0}<span class="fstat-no" title="function not covered" ></span>st</span>art(t){const e=<span class="cstat-no" title="statement not covered" >this._charts.get(t);<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;(e.running=!0,e.start=Date.now(),e.duration=e.items.reduce((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >Math.max(t,e._duration))</span>,0),this._refresh())}<span class="fstat-no" title="function not covered" ></span>ru</span>nning(t){<span class="cstat-no" title="statement not covered" >if(!this._running)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this._charts.get(t);<span class="cstat-no" title="statement not covered" ></span>return!!(e&amp;&amp;e.running&amp;&amp;e.items.length)}<span class="fstat-no" title="function not covered" ></span>st</span>op(t){const e=<span class="cstat-no" title="statement not covered" >this._charts.get(t);<span class="cstat-no" title="statement not covered" ></span>if(!e||!e.items.length)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >e.items;</span>let s=<span class="cstat-no" title="statement not covered" >i.length-1;<span class="cstat-no" title="statement not covered" ></span>for(;s&gt;=0;--s)<span class="cstat-no" title="statement not covered" >i[s].cancel();<span class="cstat-no" title="statement not covered" >e</span></span>.items=[],this._notify(t,e,Date.now(),"complete")}<span class="fstat-no" title="function not covered" ></span>re</span>move(t){<span class="cstat-no" title="statement not covered" >return this._charts.delete(t)}</span>}var o=<span class="cstat-no" title="statement not covered" >new n;</span>const a=<span class="cstat-no" title="statement not covered" >"transparent",</span>r=<span class="cstat-no" title="statement not covered" >{boolean:<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >i&gt;.5?e:t,<span class="fstat-no" title="function not covered" ></span>co</span>lor(t,e,i){const n=<span class="cstat-no" title="statement not covered" >(0,s.c)(t||a),</span>o=<span class="cstat-no" title="statement not covered" >n.valid&amp;&amp;(0,s.c)(e||a);<span class="cstat-no" title="statement not covered" ></span>return o&amp;&amp;o.valid?o.mix(n,i).hexString():e}</span>,number:<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >t+(e-t)*i}</span>;</span>class h{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,i,n){const o=<span class="cstat-no" title="statement not covered" >e[i];<span class="cstat-no" title="statement not covered" ></span>n=(0,s.a)([t.to,n,o,t.from]);c</span>onst a=<span class="cstat-no" title="statement not covered" >(0,s.a)([t.from,o,n]);<span class="cstat-no" title="statement not covered" ></span>this._active=!0,this._fn=t.fn||r[t.type||typeof a],this._easing=s.e[t.easing]||s.e.linear,this._start=Math.floor(Date.now()+(t.delay||0)),this._duration=this._total=Math.floor(t.duration),this._loop=!!t.loop,this._target=e,this._prop=i,this._from=a,this._to=n,this._promises=void 0}<span class="fstat-no" title="function not covered" ></span>ac</span>tive(){<span class="cstat-no" title="statement not covered" >return this._active}<span class="fstat-no" title="function not covered" ></span>up</span>date(t,e,i){<span class="cstat-no" title="statement not covered" >if(this._active){<span class="cstat-no" title="statement not covered" >this._notify(!1);c</span>onst n=<span class="cstat-no" title="statement not covered" >this._target[this._prop],</span>o=<span class="cstat-no" title="statement not covered" >i-this._start,</span>a=<span class="cstat-no" title="statement not covered" >this._duration-o;<span class="cstat-no" title="statement not covered" ></span>this._start=i,this._duration=Math.floor(Math.max(a,t.duration)),this._total+=o,this._loop=!!t.loop,this._to=(0,s.a)([t.to,e,n,t.from]),this._from=(0,s.a)([t.from,n,e])}</span>}<span class="fstat-no" title="function not covered" ></span>ca</span>ncel(){<span class="cstat-no" title="statement not covered" >this._active&amp;&amp;(this.tick(Date.now()),this._active=!1,this._notify(!1))}<span class="fstat-no" title="function not covered" ></span>ti</span>ck(t){const e=<span class="cstat-no" title="statement not covered" >t-this._start,</span>i=<span class="cstat-no" title="statement not covered" >this._duration,</span>s=<span class="cstat-no" title="statement not covered" >this._prop,</span>n=<span class="cstat-no" title="statement not covered" >this._from,</span>o=<span class="cstat-no" title="statement not covered" >this._loop,</span>a=<span class="cstat-no" title="statement not covered" >this._to;</span>let r;<span class="cstat-no" title="statement not covered" >if(this._active=n!==a&amp;&amp;(o||e&lt;i),!this._active)<span class="cstat-no" title="statement not covered" >return this._target[s]=a,void this._notify(!0);<span class="cstat-no" title="statement not covered" >e</span></span>&lt;0?this._target[s]=n:(r=e/i%2,r=o&amp;&amp;r&gt;1?2-r:r,r=this._easing(Math.min(1,Math.max(0,r))),this._target[s]=this._fn(n,a,r))}<span class="fstat-no" title="function not covered" ></span>wa</span>it(){const t=<span class="cstat-no" title="statement not covered" >this._promises||(this._promises=[]);<span class="cstat-no" title="statement not covered" ></span>return new Promise((<span class="fstat-no" title="function not covered" >(e</span>,i)=&gt;{<span class="cstat-no" title="statement not covered" >t.push({res:e,rej:i})}</span>))}<span class="fstat-no" title="function not covered" ></span>_n</span>otify(t){const e=<span class="cstat-no" title="statement not covered" >t?"res":"rej",</span>i=<span class="cstat-no" title="statement not covered" >this._promises||[];<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;i.length;s++)<span class="cstat-no" title="statement not covered" >i[s][e]()}</span></span>}class l{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >this._chart=t,this._properties=new Map,this.configure(e)}<span class="fstat-no" title="function not covered" ></span>co</span>nfigure(t){<span class="cstat-no" title="statement not covered" >if(!(0,s.i)(t))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >Object.keys(s.d.animation),</span>i=<span class="cstat-no" title="statement not covered" >this._properties;<span class="cstat-no" title="statement not covered" ></span>Object.getOwnPropertyNames(t).forEach((<span class="fstat-no" title="function not covered" >n=</span>&gt;{const o=<span class="cstat-no" title="statement not covered" >t[n];<span class="cstat-no" title="statement not covered" ></span>if(!(0,s.i)(o))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst a=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(const t of e)<span class="cstat-no" title="statement not covered" >a[t]=o[t];<span class="cstat-no" title="statement not covered" >(</span></span>(0,s.b)(o.properties)&amp;&amp;o.properties||[n]).forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >t!==n&amp;&amp;i.has(t)||i.set(t,a)}</span>))}</span>))}<span class="fstat-no" title="function not covered" ></span>_a</span>nimateOptions(t,e){const i=<span class="cstat-no" title="statement not covered" >e.options,</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return;l</span></span>et i=<span class="cstat-no" title="statement not covered" >t.options;<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return void(t.options=e);<span class="cstat-no" title="statement not covered" >i</span></span>.$shared&amp;&amp;(t.options=i=Object.assign({},i,{$shared:!1,$animations:{}}));<span class="cstat-no" title="statement not covered" >r</span>eturn i}</span>(t,i);<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return[];c</span></span>onst n=<span class="cstat-no" title="statement not covered" >this._createAnimations(s,i);<span class="cstat-no" title="statement not covered" ></span>return i.$shared&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >Object.keys(e);<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;s.length;n++){const e=<span class="cstat-no" title="statement not covered" >t[s[n]];<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;e.active()&amp;&amp;i.push(e.wait())}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Promise.all(i)}</span>(t.options.$animations,i).then((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.options=i}</span>),(<span class="fstat-no" title="function not covered" >()</span>=&gt;{})),n}<span class="fstat-no" title="function not covered" ></span>_c</span>reateAnimations(t,e){const i=<span class="cstat-no" title="statement not covered" >this._properties,</span>s=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >t.$animations||(t.$animations={}),</span>o=<span class="cstat-no" title="statement not covered" >Object.keys(e),</span>a=<span class="cstat-no" title="statement not covered" >Date.now();</span>let r;<span class="cstat-no" title="statement not covered" >for(r=o.length-1;r&gt;=0;--r){const l=<span class="cstat-no" title="statement not covered" >o[r];<span class="cstat-no" title="statement not covered" ></span>if("$"===l.charAt(0))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f("options"===l){<span class="cstat-no" title="statement not covered" >s.push(...this._animateOptions(t,e));<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>c</span>onst c=<span class="cstat-no" title="statement not covered" >e[l];</span>let d=<span class="cstat-no" title="statement not covered" >n[l];</span>const u=<span class="cstat-no" title="statement not covered" >i.get(l);<span class="cstat-no" title="statement not covered" ></span>if(d){<span class="cstat-no" title="statement not covered" >if(u&amp;&amp;d.active()){<span class="cstat-no" title="statement not covered" >d.update(u,c,a);<span class="cstat-no" title="statement not covered" >c</span>ontinue}<span class="cstat-no" title="statement not covered" ></span>d</span>.cancel()}<span class="cstat-no" title="statement not covered" ></span>u</span>&amp;&amp;u.duration?(n[l]=d=new h(u,t,l,c),s.push(d)):t[l]=c}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>up</span>date(t,e){<span class="cstat-no" title="statement not covered" >if(0===this._properties.size)<span class="cstat-no" title="statement not covered" >return void Object.assign(t,e);c</span></span>onst i=<span class="cstat-no" title="statement not covered" >this._createAnimations(t,e);<span class="cstat-no" title="statement not covered" ></span>return i.length?(o.add(this._chart,i),!0):void 0}</span>}function <span class="fstat-no" title="function not covered" >c(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.options||{},</span>s=<span class="cstat-no" title="statement not covered" >i.reverse,</span>n=<span class="cstat-no" title="statement not covered" >void 0===i.min?e:0,</span>o=<span class="cstat-no" title="statement not covered" >void 0===i.max?e:0;<span class="cstat-no" title="statement not covered" ></span>return{start:s?o:n,end:s?n:o}}</span>function <span class="fstat-no" title="function not covered" >d(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >t._getSortedDatasetMetas(e);</span>let n,o;<span class="cstat-no" title="statement not covered" >for(n=0,o=s.length;n&lt;o;++n)<span class="cstat-no" title="statement not covered" >i.push(s[n].index);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>function <span class="fstat-no" title="function not covered" >u(</span>t,e,i,n=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const o=<span class="cstat-no" title="statement not covered" >t.keys,</span>a=<span class="cstat-no" title="statement not covered" >"single"===n.mode;</span>let r,h,l,c;<span class="cstat-no" title="statement not covered" >if(null===e)<span class="cstat-no" title="statement not covered" >return;l</span></span>et d=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>for(r=0,h=o.length;r&lt;h;++r){<span class="cstat-no" title="statement not covered" >if(l=+o[r],l===i){<span class="cstat-no" title="statement not covered" >if(d=!0,n.all)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >b</span></span>reak}<span class="cstat-no" title="statement not covered" ></span>c</span>=t.values[l],(0,s.g)(c)&amp;&amp;(a||0===e||(0,s.s)(e)===(0,s.s)(c))&amp;&amp;(e+=c)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn d||n.all?e:0}</span>function <span class="fstat-no" title="function not covered" >g(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.options.stacked;<span class="cstat-no" title="statement not covered" ></span>return i||void 0===i&amp;&amp;void 0!==e.stack}</span>function <span class="fstat-no" title="function not covered" >f(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t[e]||(t[e]={});<span class="cstat-no" title="statement not covered" ></span>return s[i]||(s[i]={})}</span>function <span class="fstat-no" title="function not covered" >p(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >for(const n of e.getMatchingVisibleMetas(s).reverse()){const e=<span class="cstat-no" title="statement not covered" >t[n.index];<span class="cstat-no" title="statement not covered" ></span>if(i&amp;&amp;e&gt;0||!i&amp;&amp;e&lt;0)<span class="cstat-no" title="statement not covered" >return n.index}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn null}</span>function <span class="fstat-no" title="function not covered" >x(</span>t,e){const{chart:i,_cachedMeta:s}=<span class="cstat-no" title="statement not covered" >t,</span>n=<span class="cstat-no" title="statement not covered" >i._stacks||(i._stacks={}),</span>{iScale:o,vScale:a,index:r}=<span class="cstat-no" title="statement not covered" >s,</span>h=<span class="cstat-no" title="statement not covered" >o.axis,</span>l=<span class="cstat-no" title="statement not covered" >a.axis,</span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return`${t.id}.${e.id}.${i.stack||i.type}`}</span>(o,a,s),</span>d=<span class="cstat-no" title="statement not covered" >e.length;</span>let u;<span class="cstat-no" title="statement not covered" >for(let g=<span class="cstat-no" title="statement not covered" >0;</span>g&lt;d;++g){const t=<span class="cstat-no" title="statement not covered" >e[g],</span>{[h]:i,[l]:o}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>u=(t._stacks||(t._stacks={}))[l]=f(n,c,i),u[r]=o,u._top=p(u,a,!0,s.type),u._bottom=p(u,a,!1,s.type);<span class="cstat-no" title="statement not covered" >(</span>u._visualValues||(u._visualValues={}))[r]=o}</span>}</span>function <span class="fstat-no" title="function not covered" >m(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t.scales;<span class="cstat-no" title="statement not covered" ></span>return Object.keys(i).filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >i[t].axis===e)</span>).shift()}</span>function <span class="fstat-no" title="function not covered" >b(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t.controller.index,</span>s=<span class="cstat-no" title="statement not covered" >t.vScale&amp;&amp;t.vScale.axis;<span class="cstat-no" title="statement not covered" ></span>if(s){<span class="cstat-no" title="statement not covered" >e=e||t._parsed;<span class="cstat-no" title="statement not covered" >f</span>or(const t of e){const e=<span class="cstat-no" title="statement not covered" >t._stacks;<span class="cstat-no" title="statement not covered" ></span>if(!e||void 0===e[s]||void 0===e[s][i])<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >d</span></span>elete e[s][i],void 0!==e[s]._visualValues&amp;&amp;void 0!==e[s]._visualValues[i]&amp;&amp;delete e[s]._visualValues[i]}</span>}</span>}</span>const _=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"reset"===t||"none"===t,</span></span>v=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e?t:Object.assign({},t);</span></span>class y{static defaults=<span class="cstat-no" title="statement not covered" >{};</span>static datasetElementType=<span class="cstat-no" title="statement not covered" >null;</span>static dataElementType=<span class="cstat-no" title="statement not covered" >null;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >this.chart=t,this._ctx=t.ctx,this.index=e,this._cachedDataOpts={},this._cachedMeta=this.getMeta(),this._type=this._cachedMeta.type,this.options=void 0,this._parsing=!1,this._data=void 0,this._objectData=void 0,this._sharedOptions=void 0,this._drawStart=void 0,this._drawCount=void 0,this.enableOptionSharing=!1,this.supportsDecimation=!1,this.$context=void 0,this._syncList=[],this.datasetElementType=new.target.datasetElementType,this.dataElementType=new.target.dataElementType,this.initialize()}<span class="fstat-no" title="function not covered" ></span>in</span>itialize(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>this.configure(),this.linkScales(),t._stacked=g(t.vScale,t),this.addElements(),this.options.fill&amp;&amp;!this.chart.isPluginEnabled("filler")&amp;&amp;console.warn("Tried to use the 'fill' option without the 'Filler' plugin enabled. Please import and register the 'Filler' plugin and make sure it is not disabled in the options")}<span class="fstat-no" title="function not covered" ></span>up</span>dateIndex(t){<span class="cstat-no" title="statement not covered" >this.index!==t&amp;&amp;b(this._cachedMeta),this.index=t}<span class="fstat-no" title="function not covered" ></span>li</span>nkScales(){const t=<span class="cstat-no" title="statement not covered" >this.chart,</span>e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>i=<span class="cstat-no" title="statement not covered" >this.getDataset(),</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i,s)=&gt;<span class="cstat-no" title="statement not covered" >"x"===t?e:"r"===t?s:i,</span></span>o=<span class="cstat-no" title="statement not covered" >e.xAxisID=(0,s.v)(i.xAxisID,m(t,"x")),</span>a=<span class="cstat-no" title="statement not covered" >e.yAxisID=(0,s.v)(i.yAxisID,m(t,"y")),</span>r=<span class="cstat-no" title="statement not covered" >e.rAxisID=(0,s.v)(i.rAxisID,m(t,"r")),</span>h=<span class="cstat-no" title="statement not covered" >e.indexAxis,</span>l=<span class="cstat-no" title="statement not covered" >e.iAxisID=n(h,o,a,r),</span>c=<span class="cstat-no" title="statement not covered" >e.vAxisID=n(h,a,o,r);<span class="cstat-no" title="statement not covered" ></span>e.xScale=this.getScaleForId(o),e.yScale=this.getScaleForId(a),e.rScale=this.getScaleForId(r),e.iScale=this.getScaleForId(l),e.vScale=this.getScaleForId(c)}<span class="fstat-no" title="function not covered" ></span>ge</span>tDataset(){<span class="cstat-no" title="statement not covered" >return this.chart.data.datasets[this.index]}<span class="fstat-no" title="function not covered" ></span>ge</span>tMeta(){<span class="cstat-no" title="statement not covered" >return this.chart.getDatasetMeta(this.index)}<span class="fstat-no" title="function not covered" ></span>ge</span>tScaleForId(t){<span class="cstat-no" title="statement not covered" >return this.chart.scales[t]}<span class="fstat-no" title="function not covered" ></span>_g</span>etOtherScale(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>return t===e.iScale?e.vScale:e.iScale}<span class="fstat-no" title="function not covered" ></span>re</span>set(){<span class="cstat-no" title="statement not covered" >this._update("reset")}<span class="fstat-no" title="function not covered" ></span>_d</span>estroy(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>this._data&amp;&amp;(0,s.u)(this._data,this),t._stacked&amp;&amp;b(t)}<span class="fstat-no" title="function not covered" ></span>_d</span>ataCheck(){const t=<span class="cstat-no" title="statement not covered" >this.getDataset(),</span>e=<span class="cstat-no" title="statement not covered" >t.data||(t.data=[]),</span>i=<span class="cstat-no" title="statement not covered" >this._data;<span class="cstat-no" title="statement not covered" ></span>if((0,s.i)(e)){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>this._data=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const{iScale:i,vScale:s}=<span class="cstat-no" title="statement not covered" >e,</span>n=<span class="cstat-no" title="statement not covered" >"x"===i.axis?"x":"y",</span>o=<span class="cstat-no" title="statement not covered" >"x"===s.axis?"x":"y",</span>a=<span class="cstat-no" title="statement not covered" >Object.keys(t),</span>r=<span class="cstat-no" title="statement not covered" >new Array(a.length);</span>let h,l,c;<span class="cstat-no" title="statement not covered" >for(h=0,l=a.length;h&lt;l;++h)<span class="cstat-no" title="statement not covered" >c=a[h],r[h]={[n]:c,[o]:t[c]};<span class="cstat-no" title="statement not covered" >r</span></span>eturn r}</span>(e,t)}</span>else <span class="cstat-no" title="statement not covered" >if(i!==e){<span class="cstat-no" title="statement not covered" >if(i){<span class="cstat-no" title="statement not covered" >(0,s.u)(i,this);c</span>onst t=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>b(t),t._parsed=[]}<span class="cstat-no" title="statement not covered" ></span>e</span>&amp;&amp;Object.isExtensible(e)&amp;&amp;(0,s.l)(e,this),this._syncList=[],this._data=e}</span>}<span class="fstat-no" title="function not covered" ></span></span>ad</span>dElements(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>this._dataCheck(),this.datasetElementType&amp;&amp;(t.dataset=new this.datasetElementType)}<span class="fstat-no" title="function not covered" ></span>bu</span>ildOrUpdateElements(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>i=<span class="cstat-no" title="statement not covered" >this.getDataset();</span>let s=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>this._dataCheck();c</span>onst n=<span class="cstat-no" title="statement not covered" >e._stacked;<span class="cstat-no" title="statement not covered" ></span>e._stacked=g(e.vScale,e),e.stack!==i.stack&amp;&amp;(s=!0,b(e),e.stack=i.stack),this._resyncElements(t),(s||n!==e._stacked)&amp;&amp;(x(this,e._parsed),e._stacked=g(e.vScale,e))}<span class="fstat-no" title="function not covered" ></span>co</span>nfigure(){const t=<span class="cstat-no" title="statement not covered" >this.chart.config,</span>e=<span class="cstat-no" title="statement not covered" >t.datasetScopeKeys(this._type),</span>i=<span class="cstat-no" title="statement not covered" >t.getOptionScopes(this.getDataset(),e,!0);<span class="cstat-no" title="statement not covered" ></span>this.options=t.createResolver(i,this.getContext()),this._parsing=this.options.parsing,this._cachedDataOpts={}}<span class="fstat-no" title="function not covered" ></span>pa</span>rse(t,e){const{_cachedMeta:i,_data:n}=<span class="cstat-no" title="statement not covered" >this,</span>{iScale:o,_stacked:a}=<span class="cstat-no" title="statement not covered" >i,</span>r=<span class="cstat-no" title="statement not covered" >o.axis;</span>let h,l,c,d=<span class="cstat-no" title="statement not covered" >0===t&amp;&amp;e===n.length||i._sorted,</span>u=<span class="cstat-no" title="statement not covered" >t&gt;0&amp;&amp;i._parsed[t-1];<span class="cstat-no" title="statement not covered" ></span>if(!1===this._parsing)<span class="cstat-no" title="statement not covered" >i._parsed=n,i._sorted=!0,c=n;e</span>lse{<span class="cstat-no" title="statement not covered" >c=(0,s.b)(n[t])?this.parseArrayData(i,n,t,e):(0,s.i)(n[t])?this.parseObjectData(i,n,t,e):this.parsePrimitiveData(i,n,t,e);c</span>onst o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >null===l[r]||u&amp;&amp;l[r]&lt;u[r];<span class="cstat-no" title="statement not covered" ></span></span>for(h=0;h&lt;e;++h)<span class="cstat-no" title="statement not covered" >i._parsed[h+t]=l=c[h],d&amp;&amp;(o()&amp;&amp;(d=!1),u=l);<span class="cstat-no" title="statement not covered" >i</span></span>._sorted=d}<span class="cstat-no" title="statement not covered" ></span>a</span>&amp;&amp;x(this,c)}<span class="fstat-no" title="function not covered" ></span>pa</span>rsePrimitiveData(t,e,i,s){const{iScale:n,vScale:o}=<span class="cstat-no" title="statement not covered" >t,</span>a=<span class="cstat-no" title="statement not covered" >n.axis,</span>r=<span class="cstat-no" title="statement not covered" >o.axis,</span>h=<span class="cstat-no" title="statement not covered" >n.getLabels(),</span>l=<span class="cstat-no" title="statement not covered" >n===o,</span>c=<span class="cstat-no" title="statement not covered" >new Array(s);</span>let d,u,g;<span class="cstat-no" title="statement not covered" >for(d=0,u=s;d&lt;u;++d)<span class="cstat-no" title="statement not covered" >g=d+i,c[d]={[a]:l||n.parse(h[g],g),[r]:o.parse(e[g],g)};<span class="cstat-no" title="statement not covered" >r</span></span>eturn c}<span class="fstat-no" title="function not covered" ></span>pa</span>rseArrayData(t,e,i,s){const{xScale:n,yScale:o}=<span class="cstat-no" title="statement not covered" >t,</span>a=<span class="cstat-no" title="statement not covered" >new Array(s);</span>let r,h,l,c;<span class="cstat-no" title="statement not covered" >for(r=0,h=s;r&lt;h;++r)<span class="cstat-no" title="statement not covered" >l=r+i,c=e[l],a[r]={x:n.parse(c[0],l),y:o.parse(c[1],l)};<span class="cstat-no" title="statement not covered" >r</span></span>eturn a}<span class="fstat-no" title="function not covered" ></span>pa</span>rseObjectData(t,e,i,n){const{xScale:o,yScale:a}=<span class="cstat-no" title="statement not covered" >t,</span>{xAxisKey:r=<span class="branch-0 cbranch-no" title="branch not covered" >"x",</span>yAxisKey:h=<span class="branch-0 cbranch-no" title="branch not covered" >"y"}</span>=<span class="cstat-no" title="statement not covered" >this._parsing,</span>l=<span class="cstat-no" title="statement not covered" >new Array(n);</span>let c,d,u,g;<span class="cstat-no" title="statement not covered" >for(c=0,d=n;c&lt;d;++c)<span class="cstat-no" title="statement not covered" >u=c+i,g=e[u],l[c]={x:o.parse((0,s.f)(g,r),u),y:a.parse((0,s.f)(g,h),u)};<span class="cstat-no" title="statement not covered" >r</span></span>eturn l}<span class="fstat-no" title="function not covered" ></span>ge</span>tParsed(t){<span class="cstat-no" title="statement not covered" >return this._cachedMeta._parsed[t]}<span class="fstat-no" title="function not covered" ></span>ge</span>tDataElement(t){<span class="cstat-no" title="statement not covered" >return this._cachedMeta.data[t]}<span class="fstat-no" title="function not covered" ></span>ap</span>plyStack(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.chart,</span>n=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>o=<span class="cstat-no" title="statement not covered" >e[t.axis];<span class="cstat-no" title="statement not covered" ></span>return u({keys:d(s,!0),values:e._stacks[t.axis]._visualValues},o,n.index,{mode:i})}<span class="fstat-no" title="function not covered" ></span>up</span>dateRangeFromParsed(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >i[e.axis];</span>let o=<span class="cstat-no" title="statement not covered" >null===n?NaN:n;</span>const a=<span class="cstat-no" title="statement not covered" >s&amp;&amp;i._stacks[e.axis];<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;a&amp;&amp;(s.values=a,o=u(s,n,this._cachedMeta.index)),t.min=Math.min(t.min,o),t.max=Math.max(t.max,o)}<span class="fstat-no" title="function not covered" ></span>ge</span>tMinMax(t,e){const i=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>n=<span class="cstat-no" title="statement not covered" >i._parsed,</span>o=<span class="cstat-no" title="statement not covered" >i._sorted&amp;&amp;t===i.iScale,</span>a=<span class="cstat-no" title="statement not covered" >n.length,</span>r=<span class="cstat-no" title="statement not covered" >this._getOtherScale(t),</span>h=<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >t&amp;&amp;!e.hidden&amp;&amp;e._stacked&amp;&amp;{keys:d(i,!0),values:null})</span>(e,i,this.chart),</span>l=<span class="cstat-no" title="statement not covered" >{min:Number.POSITIVE_INFINITY,max:Number.NEGATIVE_INFINITY},</span>{min:c,max:u}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const{min:e,max:i,minDefined:s,maxDefined:n}=<span class="cstat-no" title="statement not covered" >t.getUserBounds();<span class="cstat-no" title="statement not covered" ></span>return{min:s?e:Number.NEGATIVE_INFINITY,max:n?i:Number.POSITIVE_INFINITY}}</span>(r);</span>let g,f;function <span class="fstat-no" title="function not covered" >p(</span>){<span class="cstat-no" title="statement not covered" >f=n[g];c</span>onst e=<span class="cstat-no" title="statement not covered" >f[r.axis];<span class="cstat-no" title="statement not covered" ></span>return!(0,s.g)(f[t.axis])||c&gt;e||u&lt;e}<span class="cstat-no" title="statement not covered" ></span>for(g=0;g&lt;a&amp;&amp;(p()||(this.updateRangeFromParsed(l,t,f,h),!o));++g);<span class="cstat-no" title="statement not covered" >i</span>f(o)<span class="cstat-no" title="statement not covered" >for(g=a-1;g&gt;=0;--g)<span class="cstat-no" title="statement not covered" >if(!p()){<span class="cstat-no" title="statement not covered" >this.updateRangeFromParsed(l,t,f,h);<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>r</span></span></span>eturn l}<span class="fstat-no" title="function not covered" ></span>ge</span>tAllParsedValues(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta._parsed,</span>i=<span class="cstat-no" title="statement not covered" >[];</span>let n,o,a;<span class="cstat-no" title="statement not covered" >for(n=0,o=e.length;n&lt;o;++n)<span class="cstat-no" title="statement not covered" >a=e[n][t.axis],(0,s.g)(a)&amp;&amp;i.push(a);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaxOverflow(){<span class="cstat-no" title="statement not covered" >return!1}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelAndValue(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>i=<span class="cstat-no" title="statement not covered" >e.iScale,</span>s=<span class="cstat-no" title="statement not covered" >e.vScale,</span>n=<span class="cstat-no" title="statement not covered" >this.getParsed(t);<span class="cstat-no" title="statement not covered" ></span>return{label:i?""+i.getLabelForValue(n[i.axis]):"",value:s?""+s.getLabelForValue(n[s.axis]):""}}<span class="fstat-no" title="function not covered" ></span>_u</span>pdate(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>this.update(t||"default"),e._clip=<span class="fstat-no" title="function not covered" >fu</span>nction(t){let e,i,n,o;<span class="cstat-no" title="statement not covered" >return(0,s.i)(t)?(e=t.top,i=t.right,n=t.bottom,o=t.left):e=i=n=o=t,{top:e,right:i,bottom:n,left:o,disabled:!1===t}}</span>((0,s.v)(this.options.clip,<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >if(!1===i)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >c(t,i),</span>n=<span class="cstat-no" title="statement not covered" >c(e,i);<span class="cstat-no" title="statement not covered" ></span>return{top:n.end,right:s.end,bottom:n.start,left:s.start}}</span>(e.xScale,e.yScale,this.getMaxOverflow())))}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){}<span class="fstat-no" title="function not covered" >dr</span>aw(){const t=<span class="cstat-no" title="statement not covered" >this._ctx,</span>e=<span class="cstat-no" title="statement not covered" >this.chart,</span>i=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>s=<span class="cstat-no" title="statement not covered" >i.data||[],</span>n=<span class="cstat-no" title="statement not covered" >e.chartArea,</span>o=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >this._drawStart||0,</span>r=<span class="cstat-no" title="statement not covered" >this._drawCount||s.length-a,</span>h=<span class="cstat-no" title="statement not covered" >this.options.drawActiveElementsOnTop;</span>let l;<span class="cstat-no" title="statement not covered" >for(i.dataset&amp;&amp;i.dataset.draw(t,n,a,r),l=a;l&lt;a+r;++l){const e=<span class="cstat-no" title="statement not covered" >s[l];<span class="cstat-no" title="statement not covered" ></span>e.hidden||(e.active&amp;&amp;h?o.push(e):e.draw(t,n))}<span class="cstat-no" title="statement not covered" ></span>f</span>or(l=0;l&lt;o.length;++l)<span class="cstat-no" title="statement not covered" >o[l].draw(t,n)}<span class="fstat-no" title="function not covered" ></span></span>ge</span>tStyle(t,e){const i=<span class="cstat-no" title="statement not covered" >e?"active":"default";<span class="cstat-no" title="statement not covered" ></span>return void 0===t&amp;&amp;this._cachedMeta.dataset?this.resolveDatasetElementOptions(i):this.resolveDataElementOptions(t||0,i)}<span class="fstat-no" title="function not covered" ></span>ge</span>tContext(t,e,i){const n=<span class="cstat-no" title="statement not covered" >this.getDataset();</span>let o;<span class="cstat-no" title="statement not covered" >if(t&gt;=0&amp;&amp;t&lt;this._cachedMeta.data.length){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta.data[t];<span class="cstat-no" title="statement not covered" ></span>o=e.$context||(e.$context=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return(0,s.j)(t,{active:!1,dataIndex:e,parsed:void 0,raw:void 0,element:i,index:e,mode:"default",type:"data"})}</span>(this.getContext(),t,e)),o.parsed=this.getParsed(t),o.raw=n.data[t],o.index=o.dataIndex=t}</span>else <span class="cstat-no" title="statement not covered" >o=this.$context||(this.$context=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return(0,s.j)(t,{active:!1,dataset:void 0,datasetIndex:e,index:e,mode:"default",type:"dataset"})}</span>(this.chart.getContext(),this.index)),o.dataset=n,o.index=o.datasetIndex=this.index;<span class="cstat-no" title="statement not covered" >r</span></span>eturn o.active=!!e,o.mode=i,o}<span class="fstat-no" title="function not covered" ></span>re</span>solveDatasetElementOptions(t){<span class="cstat-no" title="statement not covered" >return this._resolveElementOptions(this.datasetElementType.id,t)}<span class="fstat-no" title="function not covered" ></span>re</span>solveDataElementOptions(t,e){<span class="cstat-no" title="statement not covered" >return this._resolveElementOptions(this.dataElementType.id,e,t)}<span class="fstat-no" title="function not covered" ></span>_r</span>esolveElementOptions(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >"default",</span>i){const n=<span class="cstat-no" title="statement not covered" >"active"===e,</span>o=<span class="cstat-no" title="statement not covered" >this._cachedDataOpts,</span>a=<span class="cstat-no" title="statement not covered" >t+"-"+e,</span>r=<span class="cstat-no" title="statement not covered" >o[a],</span>h=<span class="cstat-no" title="statement not covered" >this.enableOptionSharing&amp;&amp;(0,s.h)(i);<span class="cstat-no" title="statement not covered" ></span>if(r)<span class="cstat-no" title="statement not covered" >return v(r,h);c</span></span>onst l=<span class="cstat-no" title="statement not covered" >this.chart.config,</span>c=<span class="cstat-no" title="statement not covered" >l.datasetElementScopeKeys(this._type,t),</span>d=<span class="cstat-no" title="statement not covered" >n?[`${t}Hover`,"hover",t,""]:[t,""],</span>u=<span class="cstat-no" title="statement not covered" >l.getOptionScopes(this.getDataset(),c),</span>g=<span class="cstat-no" title="statement not covered" >Object.keys(s.d.elements[t]),</span>f=<span class="cstat-no" title="statement not covered" >l.resolveNamedOptions(u,g,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.getContext(i,n,e))</span>,d);<span class="cstat-no" title="statement not covered" ></span>return f.$shared&amp;&amp;(f.$shared=h,o[a]=Object.freeze(v(f,h))),f}<span class="fstat-no" title="function not covered" ></span>_r</span>esolveAnimations(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.chart,</span>n=<span class="cstat-no" title="statement not covered" >this._cachedDataOpts,</span>o=<span class="cstat-no" title="statement not covered" >`animation-${e}`,</span>a=<span class="cstat-no" title="statement not covered" >n[o];<span class="cstat-no" title="statement not covered" ></span>if(a)<span class="cstat-no" title="statement not covered" >return a;l</span></span>et r;<span class="cstat-no" title="statement not covered" >if(!1!==s.options.animation){const s=<span class="cstat-no" title="statement not covered" >this.chart.config,</span>n=<span class="cstat-no" title="statement not covered" >s.datasetAnimationScopeKeys(this._type,e),</span>o=<span class="cstat-no" title="statement not covered" >s.getOptionScopes(this.getDataset(),n);<span class="cstat-no" title="statement not covered" ></span>r=s.createResolver(o,this.getContext(t,i,e))}</span>c</span>onst h=<span class="cstat-no" title="statement not covered" >new l(s,r&amp;&amp;r.animations);<span class="cstat-no" title="statement not covered" ></span>return r&amp;&amp;r._cacheable&amp;&amp;(n[o]=Object.freeze(h)),h}<span class="fstat-no" title="function not covered" ></span>ge</span>tSharedOptions(t){<span class="cstat-no" title="statement not covered" >if(t.$shared)<span class="cstat-no" title="statement not covered" >return this._sharedOptions||(this._sharedOptions=Object.assign({},t))}<span class="fstat-no" title="function not covered" ></span></span>in</span>cludeOptions(t,e){<span class="cstat-no" title="statement not covered" >return!e||_(t)||this.chart._animationsDisabled}<span class="fstat-no" title="function not covered" ></span>_g</span>etSharedOptions(t,e){const i=<span class="cstat-no" title="statement not covered" >this.resolveDataElementOptions(t,e),</span>s=<span class="cstat-no" title="statement not covered" >this._sharedOptions,</span>n=<span class="cstat-no" title="statement not covered" >this.getSharedOptions(i),</span>o=<span class="cstat-no" title="statement not covered" >this.includeOptions(e,n)||n!==s;<span class="cstat-no" title="statement not covered" ></span>return this.updateSharedOptions(n,e,i),{sharedOptions:n,includeOptions:o}}<span class="fstat-no" title="function not covered" ></span>up</span>dateElement(t,e,i,s){<span class="cstat-no" title="statement not covered" >_(s)?Object.assign(t,i):this._resolveAnimations(e,s).update(t,i)}<span class="fstat-no" title="function not covered" ></span>up</span>dateSharedOptions(t,e,i){<span class="cstat-no" title="statement not covered" >t&amp;&amp;!_(e)&amp;&amp;this._resolveAnimations(void 0,e).update(t,i)}<span class="fstat-no" title="function not covered" ></span>_s</span>etStyle(t,e,i,s){<span class="cstat-no" title="statement not covered" >t.active=s;c</span>onst n=<span class="cstat-no" title="statement not covered" >this.getStyle(e,s);<span class="cstat-no" title="statement not covered" ></span>this._resolveAnimations(e,i,s).update(t,{options:!s&amp;&amp;this.getSharedOptions(n)||n})}<span class="fstat-no" title="function not covered" ></span>re</span>moveHoverStyle(t,e,i){<span class="cstat-no" title="statement not covered" >this._setStyle(t,i,"active",!1)}<span class="fstat-no" title="function not covered" ></span>se</span>tHoverStyle(t,e,i){<span class="cstat-no" title="statement not covered" >this._setStyle(t,i,"active",!0)}<span class="fstat-no" title="function not covered" ></span>_r</span>emoveDatasetHoverStyle(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta.dataset;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;this._setStyle(t,void 0,"active",!1)}<span class="fstat-no" title="function not covered" ></span>_s</span>etDatasetHoverStyle(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta.dataset;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;this._setStyle(t,void 0,"active",!0)}<span class="fstat-no" title="function not covered" ></span>_r</span>esyncElements(t){const e=<span class="cstat-no" title="statement not covered" >this._data,</span>i=<span class="cstat-no" title="statement not covered" >this._cachedMeta.data;<span class="cstat-no" title="statement not covered" ></span>for(const[a,r,h]of this._syncList)<span class="cstat-no" title="statement not covered" >this[a](r,h);<span class="cstat-no" title="statement not covered" >t</span></span>his._syncList=[];c</span>onst s=<span class="cstat-no" title="statement not covered" >i.length,</span>n=<span class="cstat-no" title="statement not covered" >e.length,</span>o=<span class="cstat-no" title="statement not covered" >Math.min(n,s);<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;this.parse(0,o),n&gt;s?this._insertElements(s,n-s,t):n&lt;s&amp;&amp;this._removeElements(n,s-n)}<span class="fstat-no" title="function not covered" ></span>_i</span>nsertElements(t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>{const s=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>n=<span class="cstat-no" title="statement not covered" >s.data,</span>o=<span class="cstat-no" title="statement not covered" >t+e;</span>let a;const r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >for(t.length+=e,a=t.length-1;a&gt;=o;a--)<span class="cstat-no" title="statement not covered" >t[a]=t[a-e]}</span></span>;<span class="cstat-no" title="statement not covered" ></span>for(r(n),a=t;a&lt;o;++a)<span class="cstat-no" title="statement not covered" >n[a]=new this.dataElementType;<span class="cstat-no" title="statement not covered" >t</span></span>his._parsing&amp;&amp;r(s._parsed),this.parse(t,e),i&amp;&amp;this.updateElements(n,t,e,"reset")}<span class="fstat-no" title="function not covered" ></span>up</span>dateElements(t,e,i,s){}<span class="fstat-no" title="function not covered" >_r</span>emoveElements(t,e){const i=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>if(this._parsing){const s=<span class="cstat-no" title="statement not covered" >i._parsed.splice(t,e);<span class="cstat-no" title="statement not covered" ></span>i._stacked&amp;&amp;b(i,s)}<span class="cstat-no" title="statement not covered" ></span>i</span>.data.splice(t,e)}<span class="fstat-no" title="function not covered" ></span>_s</span>ync(t){<span class="cstat-no" title="statement not covered" >if(this._parsing)<span class="cstat-no" title="statement not covered" >this._syncList.push(t);e</span>lse{const[e,i,s]=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>this[e](i,s)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.chart._dataChanges.push([this.index,...t])}<span class="fstat-no" title="function not covered" ></span>_o</span>nDataPush(){const t=<span class="cstat-no" title="statement not covered" >arguments.length;<span class="cstat-no" title="statement not covered" ></span>this._sync(["_insertElements",this.getDataset().data.length-t,t])}<span class="fstat-no" title="function not covered" ></span>_o</span>nDataPop(){<span class="cstat-no" title="statement not covered" >this._sync(["_removeElements",this._cachedMeta.data.length-1,1])}<span class="fstat-no" title="function not covered" ></span>_o</span>nDataShift(){<span class="cstat-no" title="statement not covered" >this._sync(["_removeElements",0,1])}<span class="fstat-no" title="function not covered" ></span>_o</span>nDataSplice(t,e){<span class="cstat-no" title="statement not covered" >e&amp;&amp;this._sync(["_removeElements",t,e]);c</span>onst i=<span class="cstat-no" title="statement not covered" >arguments.length-2;<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;this._sync(["_insertElements",t,i])}<span class="fstat-no" title="function not covered" ></span>_o</span>nDataUnshift(){<span class="cstat-no" title="statement not covered" >this._sync(["_insertElements",0,arguments.length])}</span>}function <span class="fstat-no" title="function not covered" >M(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.iScale,</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(!t._cache.$bar){const i=<span class="cstat-no" title="statement not covered" >t.getMatchingVisibleMetas(e);</span>let n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >i.length;</span>e&lt;s;e++)<span class="cstat-no" title="statement not covered" >n=n.concat(i[e].controller.getAllParsedValues(t));<span class="cstat-no" title="statement not covered" >t</span></span>._cache.$bar=(0,s._)(n.sort((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t-e)</span>))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t._cache.$bar}</span>(e,t.type);</span>let n,o,a,r,h=<span class="cstat-no" title="statement not covered" >e._length;</span>const l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >32767!==a&amp;&amp;-32768!==a&amp;&amp;((0,s.h)(r)&amp;&amp;(h=Math.min(h,Math.abs(a-r)||h)),r=a)}</span>;<span class="cstat-no" title="statement not covered" ></span>for(n=0,o=i.length;n&lt;o;++n)<span class="cstat-no" title="statement not covered" >a=e.getPixelForValue(i[n]),l();<span class="cstat-no" title="statement not covered" >f</span></span>or(r=void 0,n=0,o=e.ticks.length;n&lt;o;++n)<span class="cstat-no" title="statement not covered" >a=e.getPixelForTick(n),l();<span class="cstat-no" title="statement not covered" >r</span></span>eturn h}</span>function <span class="fstat-no" title="function not covered" >w(</span>t,e,i,n){<span class="cstat-no" title="statement not covered" >return(0,s.b)(t)?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >i.parse(t[0],s),</span>o=<span class="cstat-no" title="statement not covered" >i.parse(t[1],s),</span>a=<span class="cstat-no" title="statement not covered" >Math.min(n,o),</span>r=<span class="cstat-no" title="statement not covered" >Math.max(n,o);</span>let h=<span class="cstat-no" title="statement not covered" >a,</span>l=<span class="cstat-no" title="statement not covered" >r;<span class="cstat-no" title="statement not covered" ></span>Math.abs(a)&gt;Math.abs(r)&amp;&amp;(h=r,l=a),e[i.axis]=l,e._custom={barStart:h,barEnd:l,start:n,end:o,min:a,max:r}}</span>(t,e,i,n):e[i.axis]=i.parse(t,n),e}</span>function <span class="fstat-no" title="function not covered" >k(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >t.iScale,</span>o=<span class="cstat-no" title="statement not covered" >t.vScale,</span>a=<span class="cstat-no" title="statement not covered" >n.getLabels(),</span>r=<span class="cstat-no" title="statement not covered" >n===o,</span>h=<span class="cstat-no" title="statement not covered" >[];</span>let l,c,d,u;<span class="cstat-no" title="statement not covered" >for(l=i,c=i+s;l&lt;c;++l)<span class="cstat-no" title="statement not covered" >u=e[l],d={},d[n.axis]=r||n.parse(a[l],l),h.push(w(u,d,o,l));<span class="cstat-no" title="statement not covered" >r</span></span>eturn h}</span>function <span class="fstat-no" title="function not covered" >S(</span>t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;void 0!==t.barStart&amp;&amp;void 0!==t.barEnd}</span>function <span class="fstat-no" title="function not covered" >D(</span>t,e,i,s){let n=<span class="cstat-no" title="statement not covered" >e.borderSkipped;</span>const o=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >return void(t.borderSkipped=o);<span class="cstat-no" title="statement not covered" >i</span></span>f(!0===n)<span class="cstat-no" title="statement not covered" >return void(t.borderSkipped={top:!0,right:!0,bottom:!0,left:!0});c</span></span>onst{start:a,end:r,reverse:h,top:l,bottom:c}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){let e,i,s,n,o;<span class="cstat-no" title="statement not covered" >return t.horizontal?(e=t.base&gt;t.x,i="left",s="right"):(e=t.base&lt;t.y,i="bottom",s="top"),e?(n="end",o="start"):(n="start",o="end"),{start:i,end:s,reverse:e,top:n,bottom:o}}</span>(t);<span class="cstat-no" title="statement not covered" ></span>"middle"===n&amp;&amp;i&amp;&amp;(t.enableBorderRadius=!0,(i._top||0)===s?n=l:(i._bottom||0)===s?n=c:(o[P(c,a,r,h)]=!0,n=l)),o[P(n,a,r,h)]=!0,t.borderSkipped=o}</span>function <span class="fstat-no" title="function not covered" >P(</span>t,e,i,s){var n,o,a;<span class="cstat-no" title="statement not covered" >return s?(a=i,t=A(t=(n=t)===(o=e)?a:n===a?o:n,i,e)):t=A(t,e,i),t}</span>function <span class="fstat-no" title="function not covered" >A(</span>t,e,i){<span class="cstat-no" title="statement not covered" >return"start"===t?e:"end"===t?i:t}</span>function <span class="fstat-no" title="function not covered" >C(</span>t,{inflateAmount:e},i){<span class="cstat-no" title="statement not covered" >t.inflateAmount="auto"===e?1===i?.33:0:e}</span>class T extends y{static id=<span class="cstat-no" title="statement not covered" >"bar";</span>static defaults=<span class="cstat-no" title="statement not covered" >{datasetElementType:!1,dataElementType:"bar",categoryPercentage:.8,barPercentage:.9,grouped:!0,animations:{numbers:{type:"number",properties:["x","y","base","width","height"]}}};</span>static overrides=<span class="cstat-no" title="statement not covered" >{scales:{_index_:{type:"category",offset:!0,grid:{offset:!0}},_value_:{type:"linear",beginAtZero:!0}}};<span class="fstat-no" title="function not covered" ></span>pa</span>rsePrimitiveData(t,e,i,s){<span class="cstat-no" title="statement not covered" >return k(t,e,i,s)}<span class="fstat-no" title="function not covered" ></span>pa</span>rseArrayData(t,e,i,s){<span class="cstat-no" title="statement not covered" >return k(t,e,i,s)}<span class="fstat-no" title="function not covered" ></span>pa</span>rseObjectData(t,e,i,n){const{iScale:o,vScale:a}=<span class="cstat-no" title="statement not covered" >t,</span>{xAxisKey:r=<span class="branch-0 cbranch-no" title="branch not covered" >"x",</span>yAxisKey:h=<span class="branch-0 cbranch-no" title="branch not covered" >"y"}</span>=<span class="cstat-no" title="statement not covered" >this._parsing,</span>l=<span class="cstat-no" title="statement not covered" >"x"===o.axis?r:h,</span>c=<span class="cstat-no" title="statement not covered" >"x"===a.axis?r:h,</span>d=<span class="cstat-no" title="statement not covered" >[];</span>let u,g,f,p;<span class="cstat-no" title="statement not covered" >for(u=i,g=i+n;u&lt;g;++u)<span class="cstat-no" title="statement not covered" >p=e[u],f={},f[o.axis]=o.parse((0,s.f)(p,l),u),d.push(w((0,s.f)(p,c),f,a,u));<span class="cstat-no" title="statement not covered" >r</span></span>eturn d}<span class="fstat-no" title="function not covered" ></span>up</span>dateRangeFromParsed(t,e,i,s){<span class="cstat-no" title="statement not covered" >super.updateRangeFromParsed(t,e,i,s);c</span>onst n=<span class="cstat-no" title="statement not covered" >i._custom;<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;e===this._cachedMeta.vScale&amp;&amp;(t.min=Math.min(t.min,n.min),t.max=Math.max(t.max,n.max))}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaxOverflow(){<span class="cstat-no" title="statement not covered" >return 0}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelAndValue(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>{iScale:i,vScale:s}=<span class="cstat-no" title="statement not covered" >e,</span>n=<span class="cstat-no" title="statement not covered" >this.getParsed(t),</span>o=<span class="cstat-no" title="statement not covered" >n._custom,</span>a=<span class="cstat-no" title="statement not covered" >S(o)?"["+o.start+", "+o.end+"]":""+s.getLabelForValue(n[s.axis]);<span class="cstat-no" title="statement not covered" ></span>return{label:""+i.getLabelForValue(n[i.axis]),value:a}}<span class="fstat-no" title="function not covered" ></span>in</span>itialize(){<span class="cstat-no" title="statement not covered" >this.enableOptionSharing=!0,super.initialize();<span class="cstat-no" title="statement not covered" >t</span>his._cachedMeta.stack=this.getDataset().stack}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>this.updateElements(e.data,0,e.data.length,t)}<span class="fstat-no" title="function not covered" ></span>up</span>dateElements(t,e,i,n){const o=<span class="cstat-no" title="statement not covered" >"reset"===n,</span>{index:a,_cachedMeta:{vScale:r}}=<span class="cstat-no" title="statement not covered" >this,</span>h=<span class="cstat-no" title="statement not covered" >r.getBasePixel(),</span>l=<span class="cstat-no" title="statement not covered" >r.isHorizontal(),</span>c=<span class="cstat-no" title="statement not covered" >this._getRuler(),</span>{sharedOptions:d,includeOptions:u}=<span class="cstat-no" title="statement not covered" >this._getSharedOptions(e,n);<span class="cstat-no" title="statement not covered" ></span>for(let g=<span class="cstat-no" title="statement not covered" >e;</span>g&lt;e+i;g++){const e=<span class="cstat-no" title="statement not covered" >this.getParsed(g),</span>i=<span class="cstat-no" title="statement not covered" >o||(0,s.k)(e[r.axis])?{base:h,head:h}:this._calculateBarValuePixels(g),</span>f=<span class="cstat-no" title="statement not covered" >this._calculateBarIndexPixels(g,c),</span>p=<span class="cstat-no" title="statement not covered" >(e._stacks||{})[r.axis],</span>x=<span class="cstat-no" title="statement not covered" >{horizontal:l,base:i.base,enableBorderRadius:!p||S(e._custom)||a===p._top||a===p._bottom,x:l?i.head:f.center,y:l?f.center:i.head,height:l?f.size:Math.abs(i.size),width:l?Math.abs(i.size):f.size};<span class="cstat-no" title="statement not covered" ></span>u&amp;&amp;(x.options=d||this.resolveDataElementOptions(g,t[g].active?"active":n));c</span>onst m=<span class="cstat-no" title="statement not covered" >x.options||t[g].options;<span class="cstat-no" title="statement not covered" ></span>D(x,m,p,a),C(x,m,c.ratio),this.updateElement(t[g],g,x,n)}</span>}<span class="fstat-no" title="function not covered" ></span>_g</span>etStacks(t,e){const{iScale:i}=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>n=<span class="cstat-no" title="statement not covered" >i.getMatchingVisibleMetas(this._type).filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.controller.options.grouped)</span>),</span>o=<span class="cstat-no" title="statement not covered" >i.options.stacked,</span>a=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >this._cachedMeta.controller.getParsed(e),</span>h=<span class="cstat-no" title="statement not covered" >r&amp;&amp;r[i.axis],</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >t._parsed.find((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t[i.axis]===h)</span>),</span>n=<span class="cstat-no" title="statement not covered" >e&amp;&amp;e[t.vScale.axis];<span class="cstat-no" title="statement not covered" ></span>if((0,s.k)(n)||isNaN(n))<span class="cstat-no" title="statement not covered" >return!0}</span></span>;<span class="cstat-no" title="statement not covered" ></span>for(const s of n)<span class="cstat-no" title="statement not covered" >if((void 0===e||!l(s))&amp;&amp;((!1===o||-1===a.indexOf(s.stack)||void 0===o&amp;&amp;void 0===s.stack)&amp;&amp;a.push(s.stack),s.index===t))<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn a.length||a.push(void 0),a}<span class="fstat-no" title="function not covered" ></span>_g</span>etStackCount(t){<span class="cstat-no" title="statement not covered" >return this._getStacks(void 0,t).length}<span class="fstat-no" title="function not covered" ></span>_g</span>etAxisCount(){<span class="cstat-no" title="statement not covered" >return this._getAxis().length}<span class="fstat-no" title="function not covered" ></span>ge</span>tFirstScaleIdForIndexAxis(){const t=<span class="cstat-no" title="statement not covered" >this.chart.scales,</span>e=<span class="cstat-no" title="statement not covered" >this.chart.options.indexAxis;<span class="cstat-no" title="statement not covered" ></span>return Object.keys(t).filter((<span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >t[i].axis===e)</span>).shift()}<span class="fstat-no" title="function not covered" ></span>_g</span>etAxis(){const t=<span class="cstat-no" title="statement not covered" >{},</span>e=<span class="cstat-no" title="statement not covered" >this.getFirstScaleIdForIndexAxis();<span class="cstat-no" title="statement not covered" ></span>for(const i of this.chart.data.datasets)<span class="cstat-no" title="statement not covered" >t[(0,s.v)("x"===this.chart.options.indexAxis?i.xAxisID:i.yAxisID,e)]=!0;<span class="cstat-no" title="statement not covered" >r</span></span>eturn Object.keys(t)}<span class="fstat-no" title="function not covered" ></span>_g</span>etStackIndex(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this._getStacks(t,i),</span>n=<span class="cstat-no" title="statement not covered" >void 0!==e?s.indexOf(e):-1;<span class="cstat-no" title="statement not covered" ></span>return-1===n?s.length-1:n}<span class="fstat-no" title="function not covered" ></span>_g</span>etRuler(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>i=<span class="cstat-no" title="statement not covered" >e.iScale,</span>s=<span class="cstat-no" title="statement not covered" >[];</span>let n,o;<span class="cstat-no" title="statement not covered" >for(n=0,o=e.data.length;n&lt;o;++n)<span class="cstat-no" title="statement not covered" >s.push(i.getPixelForValue(this.getParsed(n)[i.axis],n));c</span></span>onst a=<span class="cstat-no" title="statement not covered" >t.barThickness;<span class="cstat-no" title="statement not covered" ></span>return{min:a||M(e),pixels:s,start:i._startPixel,end:i._endPixel,stackCount:this._getStackCount(),scale:i,grouped:t.grouped,ratio:a?1:t.categoryPercentage*t.barPercentage}}<span class="fstat-no" title="function not covered" ></span>_c</span>alculateBarValuePixels(t){const{_cachedMeta:{vScale:e,_stacked:i,index:n},options:{base:o,minBarLength:a}}=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >o||0,</span>h=<span class="cstat-no" title="statement not covered" >this.getParsed(t),</span>l=<span class="cstat-no" title="statement not covered" >h._custom,</span>c=<span class="cstat-no" title="statement not covered" >S(l);</span>let d,u,g=<span class="cstat-no" title="statement not covered" >h[e.axis],</span>f=<span class="cstat-no" title="statement not covered" >0,</span>p=<span class="cstat-no" title="statement not covered" >i?this.applyStack(e,h,i):g;<span class="cstat-no" title="statement not covered" ></span>p!==g&amp;&amp;(f=p-g,p=g),c&amp;&amp;(g=l.barStart,p=l.barEnd-l.barStart,0!==g&amp;&amp;(0,s.s)(g)!==(0,s.s)(l.barEnd)&amp;&amp;(f=0),f+=g);c</span>onst x=<span class="cstat-no" title="statement not covered" >(0,s.k)(o)||c?f:o;</span>let m=<span class="cstat-no" title="statement not covered" >e.getPixelForValue(x);<span class="cstat-no" title="statement not covered" ></span>if(d=this.chart.getDataVisibility(t)?e.getPixelForValue(f+p):m,u=d-m,Math.abs(u)&lt;a){<span class="cstat-no" title="statement not covered" >u=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return 0!==t?(0,s.s)(t):(e.isHorizontal()?1:-1)*(e.min&gt;=i?1:-1)}</span>(u,e,r)*a,g===r&amp;&amp;(m-=u/2);c</span>onst t=<span class="cstat-no" title="statement not covered" >e.getPixelForDecimal(0),</span>o=<span class="cstat-no" title="statement not covered" >e.getPixelForDecimal(1),</span>l=<span class="cstat-no" title="statement not covered" >Math.min(t,o),</span>f=<span class="cstat-no" title="statement not covered" >Math.max(t,o);<span class="cstat-no" title="statement not covered" ></span>m=Math.max(Math.min(m,f),l),d=m+u,i&amp;&amp;!c&amp;&amp;(h._stacks[e.axis]._visualValues[n]=e.getValueForPixel(d)-e.getValueForPixel(m))}<span class="cstat-no" title="statement not covered" ></span>i</span>f(m===e.getPixelForValue(r)){const t=<span class="cstat-no" title="statement not covered" >(0,s.s)(u)*e.getLineWidthForValue(r)/2;<span class="cstat-no" title="statement not covered" ></span>m+=t,u-=t}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{size:u,base:m,head:d,center:d+u/2}}<span class="fstat-no" title="function not covered" ></span>_c</span>alculateBarIndexPixels(t,e){const i=<span class="cstat-no" title="statement not covered" >e.scale,</span>n=<span class="cstat-no" title="statement not covered" >this.options,</span>o=<span class="cstat-no" title="statement not covered" >n.skipNull,</span>a=<span class="cstat-no" title="statement not covered" >(0,s.v)(n.maxBarThickness,1/0);</span>let r,h;const l=<span class="cstat-no" title="statement not covered" >this._getAxisCount();<span class="cstat-no" title="statement not covered" ></span>if(e.grouped){const i=<span class="cstat-no" title="statement not covered" >o?this._getStackCount(t):e.stackCount,</span>c=<span class="cstat-no" title="statement not covered" >"flex"===n.barThickness?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >e.pixels,</span>o=<span class="cstat-no" title="statement not covered" >n[t];</span>let a=<span class="cstat-no" title="statement not covered" >t&gt;0?n[t-1]:null,</span>r=<span class="cstat-no" title="statement not covered" >t&lt;n.length-1?n[t+1]:null;</span>const h=<span class="cstat-no" title="statement not covered" >i.categoryPercentage;<span class="cstat-no" title="statement not covered" ></span>null===a&amp;&amp;(a=o-(null===r?e.end-e.start:r-o)),null===r&amp;&amp;(r=o+o-a);c</span>onst l=<span class="cstat-no" title="statement not covered" >o-(o-Math.min(a,r))/2*h;<span class="cstat-no" title="statement not covered" ></span>return{chunk:Math.abs(r-a)/2*h/s,ratio:i.barPercentage,start:l}}</span>(t,e,n,i*l):<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,n){const o=<span class="cstat-no" title="statement not covered" >i.barThickness;</span>let a,r;<span class="cstat-no" title="statement not covered" >return(0,s.k)(o)?(a=e.min*i.categoryPercentage,r=i.barPercentage):(a=o*n,r=1),{chunk:a/n,ratio:r,start:e.pixels[t]-a/2}}</span>(t,e,n,i*l),</span>d=<span class="cstat-no" title="statement not covered" >"x"===this.chart.options.indexAxis?this.getDataset().xAxisID:this.getDataset().yAxisID,</span>u=<span class="cstat-no" title="statement not covered" >this._getAxis().indexOf((0,s.v)(d,this.getFirstScaleIdForIndexAxis())),</span>g=<span class="cstat-no" title="statement not covered" >this._getStackIndex(this.index,this._cachedMeta.stack,o?t:void 0)+u;<span class="cstat-no" title="statement not covered" ></span>r=c.start+c.chunk*g+c.chunk/2,h=Math.min(a,c.chunk*c.ratio)}</span>else <span class="cstat-no" title="statement not covered" >r=i.getPixelForValue(this.getParsed(t)[i.axis],t),h=Math.min(a,e.min*e.ratio);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{base:r-h/2,head:r+h/2,center:r,size:h}}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>e=<span class="cstat-no" title="statement not covered" >t.vScale,</span>i=<span class="cstat-no" title="statement not covered" >t.data,</span>s=<span class="cstat-no" title="statement not covered" >i.length;</span>let n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;n&lt;s;++n)<span class="cstat-no" title="statement not covered" >null===this.getParsed(n)[e.axis]||i[n].hidden||i[n].draw(this._ctx)}</span></span>}class O extends y{static id=<span class="cstat-no" title="statement not covered" >"doughnut";</span>static defaults=<span class="cstat-no" title="statement not covered" >{datasetElementType:!1,dataElementType:"arc",animation:{animateRotate:!0,animateScale:!1},animations:{numbers:{type:"number",properties:["circumference","endAngle","innerRadius","outerRadius","startAngle","x","y","offset","borderWidth","spacing"]}},cutout:"50%",rotation:0,circumference:360,radius:"100%",spacing:0,indexAxis:"r"};</span>static descriptors=<span class="cstat-no" title="statement not covered" >{_scriptable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"spacing"!==t,</span>_indexable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"spacing"!==t&amp;&amp;!t.startsWith("borderDash")&amp;&amp;!t.startsWith("hoverBorderDash")}</span>;</span>static overrides=<span class="cstat-no" title="statement not covered" >{aspectRatio:1,plugins:{legend:{labels:{<span class="fstat-no" title="function not covered" >ge</span>nerateLabels(t){const e=<span class="cstat-no" title="statement not covered" >t.data,</span>{labels:{pointStyle:i,textAlign:s,color:n,useBorderRadius:o,borderRadius:a}}=<span class="cstat-no" title="statement not covered" >t.legend.options;<span class="cstat-no" title="statement not covered" ></span>return e.labels.length&amp;&amp;e.datasets.length?e.labels.map((<span class="fstat-no" title="function not covered" >(e</span>,r)=&gt;{const h=<span class="cstat-no" title="statement not covered" >t.getDatasetMeta(0).controller.getStyle(r);<span class="cstat-no" title="statement not covered" ></span>return{text:e,fillStyle:h.backgroundColor,fontColor:n,hidden:!t.getDataVisibility(r),lineDash:h.borderDash,lineDashOffset:h.borderDashOffset,lineJoin:h.borderJoinStyle,lineWidth:h.borderWidth,strokeStyle:h.borderColor,textAlign:s,pointStyle:i,borderRadius:o&amp;&amp;(a||h.borderRadius),index:r}}</span>)):[]}</span>},<span class="fstat-no" title="function not covered" >on</span>Click(t,e,i){<span class="cstat-no" title="statement not covered" >i.chart.toggleDataVisibility(e.index),i.chart.update()}</span>}}};<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >super(t,e),this.enableOptionSharing=!0,this.innerRadius=void 0,this.outerRadius=void 0,this.offsetX=void 0,this.offsetY=void 0}<span class="fstat-no" title="function not covered" ></span>li</span>nkScales(){}<span class="fstat-no" title="function not covered" >pa</span>rse(t,e){const i=<span class="cstat-no" title="statement not covered" >this.getDataset().data,</span>n=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>if(!1===this._parsing)<span class="cstat-no" title="statement not covered" >n._parsed=i;e</span>lse{let o,a,r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >+i[t];<span class="cstat-no" title="statement not covered" ></span></span>if((0,s.i)(i[t])){const{key:t=<span class="branch-0 cbranch-no" title="branch not covered" >"value"}</span>=<span class="cstat-no" title="statement not covered" >this._parsing;<span class="cstat-no" title="statement not covered" ></span>r=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >+(0,s.f)(i[e],t)}<span class="cstat-no" title="statement not covered" ></span></span>f</span>or(o=t,a=t+e;o&lt;a;++o)<span class="cstat-no" title="statement not covered" >n._parsed[o]=r(o)}</span></span>}<span class="fstat-no" title="function not covered" ></span>_g</span>etRotation(){<span class="cstat-no" title="statement not covered" >return(0,s.t)(this.options.rotation-90)}<span class="fstat-no" title="function not covered" ></span>_g</span>etCircumference(){<span class="cstat-no" title="statement not covered" >return(0,s.t)(this.options.circumference)}<span class="fstat-no" title="function not covered" ></span>_g</span>etRotationExtents(){let t=<span class="cstat-no" title="statement not covered" >s.T,</span>e=<span class="cstat-no" title="statement not covered" >-s.T;<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;this.chart.data.datasets.length;++i)<span class="cstat-no" title="statement not covered" >if(this.chart.isDatasetVisible(i)&amp;&amp;this.chart.getDatasetMeta(i).type===this._type){const s=<span class="cstat-no" title="statement not covered" >this.chart.getDatasetMeta(i).controller,</span>n=<span class="cstat-no" title="statement not covered" >s._getRotation(),</span>o=<span class="cstat-no" title="statement not covered" >s._getCircumference();<span class="cstat-no" title="statement not covered" ></span>t=Math.min(t,n),e=Math.max(e,n+o)}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn{rotation:t,circumference:e-t}}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){const e=<span class="cstat-no" title="statement not covered" >this.chart,</span>{chartArea:i}=<span class="cstat-no" title="statement not covered" >e,</span>n=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>o=<span class="cstat-no" title="statement not covered" >n.data,</span>a=<span class="cstat-no" title="statement not covered" >this.getMaxBorderWidth()+this.getMaxOffset(o)+this.options.spacing,</span>r=<span class="cstat-no" title="statement not covered" >Math.max((Math.min(i.width,i.height)-a)/2,0),</span>h=<span class="cstat-no" title="statement not covered" >Math.min((0,s.m)(this.options.cutout,r),1),</span>l=<span class="cstat-no" title="statement not covered" >this._getRingWeight(this.index),</span>{circumference:c,rotation:d}=<span class="cstat-no" title="statement not covered" >this._getRotationExtents(),</span>{ratioX:u,ratioY:g,offsetX:f,offsetY:p}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){let n=<span class="cstat-no" title="statement not covered" >1,</span>o=<span class="cstat-no" title="statement not covered" >1,</span>a=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(e&lt;s.T){const h=<span class="cstat-no" title="statement not covered" >t,</span>l=<span class="cstat-no" title="statement not covered" >h+e,</span>c=<span class="cstat-no" title="statement not covered" >Math.cos(h),</span>d=<span class="cstat-no" title="statement not covered" >Math.sin(h),</span>u=<span class="cstat-no" title="statement not covered" >Math.cos(l),</span>g=<span class="cstat-no" title="statement not covered" >Math.sin(l),</span>f=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,n)=&gt;<span class="cstat-no" title="statement not covered" >(0,s.p)(t,h,l,!0)?1:Math.max(e,e*i,n,n*i),</span></span>p=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,n)=&gt;<span class="cstat-no" title="statement not covered" >(0,s.p)(t,h,l,!0)?-1:Math.min(e,e*i,n,n*i),</span></span>x=<span class="cstat-no" title="statement not covered" >f(0,c,u),</span>m=<span class="cstat-no" title="statement not covered" >f(s.H,d,g),</span>b=<span class="cstat-no" title="statement not covered" >p(s.P,c,u),</span>_=<span class="cstat-no" title="statement not covered" >p(s.P+s.H,d,g);<span class="cstat-no" title="statement not covered" ></span>n=(x-b)/2,o=(m-_)/2,a=-(x+b)/2,r=-(m+_)/2}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{ratioX:n,ratioY:o,offsetX:a,offsetY:r}}</span>(d,c,h),</span>x=<span class="cstat-no" title="statement not covered" >(i.width-a)/u,</span>m=<span class="cstat-no" title="statement not covered" >(i.height-a)/g,</span>b=<span class="cstat-no" title="statement not covered" >Math.max(Math.min(x,m)/2,0),</span>_=<span class="cstat-no" title="statement not covered" >(0,s.n)(this.options.radius,b),</span>v=<span class="cstat-no" title="statement not covered" >(_-Math.max(_*h,0))/this._getVisibleDatasetWeightTotal();<span class="cstat-no" title="statement not covered" ></span>this.offsetX=f*_,this.offsetY=p*_,n.total=this.calculateTotal(),this.outerRadius=_-v*this._getRingWeightOffset(this.index),this.innerRadius=Math.max(this.outerRadius-v*l,0),this.updateElements(o,0,o.length,t)}<span class="fstat-no" title="function not covered" ></span>_c</span>ircumference(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options,</span>n=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>o=<span class="cstat-no" title="statement not covered" >this._getCircumference();<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;i.animation.animateRotate||!this.chart.getDataVisibility(t)||null===n._parsed[t]||n.data[t].hidden?0:this.calculateCircumference(n._parsed[t]*o/s.T)}<span class="fstat-no" title="function not covered" ></span>up</span>dateElements(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >"reset"===s,</span>o=<span class="cstat-no" title="statement not covered" >this.chart,</span>a=<span class="cstat-no" title="statement not covered" >o.chartArea,</span>r=<span class="cstat-no" title="statement not covered" >o.options.animation,</span>h=<span class="cstat-no" title="statement not covered" >(a.left+a.right)/2,</span>l=<span class="cstat-no" title="statement not covered" >(a.top+a.bottom)/2,</span>c=<span class="cstat-no" title="statement not covered" >n&amp;&amp;r.animateScale,</span>d=<span class="cstat-no" title="statement not covered" >c?0:this.innerRadius,</span>u=<span class="cstat-no" title="statement not covered" >c?0:this.outerRadius,</span>{sharedOptions:g,includeOptions:f}=<span class="cstat-no" title="statement not covered" >this._getSharedOptions(e,s);</span>let p,x=<span class="cstat-no" title="statement not covered" >this._getRotation();<span class="cstat-no" title="statement not covered" ></span>for(p=0;p&lt;e;++p)<span class="cstat-no" title="statement not covered" >x+=this._circumference(p,n);<span class="cstat-no" title="statement not covered" >f</span></span>or(p=e;p&lt;e+i;++p){const e=<span class="cstat-no" title="statement not covered" >this._circumference(p,n),</span>i=<span class="cstat-no" title="statement not covered" >t[p],</span>o=<span class="cstat-no" title="statement not covered" >{x:h+this.offsetX,y:l+this.offsetY,startAngle:x,endAngle:x+e,circumference:e,outerRadius:u,innerRadius:d};<span class="cstat-no" title="statement not covered" ></span>f&amp;&amp;(o.options=g||this.resolveDataElementOptions(p,i.active?"active":s)),x+=e,this.updateElement(i,p,o,s)}</span>}<span class="fstat-no" title="function not covered" ></span>ca</span>lculateTotal(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>e=<span class="cstat-no" title="statement not covered" >t.data;</span>let i,s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(i=0;i&lt;e.length;i++){const n=<span class="cstat-no" title="statement not covered" >t._parsed[i];<span class="cstat-no" title="statement not covered" ></span>null===n||isNaN(n)||!this.chart.getDataVisibility(i)||e[i].hidden||(s+=Math.abs(n))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>ca</span>lculateCircumference(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta.total;<span class="cstat-no" title="statement not covered" ></span>return e&gt;0&amp;&amp;!isNaN(t)?s.T*(Math.abs(t)/e):0}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelAndValue(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>i=<span class="cstat-no" title="statement not covered" >this.chart,</span>n=<span class="cstat-no" title="statement not covered" >i.data.labels||[],</span>o=<span class="cstat-no" title="statement not covered" >(0,s.o)(e._parsed[t],i.options.locale);<span class="cstat-no" title="statement not covered" ></span>return{label:n[t]||"",value:o}}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaxBorderWidth(t){let e=<span class="cstat-no" title="statement not covered" >0;</span>const i=<span class="cstat-no" title="statement not covered" >this.chart;</span>let s,n,o,a,r;<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >for(s=0,n=i.data.datasets.length;s&lt;n;++s)<span class="cstat-no" title="statement not covered" >if(i.isDatasetVisible(s)){<span class="cstat-no" title="statement not covered" >o=i.getDatasetMeta(s),t=o.data,a=o.controller;<span class="cstat-no" title="statement not covered" >b</span>reak}<span class="cstat-no" title="statement not covered" ></span>i</span></span></span>f(!t)<span class="cstat-no" title="statement not covered" >return 0;<span class="cstat-no" title="statement not covered" >f</span></span>or(s=0,n=t.length;s&lt;n;++s)<span class="cstat-no" title="statement not covered" >r=a.resolveDataElementOptions(s),"inner"!==r.borderAlign&amp;&amp;(e=Math.max(e,r.borderWidth||0,r.hoverBorderWidth||0));<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaxOffset(t){let e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >t.length;</span>i&lt;s;++i){const t=<span class="cstat-no" title="statement not covered" >this.resolveDataElementOptions(i);<span class="cstat-no" title="statement not covered" ></span>e=Math.max(e,t.offset||0,t.hoverOffset||0)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}<span class="fstat-no" title="function not covered" ></span>_g</span>etRingWeightOffset(t){let e=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;t;++i)<span class="cstat-no" title="statement not covered" >this.chart.isDatasetVisible(i)&amp;&amp;(e+=this._getRingWeight(i));<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}<span class="fstat-no" title="function not covered" ></span>_g</span>etRingWeight(t){<span class="cstat-no" title="statement not covered" >return Math.max((0,s.v)(this.chart.data.datasets[t].weight,1),0)}<span class="fstat-no" title="function not covered" ></span>_g</span>etVisibleDatasetWeightTotal(){<span class="cstat-no" title="statement not covered" >return this._getRingWeightOffset(this.chart.data.datasets.length)||1}</span>}class E extends y{static id=<span class="cstat-no" title="statement not covered" >"line";</span>static defaults=<span class="cstat-no" title="statement not covered" >{datasetElementType:"line",dataElementType:"point",showLine:!0,spanGaps:!1};</span>static overrides=<span class="cstat-no" title="statement not covered" >{scales:{_index_:{type:"category"},_value_:{type:"linear"}}};<span class="fstat-no" title="function not covered" ></span>in</span>itialize(){<span class="cstat-no" title="statement not covered" >this.enableOptionSharing=!0,this.supportsDecimation=!0,super.initialize()}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){const e=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>{dataset:i,data:n=<span class="branch-0 cbranch-no" title="branch not covered" >[],</span>_dataset:o}=<span class="cstat-no" title="statement not covered" >e,</span>a=<span class="cstat-no" title="statement not covered" >this.chart._animationsDisabled;</span>let{start:r,count:h}=<span class="cstat-no" title="statement not covered" >(0,s.q)(e,n,a);<span class="cstat-no" title="statement not covered" ></span>this._drawStart=r,this._drawCount=h,(0,s.w)(e)&amp;&amp;(r=0,h=n.length),i._chart=this.chart,i._datasetIndex=this.index,i._decimated=!!o._decimated,i.points=n;c</span>onst l=<span class="cstat-no" title="statement not covered" >this.resolveDatasetElementOptions(t);<span class="cstat-no" title="statement not covered" ></span>this.options.showLine||(l.borderWidth=0),l.segment=this.options.segment,this.updateElement(i,void 0,{animated:!a,options:l},t),this.updateElements(n,r,h,t)}<span class="fstat-no" title="function not covered" ></span>up</span>dateElements(t,e,i,n){const o=<span class="cstat-no" title="statement not covered" >"reset"===n,</span>{iScale:a,vScale:r,_stacked:h,_dataset:l}=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>{sharedOptions:c,includeOptions:d}=<span class="cstat-no" title="statement not covered" >this._getSharedOptions(e,n),</span>u=<span class="cstat-no" title="statement not covered" >a.axis,</span>g=<span class="cstat-no" title="statement not covered" >r.axis,</span>{spanGaps:f,segment:p}=<span class="cstat-no" title="statement not covered" >this.options,</span>x=<span class="cstat-no" title="statement not covered" >(0,s.x)(f)?f:Number.POSITIVE_INFINITY,</span>m=<span class="cstat-no" title="statement not covered" >this.chart._animationsDisabled||o||"none"===n,</span>b=<span class="cstat-no" title="statement not covered" >e+i,</span>_=<span class="cstat-no" title="statement not covered" >t.length;</span>let v=<span class="cstat-no" title="statement not covered" >e&gt;0&amp;&amp;this.getParsed(e-1);<span class="cstat-no" title="statement not covered" ></span>for(let y=<span class="cstat-no" title="statement not covered" >0;</span>y&lt;_;++y){const i=<span class="cstat-no" title="statement not covered" >t[y],</span>f=<span class="cstat-no" title="statement not covered" >m?i:{};<span class="cstat-no" title="statement not covered" ></span>if(y&lt;e||y&gt;=b){<span class="cstat-no" title="statement not covered" >f.skip=!0;<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>c</span>onst _=<span class="cstat-no" title="statement not covered" >this.getParsed(y),</span>M=<span class="cstat-no" title="statement not covered" >(0,s.k)(_[g]),</span>w=<span class="cstat-no" title="statement not covered" >f[u]=a.getPixelForValue(_[u],y),</span>k=<span class="cstat-no" title="statement not covered" >f[g]=o||M?r.getBasePixel():r.getPixelForValue(h?this.applyStack(r,_,h):_[g],y);<span class="cstat-no" title="statement not covered" ></span>f.skip=isNaN(w)||isNaN(k)||M,f.stop=y&gt;0&amp;&amp;Math.abs(_[u]-v[u])&gt;x,p&amp;&amp;(f.parsed=_,f.raw=l.data[y]),d&amp;&amp;(f.options=c||this.resolveDataElementOptions(y,i.active?"active":n)),m||this.updateElement(i,y,f,n),v=_}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaxOverflow(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta,</span>e=<span class="cstat-no" title="statement not covered" >t.dataset,</span>i=<span class="cstat-no" title="statement not covered" >e.options&amp;&amp;e.options.borderWidth||0,</span>s=<span class="cstat-no" title="statement not covered" >t.data||[];<span class="cstat-no" title="statement not covered" ></span>if(!s.length)<span class="cstat-no" title="statement not covered" >return i;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >s[0].size(this.resolveDataElementOptions(0)),</span>o=<span class="cstat-no" title="statement not covered" >s[s.length-1].size(this.resolveDataElementOptions(s.length-1));<span class="cstat-no" title="statement not covered" ></span>return Math.max(i,n,o)/2}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(){const t=<span class="cstat-no" title="statement not covered" >this._cachedMeta;<span class="cstat-no" title="statement not covered" ></span>t.dataset.updateControlPoints(this.chart.chartArea,t.iScale.axis),super.draw()}</span>}class R extends O{static id=<span class="cstat-no" title="statement not covered" >"pie";</span>static defaults=<span class="cstat-no" title="statement not covered" >{cutout:0,rotation:0,circumference:360,radius:"100%"}}</span>function <span class="fstat-no" title="function not covered" >I(</span>t,e,i,n){const{controller:o,data:a,_sorted:r}=<span class="cstat-no" title="statement not covered" >t,</span>h=<span class="cstat-no" title="statement not covered" >o._cachedMeta.iScale,</span>l=<span class="cstat-no" title="statement not covered" >t.dataset&amp;&amp;t.dataset.options?t.dataset.options.spanGaps:null;<span class="cstat-no" title="statement not covered" ></span>if(h&amp;&amp;e===h.axis&amp;&amp;"r"!==e&amp;&amp;r&amp;&amp;a.length){const r=<span class="cstat-no" title="statement not covered" >h._reversePixels?s.A:s.B;<span class="cstat-no" title="statement not covered" ></span>if(!n){const n=<span class="cstat-no" title="statement not covered" >r(a,e,i);<span class="cstat-no" title="statement not covered" ></span>if(l){const{vScale:e}=<span class="cstat-no" title="statement not covered" >o._cachedMeta,</span>{_parsed:i}=<span class="cstat-no" title="statement not covered" >t,</span>a=<span class="cstat-no" title="statement not covered" >i.slice(0,n.lo+1).reverse().findIndex((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!(0,s.k)(t[e.axis]))</span>);<span class="cstat-no" title="statement not covered" ></span>n.lo-=Math.max(0,a);c</span>onst r=<span class="cstat-no" title="statement not covered" >i.slice(n.hi).findIndex((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!(0,s.k)(t[e.axis]))</span>);<span class="cstat-no" title="statement not covered" ></span>n.hi+=Math.max(0,r)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn n}<span class="cstat-no" title="statement not covered" ></span>i</span>f(o._sharedOptions){const t=<span class="cstat-no" title="statement not covered" >a[0],</span>s=<span class="cstat-no" title="statement not covered" >"function"===typeof t.getRange&amp;&amp;t.getRange(e);<span class="cstat-no" title="statement not covered" ></span>if(s){const t=<span class="cstat-no" title="statement not covered" >r(a,e,i-s),</span>n=<span class="cstat-no" title="statement not covered" >r(a,e,i+s);<span class="cstat-no" title="statement not covered" ></span>return{lo:t.lo,hi:n.hi}}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{lo:0,hi:a.length-1}}</span>function <span class="fstat-no" title="function not covered" >L(</span>t,e,i,s,n){const o=<span class="cstat-no" title="statement not covered" >t.getSortedVisibleDatasetMetas(),</span>a=<span class="cstat-no" title="statement not covered" >i[e];<span class="cstat-no" title="statement not covered" ></span>for(let r=<span class="cstat-no" title="statement not covered" >0,</span>h=<span class="cstat-no" title="statement not covered" >o.length;</span>r&lt;h;++r){const{index:t,data:i}=<span class="cstat-no" title="statement not covered" >o[r],</span>{lo:h,hi:l}=<span class="cstat-no" title="statement not covered" >I(o[r],e,a,n);<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >h;</span>e&lt;=l;++e){const n=<span class="cstat-no" title="statement not covered" >i[e];<span class="cstat-no" title="statement not covered" ></span>n.skip||s(n,t,e)}</span>}</span>}</span>function <span class="fstat-no" title="function not covered" >z(</span>t,e,i,n,o){const a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(!o&amp;&amp;!t.isPointInArea(e))<span class="cstat-no" title="statement not covered" >return a;<span class="cstat-no" title="statement not covered" >r</span></span>eturn L(t,i,e,(<span class="fstat-no" title="function not covered" >fu</span>nction(i,r,h){<span class="cstat-no" title="statement not covered" >(o||(0,s.C)(i,t.chartArea,0))&amp;&amp;i.inRange(e.x,e.y,n)&amp;&amp;a.push({element:i,datasetIndex:r,index:h})}</span>),!0),a}</span>function <span class="fstat-no" title="function not covered" >F(</span>t,e,i,s,n,o){let a=<span class="cstat-no" title="statement not covered" >[];</span>const r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >-1!==t.indexOf("x"),</span>i=<span class="cstat-no" title="statement not covered" >-1!==t.indexOf("y");<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(t,s){const n=<span class="cstat-no" title="statement not covered" >e?Math.abs(t.x-s.x):0,</span>o=<span class="cstat-no" title="statement not covered" >i?Math.abs(t.y-s.y):0;<span class="cstat-no" title="statement not covered" ></span>return Math.sqrt(Math.pow(n,2)+Math.pow(o,2))}</span>}</span>(i);</span>let h=<span class="cstat-no" title="statement not covered" >Number.POSITIVE_INFINITY;<span class="cstat-no" title="statement not covered" ></span>return L(t,i,e,(<span class="fstat-no" title="function not covered" >fu</span>nction(i,l,c){const d=<span class="cstat-no" title="statement not covered" >i.inRange(e.x,e.y,n);<span class="cstat-no" title="statement not covered" ></span>if(s&amp;&amp;!d)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst u=<span class="cstat-no" title="statement not covered" >i.getCenterPoint(n);<span class="cstat-no" title="statement not covered" ></span>if(!(!!o||t.isPointInArea(u))&amp;&amp;!d)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst g=<span class="cstat-no" title="statement not covered" >r(e,u);<span class="cstat-no" title="statement not covered" ></span>g&lt;h?(a=[{element:i,datasetIndex:l,index:c}],h=g):g===h&amp;&amp;a.push({element:i,datasetIndex:l,index:c})}</span>)),a}</span>function <span class="fstat-no" title="function not covered" >B(</span>t,e,i,n,o,a){<span class="cstat-no" title="statement not covered" >return a||t.isPointInArea(e)?"r"!==i||n?F(t,e,i,n,o,a):<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,n){let o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return L(t,i,e,(<span class="fstat-no" title="function not covered" >fu</span>nction(t,i,a){const{startAngle:r,endAngle:h}=<span class="cstat-no" title="statement not covered" >t.getProps(["startAngle","endAngle"],n),</span>{angle:l}=<span class="cstat-no" title="statement not covered" >(0,s.D)(t,{x:e.x,y:e.y});<span class="cstat-no" title="statement not covered" ></span>(0,s.p)(l,r,h)&amp;&amp;o.push({element:t,datasetIndex:i,index:a})}</span>)),o}</span>(t,e,i,o):[]}</span>function <span class="fstat-no" title="function not covered" >H(</span>t,e,i,s,n){const o=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >"x"===i?"inXRange":"inYRange";</span>let r=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return L(t,i,e,(<span class="fstat-no" title="function not covered" >(t</span>,s,h)=&gt;{<span class="cstat-no" title="statement not covered" >t[a]&amp;&amp;t[a](e[i],n)&amp;&amp;(o.push({element:t,datasetIndex:s,index:h}),r=r||t.inRange(e.x,e.y,n))}</span>)),s&amp;&amp;!r?[]:o}</span>var V=<span class="cstat-no" title="statement not covered" >{evaluateInteractionItems:L,modes:{<span class="fstat-no" title="function not covered" >in</span>dex(t,e,i,n){const o=<span class="cstat-no" title="statement not covered" >(0,s.z)(e,t),</span>a=<span class="cstat-no" title="statement not covered" >i.axis||"x",</span>r=<span class="cstat-no" title="statement not covered" >i.includeInvisible||!1,</span>h=<span class="cstat-no" title="statement not covered" >i.intersect?z(t,o,a,n,r):B(t,o,a,!1,n,r),</span>l=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return h.length?(t.getSortedVisibleDatasetMetas().forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >h[0].index,</span>i=<span class="cstat-no" title="statement not covered" >t.data[e];<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;!i.skip&amp;&amp;l.push({element:i,datasetIndex:t.index,index:e})}</span>)),l):[]}</span>,<span class="fstat-no" title="function not covered" >da</span>taset(t,e,i,n){const o=<span class="cstat-no" title="statement not covered" >(0,s.z)(e,t),</span>a=<span class="cstat-no" title="statement not covered" >i.axis||"xy",</span>r=<span class="cstat-no" title="statement not covered" >i.includeInvisible||!1;</span>let h=<span class="cstat-no" title="statement not covered" >i.intersect?z(t,o,a,n,r):B(t,o,a,!1,n,r);<span class="cstat-no" title="statement not covered" ></span>if(h.length&gt;0){const e=<span class="cstat-no" title="statement not covered" >h[0].datasetIndex,</span>i=<span class="cstat-no" title="statement not covered" >t.getDatasetMeta(e).data;<span class="cstat-no" title="statement not covered" ></span>h=[];<span class="cstat-no" title="statement not covered" >f</span>or(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;i.length;++t)<span class="cstat-no" title="statement not covered" >h.push({element:i[t],datasetIndex:e,index:t})}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn h}</span>,point:<span class="fstat-no" title="function not covered" >(t</span>,e,i,n)=&gt;<span class="cstat-no" title="statement not covered" >z(t,(0,s.z)(e,t),i.axis||"xy",n,i.includeInvisible||!1),<span class="fstat-no" title="function not covered" ></span>ne</span>arest(t,e,i,n){const o=<span class="cstat-no" title="statement not covered" >(0,s.z)(e,t),</span>a=<span class="cstat-no" title="statement not covered" >i.axis||"xy",</span>r=<span class="cstat-no" title="statement not covered" >i.includeInvisible||!1;<span class="cstat-no" title="statement not covered" ></span>return B(t,o,a,i.intersect,n,r)}</span>,x:<span class="fstat-no" title="function not covered" >(t</span>,e,i,n)=&gt;<span class="cstat-no" title="statement not covered" >H(t,(0,s.z)(e,t),"x",i.intersect,n),</span>y:<span class="fstat-no" title="function not covered" >(t</span>,e,i,n)=&gt;<span class="cstat-no" title="statement not covered" >H(t,(0,s.z)(e,t),"y",i.intersect,n)}</span>};</span>const W=<span class="cstat-no" title="statement not covered" >["left","top","right","bottom"];</span>function <span class="fstat-no" title="function not covered" >N(</span>t,e){<span class="cstat-no" title="statement not covered" >return t.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.pos===e)</span>)}</span>function <span class="fstat-no" title="function not covered" >j(</span>t,e){<span class="cstat-no" title="statement not covered" >return t.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >-1===W.indexOf(t.pos)&amp;&amp;t.box.axis===e)</span>)}</span>function <span class="fstat-no" title="function not covered" >$(</span>t,e){<span class="cstat-no" title="statement not covered" >return t.sort((<span class="fstat-no" title="function not covered" >(t</span>,i)=&gt;{const s=<span class="cstat-no" title="statement not covered" >e?i:t,</span>n=<span class="cstat-no" title="statement not covered" >e?t:i;<span class="cstat-no" title="statement not covered" ></span>return s.weight===n.weight?s.index-n.index:s.weight-n.weight}</span>))}</span>function <span class="fstat-no" title="function not covered" >U(</span>t,e){const i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(const i of t){const{stack:t,pos:s,stackWeight:n}=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>if(!t||!W.includes(s))<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >e[t]||(e[t]={count:0,placed:0,weight:0,size:0});<span class="cstat-no" title="statement not covered" ></span>o.count++,o.weight+=n}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>(t),</span>{vBoxMaxWidth:s,hBoxMaxHeight:n}=<span class="cstat-no" title="statement not covered" >e;</span>let o,a,r;<span class="cstat-no" title="statement not covered" >for(o=0,a=t.length;o&lt;a;++o){<span class="cstat-no" title="statement not covered" >r=t[o];c</span>onst{fullSize:a}=<span class="cstat-no" title="statement not covered" >r.box,</span>h=<span class="cstat-no" title="statement not covered" >i[r.stack],</span>l=<span class="cstat-no" title="statement not covered" >h&amp;&amp;r.stackWeight/h.weight;<span class="cstat-no" title="statement not covered" ></span>r.horizontal?(r.width=l?l*s:a&amp;&amp;e.availableWidth,r.height=n):(r.width=s,r.height=l?l*n:a&amp;&amp;e.availableHeight)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>function <span class="fstat-no" title="function not covered" >Y(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return Math.max(t[i],e[i])+Math.max(t[s],e[s])}</span>function <span class="fstat-no" title="function not covered" >X(</span>t,e){<span class="cstat-no" title="statement not covered" >t.top=Math.max(t.top,e.top),t.left=Math.max(t.left,e.left),t.bottom=Math.max(t.bottom,e.bottom),t.right=Math.max(t.right,e.right)}</span>function <span class="fstat-no" title="function not covered" >Q(</span>t,e,i,n){const{pos:o,box:a}=<span class="cstat-no" title="statement not covered" >i,</span>r=<span class="cstat-no" title="statement not covered" >t.maxPadding;<span class="cstat-no" title="statement not covered" ></span>if(!(0,s.i)(o)){<span class="cstat-no" title="statement not covered" >i.size&amp;&amp;(t[o]-=i.size);c</span>onst e=<span class="cstat-no" title="statement not covered" >n[i.stack]||{size:0,count:1};<span class="cstat-no" title="statement not covered" ></span>e.size=Math.max(e.size,i.horizontal?a.height:a.width),i.size=e.size/e.count,t[o]+=i.size}<span class="cstat-no" title="statement not covered" ></span>a</span>.getPadding&amp;&amp;X(r,a.getPadding());c</span>onst h=<span class="cstat-no" title="statement not covered" >Math.max(0,e.outerWidth-Y(r,t,"left","right")),</span>l=<span class="cstat-no" title="statement not covered" >Math.max(0,e.outerHeight-Y(r,t,"top","bottom")),</span>c=<span class="cstat-no" title="statement not covered" >h!==t.w,</span>d=<span class="cstat-no" title="statement not covered" >l!==t.h;<span class="cstat-no" title="statement not covered" ></span>return t.w=h,t.h=l,i.horizontal?{same:c,other:d}:{same:d,other:c}}</span>function <span class="fstat-no" title="function not covered" >G(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >e.maxPadding;</span>function <span class="fstat-no" title="function not covered" >s(</span>t){const s=<span class="cstat-no" title="statement not covered" >{left:0,top:0,right:0,bottom:0};<span class="cstat-no" title="statement not covered" ></span>return t.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >s[t]=Math.max(e[t],i[t])}</span>)),s}<span class="cstat-no" title="statement not covered" ></span>return s(t?["left","right"]:["top","bottom"])}</span>function <span class="fstat-no" title="function not covered" >K(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >[];</span>let o,a,r,h,l,c;<span class="cstat-no" title="statement not covered" >for(o=0,a=t.length,l=0;o&lt;a;++o){<span class="cstat-no" title="statement not covered" >r=t[o],h=r.box,h.update(r.width||e.w,r.height||e.h,G(r.horizontal,e));c</span>onst{same:a,other:d}=<span class="cstat-no" title="statement not covered" >Q(e,i,r,s);<span class="cstat-no" title="statement not covered" ></span>l|=a&amp;&amp;n.length,c=c||d,h.fullSize||n.push(r)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn l&amp;&amp;K(n,e,i,s)||c}</span>function <span class="fstat-no" title="function not covered" >J(</span>t,e,i,s,n){<span class="cstat-no" title="statement not covered" >t.top=i,t.left=e,t.right=e+s,t.bottom=i+n,t.width=s,t.height=n}</span>function <span class="fstat-no" title="function not covered" >q(</span>t,e,i,n){const o=<span class="cstat-no" title="statement not covered" >i.padding;</span>let{x:a,y:r}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>for(const h of t){const t=<span class="cstat-no" title="statement not covered" >h.box,</span>l=<span class="cstat-no" title="statement not covered" >n[h.stack]||{count:1,placed:0,weight:1},</span>c=<span class="cstat-no" title="statement not covered" >h.stackWeight/l.weight||1;<span class="cstat-no" title="statement not covered" ></span>if(h.horizontal){const n=<span class="cstat-no" title="statement not covered" >e.w*c,</span>a=<span class="cstat-no" title="statement not covered" >l.size||t.height;<span class="cstat-no" title="statement not covered" ></span>(0,s.h)(l.start)&amp;&amp;(r=l.start),t.fullSize?J(t,o.left,r,i.outerWidth-o.right-o.left,a):J(t,e.left+l.placed,r,n,a),l.start=r,l.placed+=n,r=t.bottom}</span>else{const n=<span class="cstat-no" title="statement not covered" >e.h*c,</span>r=<span class="cstat-no" title="statement not covered" >l.size||t.width;<span class="cstat-no" title="statement not covered" ></span>(0,s.h)(l.start)&amp;&amp;(a=l.start),t.fullSize?J(t,a,o.top,r,i.outerHeight-o.bottom-o.top):J(t,a,e.top+l.placed,r,n),l.start=a,l.placed+=n,a=t.right}</span>}<span class="cstat-no" title="statement not covered" ></span>e</span>.x=a,e.y=r}</span>var Z=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >ad</span>dBox(t,e){<span class="cstat-no" title="statement not covered" >t.boxes||(t.boxes=[]),e.fullSize=e.fullSize||!1,e.position=e.position||"top",e.weight=e.weight||0,e._layers=e._layers||<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return[{z:0,<span class="fstat-no" title="function not covered" >dr</span>aw(t){<span class="cstat-no" title="statement not covered" >e.draw(t)}</span>}]}</span>,t.boxes.push(e)}</span>,<span class="fstat-no" title="function not covered" >re</span>moveBox(t,e){const i=<span class="cstat-no" title="statement not covered" >t.boxes?t.boxes.indexOf(e):-1;<span class="cstat-no" title="statement not covered" ></span>-1!==i&amp;&amp;t.boxes.splice(i,1)}</span>,<span class="fstat-no" title="function not covered" >co</span>nfigure(t,e,i){<span class="cstat-no" title="statement not covered" >e.fullSize=i.fullSize,e.position=i.position,e.weight=i.weight}</span>,<span class="fstat-no" title="function not covered" >up</span>date(t,e,i,n){<span class="cstat-no" title="statement not covered" >if(!t)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >(0,s.E)(t.options.layout.padding),</span>a=<span class="cstat-no" title="statement not covered" >Math.max(e-o.width,0),</span>r=<span class="cstat-no" title="statement not covered" >Math.max(i-o.height,0),</span>h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >[];</span>let i,s,n,o,a,r;<span class="cstat-no" title="statement not covered" >for(i=0,s=(t||[]).length;i&lt;s;++i)<span class="cstat-no" title="statement not covered" >n=t[i],({position:o,options:{stack:a,stackWeight:r=<span class="branch-0 cbranch-no" title="branch not covered" >1}</span>}=n),e.push({index:i,box:n,pos:o,horizontal:n.isHorizontal(),weight:n.weight,stack:a&amp;&amp;o+a,stackWeight:r});<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>(t),</span>i=<span class="cstat-no" title="statement not covered" >$(e.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.box.fullSize)</span>),!0),</span>s=<span class="cstat-no" title="statement not covered" >$(N(e,"left"),!0),</span>n=<span class="cstat-no" title="statement not covered" >$(N(e,"right")),</span>o=<span class="cstat-no" title="statement not covered" >$(N(e,"top"),!0),</span>a=<span class="cstat-no" title="statement not covered" >$(N(e,"bottom")),</span>r=<span class="cstat-no" title="statement not covered" >j(e,"x"),</span>h=<span class="cstat-no" title="statement not covered" >j(e,"y");<span class="cstat-no" title="statement not covered" ></span>return{fullSize:i,leftAndTop:s.concat(o),rightAndBottom:n.concat(h).concat(a).concat(r),chartArea:N(e,"chartArea"),vertical:s.concat(n).concat(h),horizontal:o.concat(a).concat(r)}}</span>(t.boxes),</span>l=<span class="cstat-no" title="statement not covered" >h.vertical,</span>c=<span class="cstat-no" title="statement not covered" >h.horizontal;<span class="cstat-no" title="statement not covered" ></span>(0,s.F)(t.boxes,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >"function"===typeof t.beforeLayout&amp;&amp;t.beforeLayout()}</span>));c</span>onst d=<span class="cstat-no" title="statement not covered" >l.reduce((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e.box.options&amp;&amp;!1===e.box.options.display?t:t+1)</span>,0)||1,</span>u=<span class="cstat-no" title="statement not covered" >Object.freeze({outerWidth:e,outerHeight:i,padding:o,availableWidth:a,availableHeight:r,vBoxMaxWidth:a/2/d,hBoxMaxHeight:r/2}),</span>g=<span class="cstat-no" title="statement not covered" >Object.assign({},o);<span class="cstat-no" title="statement not covered" ></span>X(g,(0,s.E)(n));c</span>onst f=<span class="cstat-no" title="statement not covered" >Object.assign({maxPadding:g,w:a,h:r,x:o.left,y:o.top},o),</span>p=<span class="cstat-no" title="statement not covered" >U(l.concat(c),u);<span class="cstat-no" title="statement not covered" ></span>K(h.fullSize,f,u,p),K(l,f,u,p),K(c,f,u,p)&amp;&amp;K(l,f,u,p),<span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >t.maxPadding;</span>function <span class="fstat-no" title="function not covered" >i(</span>i){const s=<span class="cstat-no" title="statement not covered" >Math.max(e[i]-t[i],0);<span class="cstat-no" title="statement not covered" ></span>return t[i]+=s,s}<span class="cstat-no" title="statement not covered" ></span>t.y+=i("top"),t.x+=i("left"),i("right"),i("bottom")}</span>(f),q(h.leftAndTop,f,u,p),f.x+=f.w,f.y+=f.h,q(h.rightAndBottom,f,u,p),t.chartArea={left:f.left,top:f.top,right:f.left+f.w,bottom:f.top+f.h,height:f.h,width:f.w},(0,s.F)(h.chartArea,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >e.box;<span class="cstat-no" title="statement not covered" ></span>Object.assign(i,t.chartArea),i.update(f.w,f.h,{left:0,top:0,right:0,bottom:0})}</span>))}</span>};</span>class tt{<span class="fstat-no" title="function not covered" >ac</span>quireContext(t,e){}<span class="fstat-no" title="function not covered" >re</span>leaseContext(t){<span class="cstat-no" title="statement not covered" >return!1}<span class="fstat-no" title="function not covered" ></span>ad</span>dEventListener(t,e,i){}<span class="fstat-no" title="function not covered" >re</span>moveEventListener(t,e,i){}<span class="fstat-no" title="function not covered" >ge</span>tDevicePixelRatio(){<span class="cstat-no" title="statement not covered" >return 1}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaximumSize(t,e,i,s){<span class="cstat-no" title="statement not covered" >return e=Math.max(0,e||t.width),i=i||t.height,{width:e,height:Math.max(0,s?Math.floor(e/s):i)}}<span class="fstat-no" title="function not covered" ></span>is</span>Attached(t){<span class="cstat-no" title="statement not covered" >return!0}<span class="fstat-no" title="function not covered" ></span>up</span>dateConfig(t){}}class et extends tt{<span class="fstat-no" title="function not covered" >ac</span>quireContext(t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;t.getContext&amp;&amp;t.getContext("2d")||null}<span class="fstat-no" title="function not covered" ></span>up</span>dateConfig(t){<span class="cstat-no" title="statement not covered" >t.options.animation=!1}</span>}const it=<span class="cstat-no" title="statement not covered" >{touchstart:"mousedown",touchmove:"mousemove",touchend:"mouseup",pointerenter:"mouseenter",pointerdown:"mousedown",pointermove:"mousemove",pointerup:"mouseup",pointerleave:"mouseout",pointerout:"mouseout"},</span>st=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >null===t||""===t;</span></span>const nt=<span class="cstat-no" title="statement not covered" >!!s.K&amp;&amp;{passive:!0};</span>function <span class="fstat-no" title="function not covered" >ot(</span>t,e,i){<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.canvas&amp;&amp;t.canvas.removeEventListener(e,i,nt)}</span>function <span class="fstat-no" title="function not covered" >at(</span>t,e){<span class="cstat-no" title="statement not covered" >for(const i of t)<span class="cstat-no" title="statement not covered" >if(i===e||i.contains(e))<span class="cstat-no" title="statement not covered" >return!0}</span></span></span>function <span class="fstat-no" title="function not covered" >rt(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.canvas,</span>n=<span class="cstat-no" title="statement not covered" >new MutationObserver((<span class="fstat-no" title="function not covered" >t=</span>&gt;{let e=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>for(const i of t)<span class="cstat-no" title="statement not covered" >e=e||at(i.addedNodes,s),e=e&amp;&amp;!at(i.removedNodes,s);<span class="cstat-no" title="statement not covered" >e</span></span>&amp;&amp;i()}</span>));<span class="cstat-no" title="statement not covered" ></span>return n.observe(document,{childList:!0,subtree:!0}),n}</span>function <span class="fstat-no" title="function not covered" >ht(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.canvas,</span>n=<span class="cstat-no" title="statement not covered" >new MutationObserver((<span class="fstat-no" title="function not covered" >t=</span>&gt;{let e=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>for(const i of t)<span class="cstat-no" title="statement not covered" >e=e||at(i.removedNodes,s),e=e&amp;&amp;!at(i.addedNodes,s);<span class="cstat-no" title="statement not covered" >e</span></span>&amp;&amp;i()}</span>));<span class="cstat-no" title="statement not covered" ></span>return n.observe(document,{childList:!0,subtree:!0}),n}</span>const lt=<span class="cstat-no" title="statement not covered" >new Map;</span>let ct=<span class="cstat-no" title="statement not covered" >0;</span>function <span class="fstat-no" title="function not covered" >dt(</span>){const t=<span class="cstat-no" title="statement not covered" >window.devicePixelRatio;<span class="cstat-no" title="statement not covered" ></span>t!==ct&amp;&amp;(ct=t,lt.forEach((<span class="fstat-no" title="function not covered" >(e</span>,i)=&gt;{<span class="cstat-no" title="statement not covered" >i.currentDevicePixelRatio!==t&amp;&amp;e()}</span>)))}</span>function <span class="fstat-no" title="function not covered" >ut(</span>t,e,i){const n=<span class="cstat-no" title="statement not covered" >t.canvas,</span>o=<span class="cstat-no" title="statement not covered" >n&amp;&amp;(0,s.I)(n);<span class="cstat-no" title="statement not covered" ></span>if(!o)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst a=<span class="cstat-no" title="statement not covered" >(0,s.L)((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{const s=<span class="cstat-no" title="statement not covered" >o.clientWidth;<span class="cstat-no" title="statement not covered" ></span>i(t,e),s&lt;o.clientWidth&amp;&amp;i()}</span>),window),</span>r=<span class="cstat-no" title="statement not covered" >new ResizeObserver((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >t[0],</span>i=<span class="cstat-no" title="statement not covered" >e.contentRect.width,</span>s=<span class="cstat-no" title="statement not covered" >e.contentRect.height;<span class="cstat-no" title="statement not covered" ></span>0===i&amp;&amp;0===s||a(i,s)}</span>));<span class="cstat-no" title="statement not covered" ></span>return r.observe(o),<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >lt.size||window.addEventListener("resize",dt),lt.set(t,e)}</span>(t,a),r}</span>function <span class="fstat-no" title="function not covered" >gt(</span>t,e,i){<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.disconnect(),"resize"===e&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >lt.delete(t),lt.size||window.removeEventListener("resize",dt)}</span>(t)}</span>function <span class="fstat-no" title="function not covered" >ft(</span>t,e,i){const n=<span class="cstat-no" title="statement not covered" >t.canvas,</span>o=<span class="cstat-no" title="statement not covered" >(0,s.L)((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >null!==t.ctx&amp;&amp;i(<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >it[t.type]||t.type,</span>{x:n,y:o}=<span class="cstat-no" title="statement not covered" >(0,s.z)(t,e);<span class="cstat-no" title="statement not covered" ></span>return{type:i,chart:e,native:t,x:void 0!==n?n:null,y:void 0!==o?o:null}}</span>(e,t))}</span>),t);<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.addEventListener(e,i,nt)}</span>(n,e,o),o}</span>class pt extends tt{<span class="fstat-no" title="function not covered" >ac</span>quireContext(t,e){const i=<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.getContext&amp;&amp;t.getContext("2d");<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;i.canvas===t?(<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >t.style,</span>n=<span class="cstat-no" title="statement not covered" >t.getAttribute("height"),</span>o=<span class="cstat-no" title="statement not covered" >t.getAttribute("width");<span class="cstat-no" title="statement not covered" ></span>if(t.$chartjs={initial:{height:n,width:o,style:{display:i.display,height:i.height,width:i.width}}},i.display=i.display||"block",i.boxSizing=i.boxSizing||"border-box",st(o)){const e=<span class="cstat-no" title="statement not covered" >(0,s.J)(t,"width");<span class="cstat-no" title="statement not covered" ></span>void 0!==e&amp;&amp;(t.width=e)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(st(n))<span class="cstat-no" title="statement not covered" >if(""===t.style.height)<span class="cstat-no" title="statement not covered" >t.height=t.width/(e||2);e</span>lse{const e=<span class="cstat-no" title="statement not covered" >(0,s.J)(t,"height");<span class="cstat-no" title="statement not covered" ></span>void 0!==e&amp;&amp;(t.height=e)}</span>}</span></span>(t,e),i):null}<span class="fstat-no" title="function not covered" ></span>re</span>leaseContext(t){const e=<span class="cstat-no" title="statement not covered" >t.canvas;<span class="cstat-no" title="statement not covered" ></span>if(!e.$chartjs)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >e.$chartjs.initial;<span class="cstat-no" title="statement not covered" ></span>["height","width"].forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >i[t];<span class="cstat-no" title="statement not covered" ></span>(0,s.k)(n)?e.removeAttribute(t):e.setAttribute(t,n)}</span>));c</span>onst n=<span class="cstat-no" title="statement not covered" >i.style||{};<span class="cstat-no" title="statement not covered" ></span>return Object.keys(n).forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.style[t]=n[t]}</span>)),e.width=e.width,delete e.$chartjs,!0}<span class="fstat-no" title="function not covered" ></span>ad</span>dEventListener(t,e,i){<span class="cstat-no" title="statement not covered" >this.removeEventListener(t,e);c</span>onst s=<span class="cstat-no" title="statement not covered" >t.$proxies||(t.$proxies={}),</span>n=<span class="cstat-no" title="statement not covered" >{attach:rt,detach:ht,resize:ut}[e]||ft;<span class="cstat-no" title="statement not covered" ></span>s[e]=n(t,e,i)}<span class="fstat-no" title="function not covered" ></span>re</span>moveEventListener(t,e){const i=<span class="cstat-no" title="statement not covered" >t.$proxies||(t.$proxies={}),</span>s=<span class="cstat-no" title="statement not covered" >i[e];<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >(</span></span>{attach:gt,detach:gt,resize:gt}[e]||ot)(t,e,s),i[e]=void 0}<span class="fstat-no" title="function not covered" ></span>ge</span>tDevicePixelRatio(){<span class="cstat-no" title="statement not covered" >return window.devicePixelRatio}<span class="fstat-no" title="function not covered" ></span>ge</span>tMaximumSize(t,e,i,n){<span class="cstat-no" title="statement not covered" >return(0,s.G)(t,e,i,n)}<span class="fstat-no" title="function not covered" ></span>is</span>Attached(t){const e=<span class="cstat-no" title="statement not covered" >t&amp;&amp;(0,s.I)(t);<span class="cstat-no" title="statement not covered" ></span>return!(!e||!e.isConnected)}</span>}class xt{static defaults=<span class="cstat-no" title="statement not covered" >{};</span>static defaultRoutes=<span class="cstat-no" title="statement not covered" >void 0;</span>x;y;active=<span class="cstat-no" title="statement not covered" >!1;</span>options;$animations;<span class="fstat-no" title="function not covered" >to</span>oltipPosition(t){const{x:e,y:i}=<span class="cstat-no" title="statement not covered" >this.getProps(["x","y"],t);<span class="cstat-no" title="statement not covered" ></span>return{x:e,y:i}}<span class="fstat-no" title="function not covered" ></span>ha</span>sValue(){<span class="cstat-no" title="statement not covered" >return(0,s.x)(this.x)&amp;&amp;(0,s.x)(this.y)}<span class="fstat-no" title="function not covered" ></span>ge</span>tProps(t,e){const i=<span class="cstat-no" title="statement not covered" >this.$animations;<span class="cstat-no" title="statement not covered" ></span>if(!e||!i)<span class="cstat-no" title="statement not covered" >return this;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>return t.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >s[t]=i[t]&amp;&amp;i[t].active()?i[t]._to:this[t]}</span>)),s}</span>}function <span class="fstat-no" title="function not covered" >mt(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t.options.ticks,</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >t.options.offset,</span>i=<span class="cstat-no" title="statement not covered" >t._tickSize(),</span>s=<span class="cstat-no" title="statement not covered" >t._length/i+(e?0:1),</span>n=<span class="cstat-no" title="statement not covered" >t._maxLength/i;<span class="cstat-no" title="statement not covered" ></span>return Math.floor(Math.min(s,n))}</span>(t),</span>o=<span class="cstat-no" title="statement not covered" >Math.min(i.maxTicksLimit||n,n),</span>a=<span class="cstat-no" title="statement not covered" >i.major.enabled?<span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >[];</span>let i,s;<span class="cstat-no" title="statement not covered" >for(i=0,s=t.length;i&lt;s;i++)<span class="cstat-no" title="statement not covered" >t[i].major&amp;&amp;e.push(i);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>(e):[],</span>r=<span class="cstat-no" title="statement not covered" >a.length,</span>h=<span class="cstat-no" title="statement not covered" >a[0],</span>l=<span class="cstat-no" title="statement not covered" >a[r-1],</span>c=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(r&gt;o)<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){let n,o=<span class="cstat-no" title="statement not covered" >0,</span>a=<span class="cstat-no" title="statement not covered" >i[0];<span class="cstat-no" title="statement not covered" ></span>for(s=Math.ceil(s),n=0;n&lt;t.length;n++)<span class="cstat-no" title="statement not covered" >n===a&amp;&amp;(e.push(t[n]),o++,a=i[o*s])}</span></span>(e,c,a,r/o),c;c</span></span>onst d=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >t.length;</span>let i,s;<span class="cstat-no" title="statement not covered" >if(e&lt;2)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(s=t[0],i=1;i&lt;e;++i)<span class="cstat-no" title="statement not covered" >if(t[i]-t[i-1]!==s)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn s}</span>(t),</span>o=<span class="cstat-no" title="statement not covered" >e.length/i;<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >return Math.max(o,1);c</span></span>onst a=<span class="cstat-no" title="statement not covered" >(0,s.N)(n);<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >a.length-1;</span>s&lt;r;s++){const t=<span class="cstat-no" title="statement not covered" >a[s];<span class="cstat-no" title="statement not covered" ></span>if(t&gt;o)<span class="cstat-no" title="statement not covered" >return t}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn Math.max(o,1)}</span>(a,e,o);<span class="cstat-no" title="statement not covered" ></span>if(r&gt;0){let t,i;const n=<span class="cstat-no" title="statement not covered" >r&gt;1?Math.round((l-h)/(r-1)):null;<span class="cstat-no" title="statement not covered" ></span>for(bt(e,c,d,(0,s.k)(n)?0:h-n,h),t=0,i=r-1;t&lt;i;t++)<span class="cstat-no" title="statement not covered" >bt(e,c,d,a[t],a[t+1]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn bt(e,c,d,l,(0,s.k)(n)?e.length:l+n),c}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn bt(e,c,d),c}</span>function <span class="fstat-no" title="function not covered" >bt(</span>t,e,i,n,o){const a=<span class="cstat-no" title="statement not covered" >(0,s.v)(n,0),</span>r=<span class="cstat-no" title="statement not covered" >Math.min((0,s.v)(o,t.length),t.length);</span>let h,l,c,d=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(i=Math.ceil(i),o&amp;&amp;(h=o-n,i=h/Math.floor(h/i)),c=a;c&lt;0;)<span class="cstat-no" title="statement not covered" >d++,c=Math.round(a+d*i);<span class="cstat-no" title="statement not covered" >f</span></span>or(l=Math.max(a,0);l&lt;r;l++)<span class="cstat-no" title="statement not covered" >l===c&amp;&amp;(e.push(t[l]),d++,c=Math.round(a+d*i))}</span></span>const _t=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;<span class="cstat-no" title="statement not covered" >"top"===e||"left"===e?t[e]+i:t[e]-i,</span></span>vt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >Math.min(e||t,t);</span></span>function <span class="fstat-no" title="function not covered" >yt(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >t.length/e,</span>n=<span class="cstat-no" title="statement not covered" >t.length;</span>let o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;o&lt;n;o+=s)<span class="cstat-no" title="statement not covered" >i.push(t[Math.floor(o)]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>function <span class="fstat-no" title="function not covered" >Mt(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.ticks.length,</span>n=<span class="cstat-no" title="statement not covered" >Math.min(e,s-1),</span>o=<span class="cstat-no" title="statement not covered" >t._startPixel,</span>a=<span class="cstat-no" title="statement not covered" >t._endPixel,</span>r=<span class="cstat-no" title="statement not covered" >1e-6;</span>let h,l=<span class="cstat-no" title="statement not covered" >t.getPixelForTick(n);<span class="cstat-no" title="statement not covered" ></span>if(!(i&amp;&amp;(h=1===s?Math.max(l-o,a-l):0===e?(t.getPixelForTick(1)-l)/2:(l-t.getPixelForTick(n-1))/2,l+=n&lt;e?h:-h,l&lt;o-r||l&gt;a+r)))<span class="cstat-no" title="statement not covered" >return l}</span></span>function <span class="fstat-no" title="function not covered" >wt(</span>t){<span class="cstat-no" title="statement not covered" >return t.drawTicks?t.tickLength:0}</span>function <span class="fstat-no" title="function not covered" >kt(</span>t,e){<span class="cstat-no" title="statement not covered" >if(!t.display)<span class="cstat-no" title="statement not covered" >return 0;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >(0,s.a0)(t.font,e),</span>n=<span class="cstat-no" title="statement not covered" >(0,s.E)(t.padding);<span class="cstat-no" title="statement not covered" ></span>return((0,s.b)(t.text)?t.text.length:1)*i.lineHeight+n.height}</span>function <span class="fstat-no" title="function not covered" >St(</span>t,e,i){let n=<span class="cstat-no" title="statement not covered" >(0,s.a1)(t);<span class="cstat-no" title="statement not covered" ></span>return(i&amp;&amp;"right"!==e||!i&amp;&amp;"right"===e)&amp;&amp;(n=(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"left"===t?"right":"right"===t?"left":t)</span>(n)),n}</span>class Dt extends xt{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.id=t.id,this.type=t.type,this.options=void 0,this.ctx=t.ctx,this.chart=t.chart,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this._margins={left:0,right:0,top:0,bottom:0},this.maxWidth=void 0,this.maxHeight=void 0,this.paddingTop=void 0,this.paddingBottom=void 0,this.paddingLeft=void 0,this.paddingRight=void 0,this.axis=void 0,this.labelRotation=void 0,this.min=void 0,this.max=void 0,this._range=void 0,this.ticks=[],this._gridLineItems=null,this._labelItems=null,this._labelSizes=null,this._length=0,this._maxLength=0,this._longestTextCache={},this._startPixel=void 0,this._endPixel=void 0,this._reversePixels=!1,this._userMax=void 0,this._userMin=void 0,this._suggestedMax=void 0,this._suggestedMin=void 0,this._ticksLength=0,this._borderValue=0,this._cache={},this._dataLimitsCached=!1,this.$context=void 0}<span class="fstat-no" title="function not covered" ></span>in</span>it(t){<span class="cstat-no" title="statement not covered" >this.options=t.setContext(this.getContext()),this.axis=t.axis,this._userMin=this.parse(t.min),this._userMax=this.parse(t.max),this._suggestedMin=this.parse(t.suggestedMin),this._suggestedMax=this.parse(t.suggestedMax)}<span class="fstat-no" title="function not covered" ></span>pa</span>rse(t,e){<span class="cstat-no" title="statement not covered" >return t}<span class="fstat-no" title="function not covered" ></span>ge</span>tUserBounds(){let{_userMin:t,_userMax:e,_suggestedMin:i,_suggestedMax:n}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return t=(0,s.O)(t,Number.POSITIVE_INFINITY),e=(0,s.O)(e,Number.NEGATIVE_INFINITY),i=(0,s.O)(i,Number.POSITIVE_INFINITY),n=(0,s.O)(n,Number.NEGATIVE_INFINITY),{min:(0,s.O)(t,i),max:(0,s.O)(e,n),minDefined:(0,s.g)(t),maxDefined:(0,s.g)(e)}}<span class="fstat-no" title="function not covered" ></span>ge</span>tMinMax(t){let e,{min:i,max:n,minDefined:o,maxDefined:a}=<span class="cstat-no" title="statement not covered" >this.getUserBounds();<span class="cstat-no" title="statement not covered" ></span>if(o&amp;&amp;a)<span class="cstat-no" title="statement not covered" >return{min:i,max:n};c</span></span>onst r=<span class="cstat-no" title="statement not covered" >this.getMatchingVisibleMetas();<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >0,</span>h=<span class="cstat-no" title="statement not covered" >r.length;</span>s&lt;h;++s)<span class="cstat-no" title="statement not covered" >e=r[s].controller.getMinMax(this,t),o||(i=Math.min(i,e.min)),a||(n=Math.max(n,e.max));<span class="cstat-no" title="statement not covered" >r</span></span>eturn i=a&amp;&amp;i&gt;n?n:i,n=o&amp;&amp;i&gt;n?i:n,{min:(0,s.O)(i,(0,s.O)(n,i)),max:(0,s.O)(n,(0,s.O)(i,n))}}<span class="fstat-no" title="function not covered" ></span>ge</span>tPadding(){<span class="cstat-no" title="statement not covered" >return{left:this.paddingLeft||0,top:this.paddingTop||0,right:this.paddingRight||0,bottom:this.paddingBottom||0}}<span class="fstat-no" title="function not covered" ></span>ge</span>tTicks(){<span class="cstat-no" title="statement not covered" >return this.ticks}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabels(){const t=<span class="cstat-no" title="statement not covered" >this.chart.data;<span class="cstat-no" title="statement not covered" ></span>return this.options.labels||(this.isHorizontal()?t.xLabels:t.yLabels)||t.labels||[]}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelItems(t=<span class="branch-0 cbranch-no" title="branch not covered" >this.chart.chartArea)</span>{<span class="cstat-no" title="statement not covered" >return this._labelItems||(this._labelItems=this._computeLabelItems(t))}<span class="fstat-no" title="function not covered" ></span>be</span>foreLayout(){<span class="cstat-no" title="statement not covered" >this._cache={},this._dataLimitsCached=!1}<span class="fstat-no" title="function not covered" ></span>be</span>foreUpdate(){<span class="cstat-no" title="statement not covered" >(0,s.Q)(this.options.beforeUpdate,[this])}<span class="fstat-no" title="function not covered" ></span>up</span>date(t,e,i){const{beginAtZero:n,grace:o,ticks:a}=<span class="cstat-no" title="statement not covered" >this.options,</span>r=<span class="cstat-no" title="statement not covered" >a.sampleSize;<span class="cstat-no" title="statement not covered" ></span>this.beforeUpdate(),this.maxWidth=t,this.maxHeight=e,this._margins=i=Object.assign({left:0,right:0,top:0,bottom:0},i),this.ticks=null,this._labelSizes=null,this._gridLineItems=null,this._labelItems=null,this.beforeSetDimensions(),this.setDimensions(),this.afterSetDimensions(),this._maxLength=this.isHorizontal()?this.width+i.left+i.right:this.height+i.top+i.bottom,this._dataLimitsCached||(this.beforeDataLimits(),this.determineDataLimits(),this.afterDataLimits(),this._range=(0,s.R)(this,o,n),this._dataLimitsCached=!0),this.beforeBuildTicks(),this.ticks=this.buildTicks()||[],this.afterBuildTicks();c</span>onst h=<span class="cstat-no" title="statement not covered" >r&lt;this.ticks.length;<span class="cstat-no" title="statement not covered" ></span>this._convertTicksToLabels(h?yt(this.ticks,r):this.ticks),this.configure(),this.beforeCalculateLabelRotation(),this.calculateLabelRotation(),this.afterCalculateLabelRotation(),a.display&amp;&amp;(a.autoSkip||"auto"===a.source)&amp;&amp;(this.ticks=mt(this,this.ticks),this._labelSizes=null,this.afterAutoSkip()),h&amp;&amp;this._convertTicksToLabels(this.ticks),this.beforeFit(),this.fit(),this.afterFit(),this.afterUpdate()}<span class="fstat-no" title="function not covered" ></span>co</span>nfigure(){let t,e,i=<span class="cstat-no" title="statement not covered" >this.options.reverse;<span class="cstat-no" title="statement not covered" ></span>this.isHorizontal()?(t=this.left,e=this.right):(t=this.top,e=this.bottom,i=!i),this._startPixel=t,this._endPixel=e,this._reversePixels=i,this._length=e-t,this._alignToPixels=this.options.alignToPixels}<span class="fstat-no" title="function not covered" ></span>af</span>terUpdate(){<span class="cstat-no" title="statement not covered" >(0,s.Q)(this.options.afterUpdate,[this])}<span class="fstat-no" title="function not covered" ></span>be</span>foreSetDimensions(){<span class="cstat-no" title="statement not covered" >(0,s.Q)(this.options.beforeSetDimensions,[this])}<span class="fstat-no" title="function not covered" ></span>se</span>tDimensions(){<span class="cstat-no" title="statement not covered" >this.isHorizontal()?(this.width=this.maxWidth,this.left=0,this.right=this.width):(this.height=this.maxHeight,this.top=0,this.bottom=this.height),this.paddingLeft=0,this.paddingTop=0,this.paddingRight=0,this.paddingBottom=0}<span class="fstat-no" title="function not covered" ></span>af</span>terSetDimensions(){<span class="cstat-no" title="statement not covered" >(0,s.Q)(this.options.afterSetDimensions,[this])}<span class="fstat-no" title="function not covered" ></span>_c</span>allHooks(t){<span class="cstat-no" title="statement not covered" >this.chart.notifyPlugins(t,this.getContext()),(0,s.Q)(this.options[t],[this])}<span class="fstat-no" title="function not covered" ></span>be</span>foreDataLimits(){<span class="cstat-no" title="statement not covered" >this._callHooks("beforeDataLimits")}<span class="fstat-no" title="function not covered" ></span>de</span>termineDataLimits(){}<span class="fstat-no" title="function not covered" >af</span>terDataLimits(){<span class="cstat-no" title="statement not covered" >this._callHooks("afterDataLimits")}<span class="fstat-no" title="function not covered" ></span>be</span>foreBuildTicks(){<span class="cstat-no" title="statement not covered" >this._callHooks("beforeBuildTicks")}<span class="fstat-no" title="function not covered" ></span>bu</span>ildTicks(){<span class="cstat-no" title="statement not covered" >return[]}<span class="fstat-no" title="function not covered" ></span>af</span>terBuildTicks(){<span class="cstat-no" title="statement not covered" >this._callHooks("afterBuildTicks")}<span class="fstat-no" title="function not covered" ></span>be</span>foreTickToLabelConversion(){<span class="cstat-no" title="statement not covered" >(0,s.Q)(this.options.beforeTickToLabelConversion,[this])}<span class="fstat-no" title="function not covered" ></span>ge</span>nerateTickLabels(t){const e=<span class="cstat-no" title="statement not covered" >this.options.ticks;</span>let i,n,o;<span class="cstat-no" title="statement not covered" >for(i=0,n=t.length;i&lt;n;i++)<span class="cstat-no" title="statement not covered" >o=t[i],o.label=(0,s.Q)(e.callback,[o.value,i,t],this)}<span class="fstat-no" title="function not covered" ></span></span>af</span>terTickToLabelConversion(){<span class="cstat-no" title="statement not covered" >(0,s.Q)(this.options.afterTickToLabelConversion,[this])}<span class="fstat-no" title="function not covered" ></span>be</span>foreCalculateLabelRotation(){<span class="cstat-no" title="statement not covered" >(0,s.Q)(this.options.beforeCalculateLabelRotation,[this])}<span class="fstat-no" title="function not covered" ></span>ca</span>lculateLabelRotation(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >t.ticks,</span>i=<span class="cstat-no" title="statement not covered" >vt(this.ticks.length,t.ticks.maxTicksLimit),</span>n=<span class="cstat-no" title="statement not covered" >e.minRotation||0,</span>o=<span class="cstat-no" title="statement not covered" >e.maxRotation;</span>let a,r,h,l=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>if(!this._isVisible()||!e.display||n&gt;=o||i&lt;=1||!this.isHorizontal())<span class="cstat-no" title="statement not covered" >return void(this.labelRotation=n);c</span></span>onst c=<span class="cstat-no" title="statement not covered" >this._getLabelSizes(),</span>d=<span class="cstat-no" title="statement not covered" >c.widest.width,</span>u=<span class="cstat-no" title="statement not covered" >c.highest.height,</span>g=<span class="cstat-no" title="statement not covered" >(0,s.S)(this.chart.width-d,0,this.maxWidth);<span class="cstat-no" title="statement not covered" ></span>a=t.offset?this.maxWidth/i:g/(i-1),d+6&gt;a&amp;&amp;(a=g/(i-(t.offset?.5:1)),r=this.maxHeight-wt(t.grid)-e.padding-kt(t.title,this.chart.options.font),h=Math.sqrt(d*d+u*u),l=(0,s.U)(Math.min(Math.asin((0,s.S)((c.highest.height+6)/a,-1,1)),Math.asin((0,s.S)(r/h,-1,1))-Math.asin((0,s.S)(u/h,-1,1)))),l=Math.max(n,Math.min(o,l))),this.labelRotation=l}<span class="fstat-no" title="function not covered" ></span>af</span>terCalculateLabelRotation(){<span class="cstat-no" title="statement not covered" >(0,s.Q)(this.options.afterCalculateLabelRotation,[this])}<span class="fstat-no" title="function not covered" ></span>af</span>terAutoSkip(){}<span class="fstat-no" title="function not covered" >be</span>foreFit(){<span class="cstat-no" title="statement not covered" >(0,s.Q)(this.options.beforeFit,[this])}<span class="fstat-no" title="function not covered" ></span>fi</span>t(){const t=<span class="cstat-no" title="statement not covered" >{width:0,height:0},</span>{chart:e,options:{ticks:i,title:n,grid:o}}=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" >this._isVisible(),</span>r=<span class="cstat-no" title="statement not covered" >this.isHorizontal();<span class="cstat-no" title="statement not covered" ></span>if(a){const a=<span class="cstat-no" title="statement not covered" >kt(n,e.options.font);<span class="cstat-no" title="statement not covered" ></span>if(r?(t.width=this.maxWidth,t.height=wt(o)+a):(t.height=this.maxHeight,t.width=wt(o)+a),i.display&amp;&amp;this.ticks.length){const{first:e,last:n,widest:o,highest:a}=<span class="cstat-no" title="statement not covered" >this._getLabelSizes(),</span>h=<span class="cstat-no" title="statement not covered" >2*i.padding,</span>l=<span class="cstat-no" title="statement not covered" >(0,s.t)(this.labelRotation),</span>c=<span class="cstat-no" title="statement not covered" >Math.cos(l),</span>d=<span class="cstat-no" title="statement not covered" >Math.sin(l);<span class="cstat-no" title="statement not covered" ></span>if(r){const e=<span class="cstat-no" title="statement not covered" >i.mirror?0:d*o.width+c*a.height;<span class="cstat-no" title="statement not covered" ></span>t.height=Math.min(this.maxHeight,t.height+e+h)}</span>else{const e=<span class="cstat-no" title="statement not covered" >i.mirror?0:c*o.width+d*a.height;<span class="cstat-no" title="statement not covered" ></span>t.width=Math.min(this.maxWidth,t.width+e+h)}<span class="cstat-no" title="statement not covered" ></span>t</span>his._calculatePadding(e,n,d,c)}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>his._handleMargins(),r?(this.width=this._length=e.width-this._margins.left-this._margins.right,this.height=t.height):(this.width=t.width,this.height=this._length=e.height-this._margins.top-this._margins.bottom)}<span class="fstat-no" title="function not covered" ></span>_c</span>alculatePadding(t,e,i,s){const{ticks:{align:n,padding:o},position:a}=<span class="cstat-no" title="statement not covered" >this.options,</span>r=<span class="cstat-no" title="statement not covered" >0!==this.labelRotation,</span>h=<span class="cstat-no" title="statement not covered" >"top"!==a&amp;&amp;"x"===this.axis;<span class="cstat-no" title="statement not covered" ></span>if(this.isHorizontal()){const a=<span class="cstat-no" title="statement not covered" >this.getPixelForTick(0)-this.left,</span>l=<span class="cstat-no" title="statement not covered" >this.right-this.getPixelForTick(this.ticks.length-1);</span>let c=<span class="cstat-no" title="statement not covered" >0,</span>d=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>r?h?(c=s*t.width,d=i*e.height):(c=i*t.height,d=s*e.width):"start"===n?d=e.width:"end"===n?c=t.width:"inner"!==n&amp;&amp;(c=t.width/2,d=e.width/2),this.paddingLeft=Math.max((c-a+o)*this.width/(this.width-a),0),this.paddingRight=Math.max((d-l+o)*this.width/(this.width-l),0)}</span>else{let i=<span class="cstat-no" title="statement not covered" >e.height/2,</span>s=<span class="cstat-no" title="statement not covered" >t.height/2;<span class="cstat-no" title="statement not covered" ></span>"start"===n?(i=0,s=t.height):"end"===n&amp;&amp;(i=e.height,s=0),this.paddingTop=i+o,this.paddingBottom=s+o}</span>}<span class="fstat-no" title="function not covered" ></span>_h</span>andleMargins(){<span class="cstat-no" title="statement not covered" >this._margins&amp;&amp;(this._margins.left=Math.max(this.paddingLeft,this._margins.left),this._margins.top=Math.max(this.paddingTop,this._margins.top),this._margins.right=Math.max(this.paddingRight,this._margins.right),this._margins.bottom=Math.max(this.paddingBottom,this._margins.bottom))}<span class="fstat-no" title="function not covered" ></span>af</span>terFit(){<span class="cstat-no" title="statement not covered" >(0,s.Q)(this.options.afterFit,[this])}<span class="fstat-no" title="function not covered" ></span>is</span>Horizontal(){const{axis:t,position:e}=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>return"top"===e||"bottom"===e||"x"===t}<span class="fstat-no" title="function not covered" ></span>is</span>FullSize(){<span class="cstat-no" title="statement not covered" >return this.options.fullSize}<span class="fstat-no" title="function not covered" ></span>_c</span>onvertTicksToLabels(t){let e,i;<span class="cstat-no" title="statement not covered" >for(this.beforeTickToLabelConversion(),this.generateTickLabels(t),e=0,i=t.length;e&lt;i;e++)<span class="cstat-no" title="statement not covered" >(0,s.k)(t[e].label)&amp;&amp;(t.splice(e,1),i--,e--);<span class="cstat-no" title="statement not covered" >t</span></span>his.afterTickToLabelConversion()}<span class="fstat-no" title="function not covered" ></span>_g</span>etLabelSizes(){let t=<span class="cstat-no" title="statement not covered" >this._labelSizes;<span class="cstat-no" title="statement not covered" ></span>if(!t){const e=<span class="cstat-no" title="statement not covered" >this.options.ticks.sampleSize;</span>let i=<span class="cstat-no" title="statement not covered" >this.ticks;<span class="cstat-no" title="statement not covered" ></span>e&lt;i.length&amp;&amp;(i=yt(i,e)),this._labelSizes=t=this._computeLabelSizes(i,i.length,this.options.ticks.maxTicksLimit)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn t}<span class="fstat-no" title="function not covered" ></span>_c</span>omputeLabelSizes(t,e,i){const{ctx:n,_longestTextCache:o}=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >[],</span>h=<span class="cstat-no" title="statement not covered" >Math.floor(e/vt(e,i));</span>let l,c,d,u,g,f,p,x,m,b,_,v=<span class="cstat-no" title="statement not covered" >0,</span>y=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(l=0;l&lt;e;l+=h){<span class="cstat-no" title="statement not covered" >if(u=t[l].label,g=this._resolveTickFontOptions(l),n.font=f=g.string,p=o[f]=o[f]||{data:{},gc:[]},x=g.lineHeight,m=b=0,(0,s.k)(u)||(0,s.b)(u)){<span class="cstat-no" title="statement not covered" >if((0,s.b)(u))<span class="cstat-no" title="statement not covered" >for(c=0,d=u.length;c&lt;d;++c)<span class="cstat-no" title="statement not covered" >_=u[c],(0,s.k)(_)||(0,s.b)(_)||(m=(0,s.V)(n,p.data,p.gc,m,_),b+=x)}</span></span></span>else <span class="cstat-no" title="statement not covered" >m=(0,s.V)(n,p.data,p.gc,m,u),b=x;<span class="cstat-no" title="statement not covered" >a</span></span>.push(m),r.push(b),v=Math.max(m,v),y=Math.max(b,y)}<span class="cstat-no" title="statement not covered" ></span>!<span class="fstat-no" title="function not covered" ></span>fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >(0,s.F)(t,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >t.gc,</span>s=<span class="cstat-no" title="statement not covered" >i.length/2;</span>let n;<span class="cstat-no" title="statement not covered" >if(s&gt;e){<span class="cstat-no" title="statement not covered" >for(n=0;n&lt;s;++n)<span class="cstat-no" title="statement not covered" >delete t.data[i[n]];<span class="cstat-no" title="statement not covered" >i</span></span>.splice(0,s)}</span>}</span>))}</span>(o,e);c</span>onst M=<span class="cstat-no" title="statement not covered" >a.indexOf(v),</span>w=<span class="cstat-no" title="statement not covered" >r.indexOf(y),</span>k=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >{width:a[t]||0,height:r[t]||0})</span>;<span class="cstat-no" title="statement not covered" ></span>return{first:k(0),last:k(e-1),widest:k(M),highest:k(w),widths:a,heights:r}}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelForValue(t){<span class="cstat-no" title="statement not covered" >return t}<span class="fstat-no" title="function not covered" ></span>ge</span>tPixelForValue(t,e){<span class="cstat-no" title="statement not covered" >return NaN}<span class="fstat-no" title="function not covered" ></span>ge</span>tValueForPixel(t){}<span class="fstat-no" title="function not covered" >ge</span>tPixelForTick(t){const e=<span class="cstat-no" title="statement not covered" >this.ticks;<span class="cstat-no" title="statement not covered" ></span>return t&lt;0||t&gt;e.length-1?null:this.getPixelForValue(e[t].value)}<span class="fstat-no" title="function not covered" ></span>ge</span>tPixelForDecimal(t){<span class="cstat-no" title="statement not covered" >this._reversePixels&amp;&amp;(t=1-t);c</span>onst e=<span class="cstat-no" title="statement not covered" >this._startPixel+t*this._length;<span class="cstat-no" title="statement not covered" ></span>return(0,s.W)(this._alignToPixels?(0,s.X)(this.chart,e,0):e)}<span class="fstat-no" title="function not covered" ></span>ge</span>tDecimalForPixel(t){const e=<span class="cstat-no" title="statement not covered" >(t-this._startPixel)/this._length;<span class="cstat-no" title="statement not covered" ></span>return this._reversePixels?1-e:e}<span class="fstat-no" title="function not covered" ></span>ge</span>tBasePixel(){<span class="cstat-no" title="statement not covered" >return this.getPixelForValue(this.getBaseValue())}<span class="fstat-no" title="function not covered" ></span>ge</span>tBaseValue(){const{min:t,max:e}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return t&lt;0&amp;&amp;e&lt;0?e:t&gt;0&amp;&amp;e&gt;0?t:0}<span class="fstat-no" title="function not covered" ></span>ge</span>tContext(t){const e=<span class="cstat-no" title="statement not covered" >this.ticks||[];<span class="cstat-no" title="statement not covered" ></span>if(t&gt;=0&amp;&amp;t&lt;e.length){const i=<span class="cstat-no" title="statement not covered" >e[t];<span class="cstat-no" title="statement not covered" ></span>return i.$context||(i.$context=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >return(0,s.j)(t,{tick:i,index:e,type:"tick"})}</span>(this.getContext(),t,i))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this.$context||(this.$context=(i=this.chart.getContext(),n=this,(0,s.j)(i,{scale:n,type:"scale"})));v</span>ar i,n}<span class="fstat-no" title="function not covered" >_t</span>ickSize(){const t=<span class="cstat-no" title="statement not covered" >this.options.ticks,</span>e=<span class="cstat-no" title="statement not covered" >(0,s.t)(this.labelRotation),</span>i=<span class="cstat-no" title="statement not covered" >Math.abs(Math.cos(e)),</span>n=<span class="cstat-no" title="statement not covered" >Math.abs(Math.sin(e)),</span>o=<span class="cstat-no" title="statement not covered" >this._getLabelSizes(),</span>a=<span class="cstat-no" title="statement not covered" >t.autoSkipPadding||0,</span>r=<span class="cstat-no" title="statement not covered" >o?o.widest.width+a:0,</span>h=<span class="cstat-no" title="statement not covered" >o?o.highest.height+a:0;<span class="cstat-no" title="statement not covered" ></span>return this.isHorizontal()?h*i&gt;r*n?r/i:h/n:h*n&lt;r*i?h/i:r/n}<span class="fstat-no" title="function not covered" ></span>_i</span>sVisible(){const t=<span class="cstat-no" title="statement not covered" >this.options.display;<span class="cstat-no" title="statement not covered" ></span>return"auto"!==t?!!t:this.getMatchingVisibleMetas().length&gt;0}<span class="fstat-no" title="function not covered" ></span>_c</span>omputeGridLineItems(t){const e=<span class="cstat-no" title="statement not covered" >this.axis,</span>i=<span class="cstat-no" title="statement not covered" >this.chart,</span>n=<span class="cstat-no" title="statement not covered" >this.options,</span>{grid:o,position:a,border:r}=<span class="cstat-no" title="statement not covered" >n,</span>h=<span class="cstat-no" title="statement not covered" >o.offset,</span>l=<span class="cstat-no" title="statement not covered" >this.isHorizontal(),</span>c=<span class="cstat-no" title="statement not covered" >this.ticks.length+(h?1:0),</span>d=<span class="cstat-no" title="statement not covered" >wt(o),</span>u=<span class="cstat-no" title="statement not covered" >[],</span>g=<span class="cstat-no" title="statement not covered" >r.setContext(this.getContext()),</span>f=<span class="cstat-no" title="statement not covered" >g.display?g.width:0,</span>p=<span class="cstat-no" title="statement not covered" >f/2,</span>x=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return(0,s.X)(i,t,f)}</span>;</span>let m,b,_,v,y,M,w,k,S,D,P,A;<span class="cstat-no" title="statement not covered" >if("top"===a)<span class="cstat-no" title="statement not covered" >m=x(this.bottom),M=this.bottom-d,k=m-p,D=x(t.top)+p,A=t.bottom;e</span>lse <span class="cstat-no" title="statement not covered" >if("bottom"===a)<span class="cstat-no" title="statement not covered" >m=x(this.top),D=t.top,A=x(t.bottom)-p,M=m+p,k=this.top+d;e</span>lse <span class="cstat-no" title="statement not covered" >if("left"===a)<span class="cstat-no" title="statement not covered" >m=x(this.right),y=this.right-d,w=m-p,S=x(t.left)+p,P=t.right;e</span>lse <span class="cstat-no" title="statement not covered" >if("right"===a)<span class="cstat-no" title="statement not covered" >m=x(this.left),S=t.left,P=x(t.right)-p,y=m+p,w=this.left+d;e</span>lse <span class="cstat-no" title="statement not covered" >if("x"===e){<span class="cstat-no" title="statement not covered" >if("center"===a)<span class="cstat-no" title="statement not covered" >m=x((t.top+t.bottom)/2+.5);e</span>lse <span class="cstat-no" title="statement not covered" >if((0,s.i)(a)){const t=<span class="cstat-no" title="statement not covered" >Object.keys(a)[0],</span>e=<span class="cstat-no" title="statement not covered" >a[t];<span class="cstat-no" title="statement not covered" ></span>m=x(this.chart.scales[t].getPixelForValue(e))}<span class="cstat-no" title="statement not covered" ></span>D</span></span>=t.top,A=t.bottom,M=m+p,k=M+d}</span>else <span class="cstat-no" title="statement not covered" >if("y"===e){<span class="cstat-no" title="statement not covered" >if("center"===a)<span class="cstat-no" title="statement not covered" >m=x((t.left+t.right)/2);e</span>lse <span class="cstat-no" title="statement not covered" >if((0,s.i)(a)){const t=<span class="cstat-no" title="statement not covered" >Object.keys(a)[0],</span>e=<span class="cstat-no" title="statement not covered" >a[t];<span class="cstat-no" title="statement not covered" ></span>m=x(this.chart.scales[t].getPixelForValue(e))}<span class="cstat-no" title="statement not covered" ></span>y</span></span>=m-p,w=y-d,S=t.left,P=t.right}</span>c</span></span></span></span></span></span>onst C=<span class="cstat-no" title="statement not covered" >(0,s.v)(n.ticks.maxTicksLimit,c),</span>T=<span class="cstat-no" title="statement not covered" >Math.max(1,Math.ceil(c/C));<span class="cstat-no" title="statement not covered" ></span>for(b=0;b&lt;c;b+=T){const t=<span class="cstat-no" title="statement not covered" >this.getContext(b),</span>e=<span class="cstat-no" title="statement not covered" >o.setContext(t),</span>n=<span class="cstat-no" title="statement not covered" >r.setContext(t),</span>a=<span class="cstat-no" title="statement not covered" >e.lineWidth,</span>c=<span class="cstat-no" title="statement not covered" >e.color,</span>d=<span class="cstat-no" title="statement not covered" >n.dash||[],</span>g=<span class="cstat-no" title="statement not covered" >n.dashOffset,</span>f=<span class="cstat-no" title="statement not covered" >e.tickWidth,</span>p=<span class="cstat-no" title="statement not covered" >e.tickColor,</span>x=<span class="cstat-no" title="statement not covered" >e.tickBorderDash||[],</span>m=<span class="cstat-no" title="statement not covered" >e.tickBorderDashOffset;<span class="cstat-no" title="statement not covered" ></span>_=Mt(this,b,h),void 0!==_&amp;&amp;(v=(0,s.X)(i,_,a),l?y=w=S=P=v:M=k=D=A=v,u.push({tx1:y,ty1:M,tx2:w,ty2:k,x1:S,y1:D,x2:P,y2:A,width:a,color:c,borderDash:d,borderDashOffset:g,tickWidth:f,tickColor:p,tickBorderDash:x,tickBorderDashOffset:m}))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this._ticksLength=c,this._borderValue=m,u}<span class="fstat-no" title="function not covered" ></span>_c</span>omputeLabelItems(t){const e=<span class="cstat-no" title="statement not covered" >this.axis,</span>i=<span class="cstat-no" title="statement not covered" >this.options,</span>{position:n,ticks:o}=<span class="cstat-no" title="statement not covered" >i,</span>a=<span class="cstat-no" title="statement not covered" >this.isHorizontal(),</span>r=<span class="cstat-no" title="statement not covered" >this.ticks,</span>{align:h,crossAlign:l,padding:c,mirror:d}=<span class="cstat-no" title="statement not covered" >o,</span>u=<span class="cstat-no" title="statement not covered" >wt(i.grid),</span>g=<span class="cstat-no" title="statement not covered" >u+c,</span>f=<span class="cstat-no" title="statement not covered" >d?-c:g,</span>p=<span class="cstat-no" title="statement not covered" >-(0,s.t)(this.labelRotation),</span>x=<span class="cstat-no" title="statement not covered" >[];</span>let m,b,_,v,y,M,w,k,S,D,P,A,C=<span class="cstat-no" title="statement not covered" >"middle";<span class="cstat-no" title="statement not covered" ></span>if("top"===n)<span class="cstat-no" title="statement not covered" >M=this.bottom-f,w=this._getXAxisLabelAlignment();e</span>lse <span class="cstat-no" title="statement not covered" >if("bottom"===n)<span class="cstat-no" title="statement not covered" >M=this.top+f,w=this._getXAxisLabelAlignment();e</span>lse <span class="cstat-no" title="statement not covered" >if("left"===n){const t=<span class="cstat-no" title="statement not covered" >this._getYAxisLabelAlignment(u);<span class="cstat-no" title="statement not covered" ></span>w=t.textAlign,y=t.x}</span>else <span class="cstat-no" title="statement not covered" >if("right"===n){const t=<span class="cstat-no" title="statement not covered" >this._getYAxisLabelAlignment(u);<span class="cstat-no" title="statement not covered" ></span>w=t.textAlign,y=t.x}</span>else <span class="cstat-no" title="statement not covered" >if("x"===e){<span class="cstat-no" title="statement not covered" >if("center"===n)<span class="cstat-no" title="statement not covered" >M=(t.top+t.bottom)/2+g;e</span>lse <span class="cstat-no" title="statement not covered" >if((0,s.i)(n)){const t=<span class="cstat-no" title="statement not covered" >Object.keys(n)[0],</span>e=<span class="cstat-no" title="statement not covered" >n[t];<span class="cstat-no" title="statement not covered" ></span>M=this.chart.scales[t].getPixelForValue(e)+g}<span class="cstat-no" title="statement not covered" ></span>w</span></span>=this._getXAxisLabelAlignment()}</span>else <span class="cstat-no" title="statement not covered" >if("y"===e){<span class="cstat-no" title="statement not covered" >if("center"===n)<span class="cstat-no" title="statement not covered" >y=(t.left+t.right)/2-g;e</span>lse <span class="cstat-no" title="statement not covered" >if((0,s.i)(n)){const t=<span class="cstat-no" title="statement not covered" >Object.keys(n)[0],</span>e=<span class="cstat-no" title="statement not covered" >n[t];<span class="cstat-no" title="statement not covered" ></span>y=this.chart.scales[t].getPixelForValue(e)}<span class="cstat-no" title="statement not covered" ></span>w</span></span>=this._getYAxisLabelAlignment(u).textAlign}<span class="cstat-no" title="statement not covered" ></span>"</span></span></span></span></span></span>y"===e&amp;&amp;("start"===h?C="top":"end"===h&amp;&amp;(C="bottom"));c</span>onst T=<span class="cstat-no" title="statement not covered" >this._getLabelSizes();<span class="cstat-no" title="statement not covered" ></span>for(m=0,b=r.length;m&lt;b;++m){<span class="cstat-no" title="statement not covered" >_=r[m],v=_.label;c</span>onst t=<span class="cstat-no" title="statement not covered" >o.setContext(this.getContext(m));<span class="cstat-no" title="statement not covered" ></span>k=this.getPixelForTick(m)+o.labelOffset,S=this._resolveTickFontOptions(m),D=S.lineHeight,P=(0,s.b)(v)?v.length:1;c</span>onst e=<span class="cstat-no" title="statement not covered" >P/2,</span>i=<span class="cstat-no" title="statement not covered" >t.color,</span>h=<span class="cstat-no" title="statement not covered" >t.textStrokeColor,</span>c=<span class="cstat-no" title="statement not covered" >t.textStrokeWidth;</span>let u,g=<span class="cstat-no" title="statement not covered" >w;<span class="cstat-no" title="statement not covered" ></span>if(a?(y=k,"inner"===w&amp;&amp;(g=m===b-1?this.options.reverse?"left":"right":0===m?this.options.reverse?"right":"left":"center"),A="top"===n?"near"===l||0!==p?-P*D+D/2:"center"===l?-T.highest.height/2-e*D+D:-T.highest.height+D/2:"near"===l||0!==p?D/2:"center"===l?T.highest.height/2-e*D:T.highest.height-P*D,d&amp;&amp;(A*=-1),0===p||t.showLabelBackdrop||(y+=D/2*Math.sin(p))):(M=k,A=(1-P)*D/2),t.showLabelBackdrop){const e=<span class="cstat-no" title="statement not covered" >(0,s.E)(t.backdropPadding),</span>i=<span class="cstat-no" title="statement not covered" >T.heights[m],</span>n=<span class="cstat-no" title="statement not covered" >T.widths[m];</span>let o=<span class="cstat-no" title="statement not covered" >A-e.top,</span>a=<span class="cstat-no" title="statement not covered" >0-e.left;<span class="cstat-no" title="statement not covered" ></span>switch(C){case"middle":<span class="cstat-no" title="statement not covered" >o-=i/2;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"bottom":<span class="cstat-no" title="statement not covered" >o-=i}<span class="cstat-no" title="statement not covered" ></span>s</span>witch(w){case"center":<span class="cstat-no" title="statement not covered" >a-=n/2;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"right":<span class="cstat-no" title="statement not covered" >a-=n;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"inner":<span class="cstat-no" title="statement not covered" >m===b-1?a-=n:m&gt;0&amp;&amp;(a-=n/2)}<span class="cstat-no" title="statement not covered" ></span>u</span>={left:a,top:o,width:n+e.width,height:i+e.height,color:t.backdropColor}}<span class="cstat-no" title="statement not covered" ></span>x</span>.push({label:v,font:S,textOffset:A,options:{rotation:p,color:i,strokeColor:h,strokeWidth:c,textAlign:g,textBaseline:C,translation:[y,M],backdrop:u}})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn x}<span class="fstat-no" title="function not covered" ></span>_g</span>etXAxisLabelAlignment(){const{position:t,ticks:e}=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if(-(0,s.t)(this.labelRotation))<span class="cstat-no" title="statement not covered" >return"top"===t?"left":"right";l</span></span>et i=<span class="cstat-no" title="statement not covered" >"center";<span class="cstat-no" title="statement not covered" ></span>return"start"===e.align?i="left":"end"===e.align?i="right":"inner"===e.align&amp;&amp;(i="inner"),i}<span class="fstat-no" title="function not covered" ></span>_g</span>etYAxisLabelAlignment(t){const{position:e,ticks:{crossAlign:i,mirror:s,padding:n}}=<span class="cstat-no" title="statement not covered" >this.options,</span>o=<span class="cstat-no" title="statement not covered" >t+n,</span>a=<span class="cstat-no" title="statement not covered" >this._getLabelSizes().widest.width;</span>let r,h;<span class="cstat-no" title="statement not covered" >return"left"===e?s?(h=this.right+n,"near"===i?r="left":"center"===i?(r="center",h+=a/2):(r="right",h+=a)):(h=this.right-o,"near"===i?r="right":"center"===i?(r="center",h-=a/2):(r="left",h=this.left)):"right"===e?s?(h=this.left+n,"near"===i?r="right":"center"===i?(r="center",h-=a/2):(r="left",h-=a)):(h=this.left+o,"near"===i?r="left":"center"===i?(r="center",h+=a/2):(r="right",h=this.right)):r="right",{textAlign:r,x:h}}<span class="fstat-no" title="function not covered" ></span>_c</span>omputeLabelArea(){<span class="cstat-no" title="statement not covered" >if(this.options.ticks.mirror)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this.chart,</span>e=<span class="cstat-no" title="statement not covered" >this.options.position;<span class="cstat-no" title="statement not covered" ></span>return"left"===e||"right"===e?{top:0,left:this.left,bottom:t.height,right:this.right}:"top"===e||"bottom"===e?{top:this.top,left:0,bottom:this.bottom,right:t.width}:void 0}<span class="fstat-no" title="function not covered" ></span>dr</span>awBackground(){const{ctx:t,options:{backgroundColor:e},left:i,top:s,width:n,height:o}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;(t.save(),t.fillStyle=e,t.fillRect(i,s,n,o),t.restore())}<span class="fstat-no" title="function not covered" ></span>ge</span>tLineWidthForValue(t){const e=<span class="cstat-no" title="statement not covered" >this.options.grid;<span class="cstat-no" title="statement not covered" ></span>if(!this._isVisible()||!e.display)<span class="cstat-no" title="statement not covered" >return 0;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >this.ticks.findIndex((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.value===t)</span>);<span class="cstat-no" title="statement not covered" ></span>if(i&gt;=0){<span class="cstat-no" title="statement not covered" >return e.setContext(this.getContext(i)).lineWidth}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn 0}<span class="fstat-no" title="function not covered" ></span>dr</span>awGrid(t){const e=<span class="cstat-no" title="statement not covered" >this.options.grid,</span>i=<span class="cstat-no" title="statement not covered" >this.ctx,</span>s=<span class="cstat-no" title="statement not covered" >this._gridLineItems||(this._gridLineItems=this._computeGridLineItems(t));</span>let n,o;const a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >s.width&amp;&amp;s.color&amp;&amp;(i.save(),i.lineWidth=s.width,i.strokeStyle=s.color,i.setLineDash(s.borderDash||[]),i.lineDashOffset=s.borderDashOffset,i.beginPath(),i.moveTo(t.x,t.y),i.lineTo(e.x,e.y),i.stroke(),i.restore())}</span>;<span class="cstat-no" title="statement not covered" ></span>if(e.display)<span class="cstat-no" title="statement not covered" >for(n=0,o=s.length;n&lt;o;++n){const t=<span class="cstat-no" title="statement not covered" >s[n];<span class="cstat-no" title="statement not covered" ></span>e.drawOnChartArea&amp;&amp;a({x:t.x1,y:t.y1},{x:t.x2,y:t.y2},t),e.drawTicks&amp;&amp;a({x:t.tx1,y:t.ty1},{x:t.tx2,y:t.ty2},{color:t.tickColor,width:t.tickWidth,borderDash:t.tickBorderDash,borderDashOffset:t.tickBorderDashOffset})}</span>}<span class="fstat-no" title="function not covered" ></span></span>dr</span>awBorder(){const{chart:t,ctx:e,options:{border:i,grid:n}}=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >i.setContext(this.getContext()),</span>a=<span class="cstat-no" title="statement not covered" >i.display?o.width:0;<span class="cstat-no" title="statement not covered" ></span>if(!a)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >n.setContext(this.getContext(0)).lineWidth,</span>h=<span class="cstat-no" title="statement not covered" >this._borderValue;</span>let l,c,d,u;<span class="cstat-no" title="statement not covered" >this.isHorizontal()?(l=(0,s.X)(t,this.left,a)-a/2,c=(0,s.X)(t,this.right,r)+r/2,d=u=h):(d=(0,s.X)(t,this.top,a)-a/2,u=(0,s.X)(t,this.bottom,r)+r/2,l=c=h),e.save(),e.lineWidth=o.width,e.strokeStyle=o.color,e.beginPath(),e.moveTo(l,d),e.lineTo(c,u),e.stroke(),e.restore()}<span class="fstat-no" title="function not covered" ></span>dr</span>awLabels(t){<span class="cstat-no" title="statement not covered" >if(!this.options.ticks.display)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.ctx,</span>i=<span class="cstat-no" title="statement not covered" >this._computeLabelArea();<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;(0,s.Y)(e,i);c</span>onst n=<span class="cstat-no" title="statement not covered" >this.getLabelItems(t);<span class="cstat-no" title="statement not covered" ></span>for(const o of n){const t=<span class="cstat-no" title="statement not covered" >o.options,</span>i=<span class="cstat-no" title="statement not covered" >o.font,</span>n=<span class="cstat-no" title="statement not covered" >o.label,</span>a=<span class="cstat-no" title="statement not covered" >o.textOffset;<span class="cstat-no" title="statement not covered" ></span>(0,s.Z)(e,n,0,a,i,t)}<span class="cstat-no" title="statement not covered" ></span>i</span>&amp;&amp;(0,s.$)(e)}<span class="fstat-no" title="function not covered" ></span>dr</span>awTitle(){const{ctx:t,options:{position:e,title:i,reverse:n}}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(!i.display)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >(0,s.a0)(i.font),</span>a=<span class="cstat-no" title="statement not covered" >(0,s.E)(i.padding),</span>r=<span class="cstat-no" title="statement not covered" >i.align;</span>let h=<span class="cstat-no" title="statement not covered" >o.lineHeight/2;<span class="cstat-no" title="statement not covered" ></span>"bottom"===e||"center"===e||(0,s.i)(e)?(h+=a.bottom,(0,s.b)(i.text)&amp;&amp;(h+=o.lineHeight*(i.text.length-1))):h+=a.top;c</span>onst{titleX:l,titleY:c,maxWidth:d,rotation:u}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,n){const{top:o,left:a,bottom:r,right:h,chart:l}=<span class="cstat-no" title="statement not covered" >t,</span>{chartArea:c,scales:d}=<span class="cstat-no" title="statement not covered" >l;</span>let u,g,f,p=<span class="cstat-no" title="statement not covered" >0;</span>const x=<span class="cstat-no" title="statement not covered" >r-o,</span>m=<span class="cstat-no" title="statement not covered" >h-a;<span class="cstat-no" title="statement not covered" ></span>if(t.isHorizontal()){<span class="cstat-no" title="statement not covered" >if(g=(0,s.a2)(n,a,h),(0,s.i)(i)){const t=<span class="cstat-no" title="statement not covered" >Object.keys(i)[0],</span>s=<span class="cstat-no" title="statement not covered" >i[t];<span class="cstat-no" title="statement not covered" ></span>f=d[t].getPixelForValue(s)+x-e}</span>else <span class="cstat-no" title="statement not covered" >f="center"===i?(c.bottom+c.top)/2+x-e:_t(t,i,e);<span class="cstat-no" title="statement not covered" >u</span></span>=h-a}</span>else{<span class="cstat-no" title="statement not covered" >if((0,s.i)(i)){const t=<span class="cstat-no" title="statement not covered" >Object.keys(i)[0],</span>s=<span class="cstat-no" title="statement not covered" >i[t];<span class="cstat-no" title="statement not covered" ></span>g=d[t].getPixelForValue(s)-m+e}</span>else <span class="cstat-no" title="statement not covered" >g="center"===i?(c.left+c.right)/2-m+e:_t(t,i,e);<span class="cstat-no" title="statement not covered" >f</span></span>=(0,s.a2)(n,r,o),p="left"===i?-s.H:s.H}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{titleX:g,titleY:f,maxWidth:u,rotation:p}}</span>(this,h,e,r);<span class="cstat-no" title="statement not covered" ></span>(0,s.Z)(t,i.text,0,0,o,{color:i.color,maxWidth:d,rotation:u,textAlign:St(r,e,n),textBaseline:"middle",translation:[l,c]})}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(t){<span class="cstat-no" title="statement not covered" >this._isVisible()&amp;&amp;(this.drawBackground(),this.drawGrid(t),this.drawBorder(),this.drawTitle(),this.drawLabels(t))}<span class="fstat-no" title="function not covered" ></span>_l</span>ayers(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >t.ticks&amp;&amp;t.ticks.z||0,</span>i=<span class="cstat-no" title="statement not covered" >(0,s.v)(t.grid&amp;&amp;t.grid.z,-1),</span>n=<span class="cstat-no" title="statement not covered" >(0,s.v)(t.border&amp;&amp;t.border.z,0);<span class="cstat-no" title="statement not covered" ></span>return this._isVisible()&amp;&amp;this.draw===Dt.prototype.draw?[{z:i,draw:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.drawBackground(),this.drawGrid(t),this.drawTitle()}</span>},{z:n,draw:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.drawBorder()}</span>},{z:e,draw:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.drawLabels(t)}</span>}]:[{z:e,draw:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.draw(t)}</span>}]}<span class="fstat-no" title="function not covered" ></span>ge</span>tMatchingVisibleMetas(t){const e=<span class="cstat-no" title="statement not covered" >this.chart.getSortedVisibleDatasetMetas(),</span>i=<span class="cstat-no" title="statement not covered" >this.axis+"AxisID",</span>s=<span class="cstat-no" title="statement not covered" >[];</span>let n,o;<span class="cstat-no" title="statement not covered" >for(n=0,o=e.length;n&lt;o;++n){const o=<span class="cstat-no" title="statement not covered" >e[n];<span class="cstat-no" title="statement not covered" ></span>o[i]!==this.id||t&amp;&amp;o.type!==t||s.push(o)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}<span class="fstat-no" title="function not covered" ></span>_r</span>esolveTickFontOptions(t){const e=<span class="cstat-no" title="statement not covered" >this.options.ticks.setContext(this.getContext(t));<span class="cstat-no" title="statement not covered" ></span>return(0,s.a0)(e.font)}<span class="fstat-no" title="function not covered" ></span>_m</span>axDigits(){const t=<span class="cstat-no" title="statement not covered" >this._resolveTickFontOptions(0).lineHeight;<span class="cstat-no" title="statement not covered" ></span>return(this.isHorizontal()?this.width:this.height)/t}</span>}class Pt{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,i){<span class="cstat-no" title="statement not covered" >this.type=t,this.scope=e,this.override=i,this.items=Object.create(null)}<span class="fstat-no" title="function not covered" ></span>is</span>ForType(t){<span class="cstat-no" title="statement not covered" >return Object.prototype.isPrototypeOf.call(this.type.prototype,t.prototype)}<span class="fstat-no" title="function not covered" ></span>re</span>gister(t){const e=<span class="cstat-no" title="statement not covered" >Object.getPrototypeOf(t);</span>let i;<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return"id"in t&amp;&amp;"defaults"in t}</span>)(e)&amp;&amp;(i=this.register(e));c</span>onst n=<span class="cstat-no" title="statement not covered" >this.items,</span>o=<span class="cstat-no" title="statement not covered" >t.id,</span>a=<span class="cstat-no" title="statement not covered" >this.scope+"."+o;<span class="cstat-no" title="statement not covered" ></span>if(!o)<span class="cstat-no" title="statement not covered" >throw new Error("class does not have id: "+t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn o in n||(n[o]=t,<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const n=<span class="cstat-no" title="statement not covered" >(0,s.a4)(Object.create(null),[i?s.d.get(i):{},s.d.get(e),t.defaults]);<span class="cstat-no" title="statement not covered" ></span>s.d.set(e,n),t.defaultRoutes&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >Object.keys(e).forEach((<span class="fstat-no" title="function not covered" >i=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >i.split("."),</span>o=<span class="cstat-no" title="statement not covered" >n.pop(),</span>a=<span class="cstat-no" title="statement not covered" >[t].concat(n).join("."),</span>r=<span class="cstat-no" title="statement not covered" >e[i].split("."),</span>h=<span class="cstat-no" title="statement not covered" >r.pop(),</span>l=<span class="cstat-no" title="statement not covered" >r.join(".");<span class="cstat-no" title="statement not covered" ></span>s.d.route(a,o,l,h)}</span>))}</span>(e,t.defaultRoutes);<span class="cstat-no" title="statement not covered" >t</span>.descriptors&amp;&amp;s.d.describe(e,t.descriptors)}</span>(t,a,i),this.override&amp;&amp;s.d.override(t.id,t.overrides)),a}<span class="fstat-no" title="function not covered" ></span>ge</span>t(t){<span class="cstat-no" title="statement not covered" >return this.items[t]}<span class="fstat-no" title="function not covered" ></span>un</span>register(t){const e=<span class="cstat-no" title="statement not covered" >this.items,</span>i=<span class="cstat-no" title="statement not covered" >t.id,</span>n=<span class="cstat-no" title="statement not covered" >this.scope;<span class="cstat-no" title="statement not covered" ></span>i in e&amp;&amp;delete e[i],n&amp;&amp;i in s.d[n]&amp;&amp;(delete s.d[n][i],this.override&amp;&amp;delete s.a3[i])}</span>}class At{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.controllers=new Pt(y,"datasets",!0),this.elements=new Pt(xt,"elements"),this.plugins=new Pt(Object,"plugins"),this.scales=new Pt(Dt,"scales"),this._typedRegistries=[this.controllers,this.scales,this.elements]}<span class="fstat-no" title="function not covered" ></span>ad</span>d(...t){<span class="cstat-no" title="statement not covered" >this._each("register",t)}<span class="fstat-no" title="function not covered" ></span>re</span>move(...t){<span class="cstat-no" title="statement not covered" >this._each("unregister",t)}<span class="fstat-no" title="function not covered" ></span>ad</span>dControllers(...t){<span class="cstat-no" title="statement not covered" >this._each("register",t,this.controllers)}<span class="fstat-no" title="function not covered" ></span>ad</span>dElements(...t){<span class="cstat-no" title="statement not covered" >this._each("register",t,this.elements)}<span class="fstat-no" title="function not covered" ></span>ad</span>dPlugins(...t){<span class="cstat-no" title="statement not covered" >this._each("register",t,this.plugins)}<span class="fstat-no" title="function not covered" ></span>ad</span>dScales(...t){<span class="cstat-no" title="statement not covered" >this._each("register",t,this.scales)}<span class="fstat-no" title="function not covered" ></span>ge</span>tController(t){<span class="cstat-no" title="statement not covered" >return this._get(t,this.controllers,"controller")}<span class="fstat-no" title="function not covered" ></span>ge</span>tElement(t){<span class="cstat-no" title="statement not covered" >return this._get(t,this.elements,"element")}<span class="fstat-no" title="function not covered" ></span>ge</span>tPlugin(t){<span class="cstat-no" title="statement not covered" >return this._get(t,this.plugins,"plugin")}<span class="fstat-no" title="function not covered" ></span>ge</span>tScale(t){<span class="cstat-no" title="statement not covered" >return this._get(t,this.scales,"scale")}<span class="fstat-no" title="function not covered" ></span>re</span>moveControllers(...t){<span class="cstat-no" title="statement not covered" >this._each("unregister",t,this.controllers)}<span class="fstat-no" title="function not covered" ></span>re</span>moveElements(...t){<span class="cstat-no" title="statement not covered" >this._each("unregister",t,this.elements)}<span class="fstat-no" title="function not covered" ></span>re</span>movePlugins(...t){<span class="cstat-no" title="statement not covered" >this._each("unregister",t,this.plugins)}<span class="fstat-no" title="function not covered" ></span>re</span>moveScales(...t){<span class="cstat-no" title="statement not covered" >this._each("unregister",t,this.scales)}<span class="fstat-no" title="function not covered" ></span>_e</span>ach(t,e,i){<span class="cstat-no" title="statement not covered" >[...e].forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >i||this._getRegistryForType(e);<span class="cstat-no" title="statement not covered" ></span>i||n.isForType(e)||n===this.plugins&amp;&amp;e.id?this._exec(t,n,e):(0,s.F)(e,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >i||this._getRegistryForType(e);<span class="cstat-no" title="statement not covered" ></span>this._exec(t,s,e)}</span>))}</span>))}<span class="fstat-no" title="function not covered" ></span>_e</span>xec(t,e,i){const n=<span class="cstat-no" title="statement not covered" >(0,s.a5)(t);<span class="cstat-no" title="statement not covered" ></span>(0,s.Q)(i["before"+n],[],i),e[t](i),(0,s.Q)(i["after"+n],[],i)}<span class="fstat-no" title="function not covered" ></span>_g</span>etRegistryForType(t){<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this._typedRegistries.length;e++){const i=<span class="cstat-no" title="statement not covered" >this._typedRegistries[e];<span class="cstat-no" title="statement not covered" ></span>if(i.isForType(t))<span class="cstat-no" title="statement not covered" >return i}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn this.plugins}<span class="fstat-no" title="function not covered" ></span>_g</span>et(t,e,i){const s=<span class="cstat-no" title="statement not covered" >e.get(t);<span class="cstat-no" title="statement not covered" ></span>if(void 0===s)<span class="cstat-no" title="statement not covered" >throw new Error('"'+t+'" is not a registered '+i+".");<span class="cstat-no" title="statement not covered" >r</span></span>eturn s}</span>}var Ct=<span class="cstat-no" title="statement not covered" >new At;</span>class Tt{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this._init=void 0}<span class="fstat-no" title="function not covered" ></span>no</span>tify(t,e,i,s){<span class="cstat-no" title="statement not covered" >if("beforeInit"===e&amp;&amp;(this._init=this._createDescriptors(t,!0),this._notify(this._init,t,"install")),void 0===this._init)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >s?this._descriptors(t).filter(s):this._descriptors(t),</span>o=<span class="cstat-no" title="statement not covered" >this._notify(n,t,e,i);<span class="cstat-no" title="statement not covered" ></span>return"afterDestroy"===e&amp;&amp;(this._notify(n,t,"stop"),this._notify(this._init,t,"uninstall"),this._init=void 0),o}<span class="fstat-no" title="function not covered" ></span>_n</span>otify(t,e,i,n){<span class="cstat-no" title="statement not covered" >n=n||{};<span class="cstat-no" title="statement not covered" >f</span>or(const o of t){const t=<span class="cstat-no" title="statement not covered" >o.plugin,</span>a=<span class="cstat-no" title="statement not covered" >t[i],</span>r=<span class="cstat-no" title="statement not covered" >[e,n,o.options];<span class="cstat-no" title="statement not covered" ></span>if(!1===(0,s.Q)(a,r,t)&amp;&amp;n.cancelable)<span class="cstat-no" title="statement not covered" >return!1}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!0}<span class="fstat-no" title="function not covered" ></span>in</span>validate(){<span class="cstat-no" title="statement not covered" >(0,s.k)(this._cache)||(this._oldCache=this._cache,this._cache=void 0)}<span class="fstat-no" title="function not covered" ></span>_d</span>escriptors(t){<span class="cstat-no" title="statement not covered" >if(this._cache)<span class="cstat-no" title="statement not covered" >return this._cache;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this._cache=this._createDescriptors(t);<span class="cstat-no" title="statement not covered" ></span>return this._notifyStateChanges(t),e}<span class="fstat-no" title="function not covered" ></span>_c</span>reateDescriptors(t,e){const i=<span class="cstat-no" title="statement not covered" >t&amp;&amp;t.config,</span>n=<span class="cstat-no" title="statement not covered" >(0,s.v)(i.options&amp;&amp;i.options.plugins,{}),</span>o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >{},</span>i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >Object.keys(Ct.plugins.items);<span class="cstat-no" title="statement not covered" ></span>for(let o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;s.length;o++)<span class="cstat-no" title="statement not covered" >i.push(Ct.getPlugin(s[o]));c</span></span>onst n=<span class="cstat-no" title="statement not covered" >t.plugins||[];<span class="cstat-no" title="statement not covered" ></span>for(let o=<span class="cstat-no" title="statement not covered" >0;</span>o&lt;n.length;o++){const t=<span class="cstat-no" title="statement not covered" >n[o];<span class="cstat-no" title="statement not covered" ></span>-1===i.indexOf(t)&amp;&amp;(i.push(t),e[t.id]=!0)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{plugins:i,localIds:e}}</span>(i);<span class="cstat-no" title="statement not covered" ></span>return!1!==n||e?<span class="fstat-no" title="function not covered" >fu</span>nction(t,{plugins:e,localIds:i},s,n){const o=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >t.getContext();<span class="cstat-no" title="statement not covered" ></span>for(const r of e){const e=<span class="cstat-no" title="statement not covered" >r.id,</span>h=<span class="cstat-no" title="statement not covered" >Ot(s[e],n);<span class="cstat-no" title="statement not covered" ></span>null!==h&amp;&amp;o.push({plugin:r,options:Et(t.config,{plugin:r,local:i[e]},h,a)})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o}</span>(t,o,n,e):[]}<span class="fstat-no" title="function not covered" ></span>_n</span>otifyStateChanges(t){const e=<span class="cstat-no" title="statement not covered" >this._oldCache||[],</span>i=<span class="cstat-no" title="statement not covered" >this._cache,</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!e.some((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >t.plugin.id===e.plugin.id)</span>))</span>);<span class="cstat-no" title="statement not covered" ></span></span>this._notify(s(e,i),t,"stop"),this._notify(s(i,e),t,"start")}</span>}function <span class="fstat-no" title="function not covered" >Ot(</span>t,e){<span class="cstat-no" title="statement not covered" >return e||!1!==t?!0===t?{}:t:null}</span>function <span class="fstat-no" title="function not covered" >Et(</span>t,{plugin:e,local:i},s,n){const o=<span class="cstat-no" title="statement not covered" >t.pluginScopeKeys(e),</span>a=<span class="cstat-no" title="statement not covered" >t.getOptionScopes(s,o);<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;e.defaults&amp;&amp;a.push(e.defaults),t.createResolver(a,n,[""],{scriptable:!1,indexable:!1,allKeys:!0})}</span>function <span class="fstat-no" title="function not covered" >Rt(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >s.d.datasets[t]||{};<span class="cstat-no" title="statement not covered" ></span>return((e.datasets||{})[t]||{}).indexAxis||e.indexAxis||i.indexAxis||"x"}</span>function <span class="fstat-no" title="function not covered" >It(</span>t){<span class="cstat-no" title="statement not covered" >if("x"===t||"y"===t||"r"===t)<span class="cstat-no" title="statement not covered" >return t}</span></span>function <span class="fstat-no" title="function not covered" >Lt(</span>t,...e){<span class="cstat-no" title="statement not covered" >if(It(t))<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >f</span></span>or(const s of e){const e=<span class="cstat-no" title="statement not covered" >s.axis||("top"===(i=s.position)||"bottom"===i?"x":"left"===i||"right"===i?"y":void 0)||t.length&gt;1&amp;&amp;It(t[0].toLowerCase());<span class="cstat-no" title="statement not covered" ></span>if(e)<span class="cstat-no" title="statement not covered" >return e}</span></span>v</span>ar i;<span class="cstat-no" title="statement not covered" >throw new Error(`Cannot determine type of '${t}' axis. Please provide 'axis' or 'position' option.`)}</span>function <span class="fstat-no" title="function not covered" >zt(</span>t,e,i){<span class="cstat-no" title="statement not covered" >if(i[e+"AxisID"]===t)<span class="cstat-no" title="statement not covered" >return{axis:e}}</span></span>function <span class="fstat-no" title="function not covered" >Ft(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >s.a3[t.type]||{scales:{}},</span>n=<span class="cstat-no" title="statement not covered" >e.scales||{},</span>o=<span class="cstat-no" title="statement not covered" >Rt(t.type,e),</span>a=<span class="cstat-no" title="statement not covered" >Object.create(null);<span class="cstat-no" title="statement not covered" ></span>return Object.keys(n).forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const r=<span class="cstat-no" title="statement not covered" >n[e];<span class="cstat-no" title="statement not covered" ></span>if(!(0,s.i)(r))<span class="cstat-no" title="statement not covered" >return console.error(`Invalid scale configuration for scale: ${e}`);<span class="cstat-no" title="statement not covered" >i</span></span>f(r._proxy)<span class="cstat-no" title="statement not covered" >return console.warn(`Ignoring resolver passed as options for scale: ${e}`);c</span></span>onst h=<span class="cstat-no" title="statement not covered" >Lt(e,r,<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(e.data&amp;&amp;e.data.datasets){const i=<span class="cstat-no" title="statement not covered" >e.data.datasets.filter((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.xAxisID===t||e.yAxisID===t)</span>);<span class="cstat-no" title="statement not covered" ></span>if(i.length)<span class="cstat-no" title="statement not covered" >return zt(t,"x",i[0])||zt(t,"y",i[0])}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn{}}</span>(e,t),s.d.scales[r.type]),</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t===e?"_index_":"_value_"}</span>(h,o),</span>c=<span class="cstat-no" title="statement not covered" >i.scales||{};<span class="cstat-no" title="statement not covered" ></span>a[e]=(0,s.ab)(Object.create(null),[{axis:h},r,c[h],c[l]])}</span>)),t.data.datasets.forEach((<span class="fstat-no" title="function not covered" >i=</span>&gt;{const o=<span class="cstat-no" title="statement not covered" >i.type||t.type,</span>r=<span class="cstat-no" title="statement not covered" >i.indexAxis||Rt(o,e),</span>h=<span class="cstat-no" title="statement not covered" >(s.a3[o]||{}).scales||{};<span class="cstat-no" title="statement not covered" ></span>Object.keys(h).forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){let i=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return"_index_"===t?i=e:"_value_"===t&amp;&amp;(i="x"===e?"y":"x"),i}</span>(t,r),</span>o=<span class="cstat-no" title="statement not covered" >i[e+"AxisID"]||e;<span class="cstat-no" title="statement not covered" ></span>a[o]=a[o]||Object.create(null),(0,s.ab)(a[o],[{axis:e},n[o],h[t]])}</span>))}</span>)),Object.keys(a).forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >a[t];<span class="cstat-no" title="statement not covered" ></span>(0,s.ab)(e,[s.d.scales[e.type],s.d.scale])}</span>)),a}</span>function <span class="fstat-no" title="function not covered" >Bt(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.options||(t.options={});<span class="cstat-no" title="statement not covered" ></span>e.plugins=(0,s.v)(e.plugins,{}),e.scales=Ft(t,e)}</span>function <span class="fstat-no" title="function not covered" >Ht(</span>t){<span class="cstat-no" title="statement not covered" >return(t=t||{}).datasets=t.datasets||[],t.labels=t.labels||[],t}</span>const Vt=<span class="cstat-no" title="statement not covered" >new Map,</span>Wt=<span class="cstat-no" title="statement not covered" >new Set;</span>function <span class="fstat-no" title="function not covered" >Nt(</span>t,e){let i=<span class="cstat-no" title="statement not covered" >Vt.get(t);<span class="cstat-no" title="statement not covered" ></span>return i||(i=e(),Vt.set(t,i),Wt.add(i)),i}</span>const jt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{const n=<span class="cstat-no" title="statement not covered" >(0,s.f)(e,i);<span class="cstat-no" title="statement not covered" ></span>void 0!==n&amp;&amp;t.add(n)}</span>;</span>class $t{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this._config=<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return(t=t||{}).data=Ht(t.data),Bt(t),t}</span>(t),this._scopeCache=new Map,this._resolverCache=new Map}<span class="fstat-no" title="function not covered" ></span>ge</span>t platform(){<span class="cstat-no" title="statement not covered" >return this._config.platform}<span class="fstat-no" title="function not covered" ></span>ge</span>t type(){<span class="cstat-no" title="statement not covered" >return this._config.type}<span class="fstat-no" title="function not covered" ></span>se</span>t type(t){<span class="cstat-no" title="statement not covered" >this._config.type=t}<span class="fstat-no" title="function not covered" ></span>ge</span>t data(){<span class="cstat-no" title="statement not covered" >return this._config.data}<span class="fstat-no" title="function not covered" ></span>se</span>t data(t){<span class="cstat-no" title="statement not covered" >this._config.data=Ht(t)}<span class="fstat-no" title="function not covered" ></span>ge</span>t options(){<span class="cstat-no" title="statement not covered" >return this._config.options}<span class="fstat-no" title="function not covered" ></span>se</span>t options(t){<span class="cstat-no" title="statement not covered" >this._config.options=t}<span class="fstat-no" title="function not covered" ></span>ge</span>t plugins(){<span class="cstat-no" title="statement not covered" >return this._config.plugins}<span class="fstat-no" title="function not covered" ></span>up</span>date(){const t=<span class="cstat-no" title="statement not covered" >this._config;<span class="cstat-no" title="statement not covered" ></span>this.clearCache(),Bt(t)}<span class="fstat-no" title="function not covered" ></span>cl</span>earCache(){<span class="cstat-no" title="statement not covered" >this._scopeCache.clear(),this._resolverCache.clear()}<span class="fstat-no" title="function not covered" ></span>da</span>tasetScopeKeys(t){<span class="cstat-no" title="statement not covered" >return Nt(t,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[[`datasets.${t}`,""]])</span>)}<span class="fstat-no" title="function not covered" ></span>da</span>tasetAnimationScopeKeys(t,e){<span class="cstat-no" title="statement not covered" >return Nt(`${t}.transition.${e}`,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[[`datasets.${t}.transitions.${e}`,`transitions.${e}`],[`datasets.${t}`,""]])</span>)}<span class="fstat-no" title="function not covered" ></span>da</span>tasetElementScopeKeys(t,e){<span class="cstat-no" title="statement not covered" >return Nt(`${t}-${e}`,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[[`datasets.${t}.elements.${e}`,`datasets.${t}`,`elements.${e}`,""]])</span>)}<span class="fstat-no" title="function not covered" ></span>pl</span>uginScopeKeys(t){const e=<span class="cstat-no" title="statement not covered" >t.id;<span class="cstat-no" title="statement not covered" ></span>return Nt(`${this.type}-plugin-${e}`,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >[[`plugins.${e}`,...t.additionalOptionScopes||[]]])</span>)}<span class="fstat-no" title="function not covered" ></span>_c</span>achedScopes(t,e){const i=<span class="cstat-no" title="statement not covered" >this._scopeCache;</span>let s=<span class="cstat-no" title="statement not covered" >i.get(t);<span class="cstat-no" title="statement not covered" ></span>return s&amp;&amp;!e||(s=new Map,i.set(t,s)),s}<span class="fstat-no" title="function not covered" ></span>ge</span>tOptionScopes(t,e,i){const{options:n,type:o}=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" >this._cachedScopes(t,i),</span>r=<span class="cstat-no" title="statement not covered" >a.get(e);<span class="cstat-no" title="statement not covered" ></span>if(r)<span class="cstat-no" title="statement not covered" >return r;c</span></span>onst h=<span class="cstat-no" title="statement not covered" >new Set;<span class="cstat-no" title="statement not covered" ></span>e.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >t&amp;&amp;(h.add(t),e.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >jt(h,t,e))</span>)),e.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >jt(h,n,t))</span>),e.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >jt(h,s.a3[o]||{},t))</span>),e.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >jt(h,s.d,t))</span>),e.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >jt(h,s.a6,t))</span>)}</span>));c</span>onst l=<span class="cstat-no" title="statement not covered" >Array.from(h);<span class="cstat-no" title="statement not covered" ></span>return 0===l.length&amp;&amp;l.push(Object.create(null)),Wt.has(e)&amp;&amp;a.set(e,l),l}<span class="fstat-no" title="function not covered" ></span>ch</span>artOptionScopes(){const{options:t,type:e}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return[t,s.a3[e]||{},s.d.datasets[e]||{},{type:e},s.d,s.a6]}<span class="fstat-no" title="function not covered" ></span>re</span>solveNamedOptions(t,e,i,n=<span class="branch-0 cbranch-no" title="branch not covered" >[""])</span>{const o=<span class="cstat-no" title="statement not covered" >{$shared:!0},</span>{resolver:a,subPrefixes:r}=<span class="cstat-no" title="statement not covered" >Ut(this._resolverCache,t,n);</span>let h=<span class="cstat-no" title="statement not covered" >a;<span class="cstat-no" title="statement not covered" ></span>if(<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const{isScriptable:i,isIndexable:n}=<span class="cstat-no" title="statement not covered" >(0,s.aa)(t);<span class="cstat-no" title="statement not covered" ></span>for(const o of e){const e=<span class="cstat-no" title="statement not covered" >i(o),</span>a=<span class="cstat-no" title="statement not covered" >n(o),</span>r=<span class="cstat-no" title="statement not covered" >(a||e)&amp;&amp;t[o];<span class="cstat-no" title="statement not covered" ></span>if(e&amp;&amp;((0,s.a7)(r)||Yt(r))||a&amp;&amp;(0,s.b)(r))<span class="cstat-no" title="statement not covered" >return!0}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn!1}</span>(a,e)){<span class="cstat-no" title="statement not covered" >o.$shared=!1,i=(0,s.a7)(i)?i():i;c</span>onst e=<span class="cstat-no" title="statement not covered" >this.createResolver(t,i,r);<span class="cstat-no" title="statement not covered" ></span>h=(0,s.a8)(a,i,e)}<span class="cstat-no" title="statement not covered" ></span>f</span>or(const s of e)<span class="cstat-no" title="statement not covered" >o[s]=h[s];<span class="cstat-no" title="statement not covered" >r</span></span>eturn o}<span class="fstat-no" title="function not covered" ></span>cr</span>eateResolver(t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >[""],</span>n){const{resolver:o}=<span class="cstat-no" title="statement not covered" >Ut(this._resolverCache,t,i);<span class="cstat-no" title="statement not covered" ></span>return(0,s.i)(e)?(0,s.a8)(o,e,void 0,n):o}</span>}function <span class="fstat-no" title="function not covered" >Ut(</span>t,e,i){let n=<span class="cstat-no" title="statement not covered" >t.get(e);<span class="cstat-no" title="statement not covered" ></span>n||(n=new Map,t.set(e,n));c</span>onst o=<span class="cstat-no" title="statement not covered" >i.join();</span>let a=<span class="cstat-no" title="statement not covered" >n.get(o);<span class="cstat-no" title="statement not covered" ></span>if(!a){<span class="cstat-no" title="statement not covered" >a={resolver:(0,s.a9)(e,i),subPrefixes:i.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!t.toLowerCase().includes("hover"))</span>)},n.set(o,a)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn a}</span>const Yt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(0,s.i)(t)&amp;&amp;Object.getOwnPropertyNames(t).some((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >(0,s.a7)(t[e]))</span>);</span></span>const Xt=<span class="cstat-no" title="statement not covered" >["top","bottom","left","right","chartArea"];</span>function <span class="fstat-no" title="function not covered" >Qt(</span>t,e){<span class="cstat-no" title="statement not covered" >return"top"===t||"bottom"===t||-1===Xt.indexOf(t)&amp;&amp;"x"===e}</span>function <span class="fstat-no" title="function not covered" >Gt(</span>t,e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(i,s){<span class="cstat-no" title="statement not covered" >return i[t]===s[t]?i[e]-s[e]:i[t]-s[t]}</span>}</span>function <span class="fstat-no" title="function not covered" >Kt(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.chart,</span>i=<span class="cstat-no" title="statement not covered" >e.options.animation;<span class="cstat-no" title="statement not covered" ></span>e.notifyPlugins("afterRender"),(0,s.Q)(i&amp;&amp;i.onComplete,[t],e)}</span>function <span class="fstat-no" title="function not covered" >Jt(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.chart,</span>i=<span class="cstat-no" title="statement not covered" >e.options.animation;<span class="cstat-no" title="statement not covered" ></span>(0,s.Q)(i&amp;&amp;i.onProgress,[t],e)}</span>function <span class="fstat-no" title="function not covered" >qt(</span>t){<span class="cstat-no" title="statement not covered" >return(0,s.M)()&amp;&amp;"string"===typeof t?t=document.getElementById(t):t&amp;&amp;t.length&amp;&amp;(t=t[0]),t&amp;&amp;t.canvas&amp;&amp;(t=t.canvas),t}</span>const Zt=<span class="cstat-no" title="statement not covered" >{},</span>te=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >qt(t);<span class="cstat-no" title="statement not covered" ></span>return Object.values(Zt).filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.canvas===e)</span>).pop()}</span>;</span>function <span class="fstat-no" title="function not covered" >ee(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >Object.keys(t);<span class="cstat-no" title="statement not covered" ></span>for(const n of s){const s=<span class="cstat-no" title="statement not covered" >+n;<span class="cstat-no" title="statement not covered" ></span>if(s&gt;=e){const o=<span class="cstat-no" title="statement not covered" >t[n];<span class="cstat-no" title="statement not covered" ></span>delete t[n],(i&gt;0||s&gt;e)&amp;&amp;(t[s+i]=o)}</span>}</span>}</span>class ie{static defaults=<span class="cstat-no" title="statement not covered" >s.d;</span>static instances=<span class="cstat-no" title="statement not covered" >Zt;</span>static overrides=<span class="cstat-no" title="statement not covered" >s.a3;</span>static registry=<span class="cstat-no" title="statement not covered" >Ct;</span>static version=<span class="cstat-no" title="statement not covered" >"4.5.1";</span>static getChart=<span class="cstat-no" title="statement not covered" >te;<span class="fstat-no" title="function not covered" ></span>st</span>atic register(...t){<span class="cstat-no" title="statement not covered" >Ct.add(...t),se()}<span class="fstat-no" title="function not covered" ></span>st</span>atic unregister(...t){<span class="cstat-no" title="statement not covered" >Ct.remove(...t),se()}<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t,e){const i=<span class="cstat-no" title="statement not covered" >this.config=new $t(e),</span>n=<span class="cstat-no" title="statement not covered" >qt(t),</span>a=<span class="cstat-no" title="statement not covered" >te(n);<span class="cstat-no" title="statement not covered" ></span>if(a)<span class="cstat-no" title="statement not covered" >throw new Error("Canvas is already in use. Chart with ID '"+a.id+"' must be destroyed before the canvas with ID '"+a.canvas.id+"' can be reused.");c</span></span>onst r=<span class="cstat-no" title="statement not covered" >i.createResolver(i.chartOptionScopes(),this.getContext());<span class="cstat-no" title="statement not covered" ></span>this.platform=new(i.platform||<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return!(0,s.M)()||"undefined"!==typeof OffscreenCanvas&amp;&amp;t instanceof OffscreenCanvas?et:pt}</span>(n)),this.platform.updateConfig(i);c</span>onst h=<span class="cstat-no" title="statement not covered" >this.platform.acquireContext(n,r.aspectRatio),</span>l=<span class="cstat-no" title="statement not covered" >h&amp;&amp;h.canvas,</span>c=<span class="cstat-no" title="statement not covered" >l&amp;&amp;l.height,</span>d=<span class="cstat-no" title="statement not covered" >l&amp;&amp;l.width;<span class="cstat-no" title="statement not covered" ></span>this.id=(0,s.ac)(),this.ctx=h,this.canvas=l,this.width=d,this.height=c,this._options=r,this._aspectRatio=this.aspectRatio,this._layers=[],this._metasets=[],this._stacks=void 0,this.boxes=[],this.currentDevicePixelRatio=void 0,this.chartArea=void 0,this._active=[],this._lastEvent=void 0,this._listeners={},this._responsiveListeners=void 0,this._sortedMetasets=[],this.scales={},this._plugins=new Tt,this.$proxies={},this._hiddenIndices={},this.attached=!1,this._animationsDisabled=void 0,this.$context=void 0,this._doResize=(0,s.ad)((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this.update(t))</span>,r.resizeDelay||0),this._dataChanges=[],Zt[this.id]=this,h&amp;&amp;l?(o.listen(this,"complete",Kt),o.listen(this,"progress",Jt),this._initialize(),this.attached&amp;&amp;this.update()):console.error("Failed to create chart: can't acquire context from the given item")}<span class="fstat-no" title="function not covered" ></span>ge</span>t aspectRatio(){const{options:{aspectRatio:t,maintainAspectRatio:e},width:i,height:n,_aspectRatio:o}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return(0,s.k)(t)?e&amp;&amp;o?o:n?i/n:null:t}<span class="fstat-no" title="function not covered" ></span>ge</span>t data(){<span class="cstat-no" title="statement not covered" >return this.config.data}<span class="fstat-no" title="function not covered" ></span>se</span>t data(t){<span class="cstat-no" title="statement not covered" >this.config.data=t}<span class="fstat-no" title="function not covered" ></span>ge</span>t options(){<span class="cstat-no" title="statement not covered" >return this._options}<span class="fstat-no" title="function not covered" ></span>se</span>t options(t){<span class="cstat-no" title="statement not covered" >this.config.options=t}<span class="fstat-no" title="function not covered" ></span>ge</span>t registry(){<span class="cstat-no" title="statement not covered" >return Ct}<span class="fstat-no" title="function not covered" ></span>_i</span>nitialize(){<span class="cstat-no" title="statement not covered" >return this.notifyPlugins("beforeInit"),this.options.responsive?this.resize():(0,s.ae)(this,this.options.devicePixelRatio),this.bindEvents(),this.notifyPlugins("afterInit"),this}<span class="fstat-no" title="function not covered" ></span>cl</span>ear(){<span class="cstat-no" title="statement not covered" >return(0,s.af)(this.canvas,this.ctx),this}<span class="fstat-no" title="function not covered" ></span>st</span>op(){<span class="cstat-no" title="statement not covered" >return o.stop(this),this}<span class="fstat-no" title="function not covered" ></span>re</span>size(t,e){<span class="cstat-no" title="statement not covered" >o.running(this)?this._resizeBeforeDraw={width:t,height:e}:this._resize(t,e)}<span class="fstat-no" title="function not covered" ></span>_r</span>esize(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options,</span>n=<span class="cstat-no" title="statement not covered" >this.canvas,</span>o=<span class="cstat-no" title="statement not covered" >i.maintainAspectRatio&amp;&amp;this.aspectRatio,</span>a=<span class="cstat-no" title="statement not covered" >this.platform.getMaximumSize(n,t,e,o),</span>r=<span class="cstat-no" title="statement not covered" >i.devicePixelRatio||this.platform.getDevicePixelRatio(),</span>h=<span class="cstat-no" title="statement not covered" >this.width?"resize":"attach";<span class="cstat-no" title="statement not covered" ></span>this.width=a.width,this.height=a.height,this._aspectRatio=this.aspectRatio,(0,s.ae)(this,r,!0)&amp;&amp;(this.notifyPlugins("resize",{size:a}),(0,s.Q)(i.onResize,[this,a],this),this.attached&amp;&amp;this._doResize(h)&amp;&amp;this.render())}<span class="fstat-no" title="function not covered" ></span>en</span>sureScalesHaveIDs(){const t=<span class="cstat-no" title="statement not covered" >this.options.scales||{};<span class="cstat-no" title="statement not covered" ></span>(0,s.F)(t,(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >t.id=e}</span>))}<span class="fstat-no" title="function not covered" ></span>bu</span>ildOrUpdateScales(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >t.scales,</span>i=<span class="cstat-no" title="statement not covered" >this.scales,</span>n=<span class="cstat-no" title="statement not covered" >Object.keys(i).reduce((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;(<span class="cstat-no" title="statement not covered" >t[e]=!1,t)</span>),{});</span>let o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;(o=o.concat(Object.keys(e).map((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >e[t],</span>s=<span class="cstat-no" title="statement not covered" >Lt(t,i),</span>n=<span class="cstat-no" title="statement not covered" >"r"===s,</span>o=<span class="cstat-no" title="statement not covered" >"x"===s;<span class="cstat-no" title="statement not covered" ></span>return{options:i,dposition:n?"chartArea":o?"bottom":"left",dtype:n?"radialLinear":o?"category":"linear"}}</span>)))),(0,s.F)(o,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const o=<span class="cstat-no" title="statement not covered" >e.options,</span>a=<span class="cstat-no" title="statement not covered" >o.id,</span>r=<span class="cstat-no" title="statement not covered" >Lt(a,o),</span>h=<span class="cstat-no" title="statement not covered" >(0,s.v)(o.type,e.dtype);<span class="cstat-no" title="statement not covered" ></span>void 0!==o.position&amp;&amp;Qt(o.position,r)===Qt(e.dposition)||(o.position=e.dposition),n[a]=!0;l</span>et l=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>if(a in i&amp;&amp;i[a].type===h)<span class="cstat-no" title="statement not covered" >l=i[a];e</span>lse{<span class="cstat-no" title="statement not covered" >l=new(Ct.getScale(h))({id:a,type:h,ctx:this.ctx,chart:this}),i[l.id]=l}<span class="cstat-no" title="statement not covered" ></span>l</span>.init(o,t)}</span>)),(0,s.F)(n,(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >t||delete i[e]}</span>)),(0,s.F)(i,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >Z.configure(this,t,t.options),Z.addBox(this,t)}</span>))}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateMetasets(){const t=<span class="cstat-no" title="statement not covered" >this._metasets,</span>e=<span class="cstat-no" title="statement not covered" >this.data.datasets.length,</span>i=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>if(t.sort((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t.index-e.index)</span>),i&gt;e){<span class="cstat-no" title="statement not covered" >for(let t=<span class="cstat-no" title="statement not covered" >e;</span>t&lt;i;++t)<span class="cstat-no" title="statement not covered" >this._destroyDatasetMeta(t);<span class="cstat-no" title="statement not covered" >t</span></span>.splice(e,i-e)}<span class="cstat-no" title="statement not covered" ></span>t</span>his._sortedMetasets=t.slice(0).sort(Gt("order","index"))}<span class="fstat-no" title="function not covered" ></span>_r</span>emoveUnreferencedMetasets(){const{_metasets:t,data:{datasets:e}}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>t.length&gt;e.length&amp;&amp;delete this._stacks,t.forEach((<span class="fstat-no" title="function not covered" >(t</span>,i)=&gt;{<span class="cstat-no" title="statement not covered" >0===e.filter((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e===t._dataset)</span>).length&amp;&amp;this._destroyDatasetMeta(i)}</span>))}<span class="fstat-no" title="function not covered" ></span>bu</span>ildOrUpdateControllers(){const t=<span class="cstat-no" title="statement not covered" >[],</span>e=<span class="cstat-no" title="statement not covered" >this.data.datasets;</span>let i,n;<span class="cstat-no" title="statement not covered" >for(this._removeUnreferencedMetasets(),i=0,n=e.length;i&lt;n;i++){const n=<span class="cstat-no" title="statement not covered" >e[i];</span>let o=<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(i);</span>const a=<span class="cstat-no" title="statement not covered" >n.type||this.config.type;<span class="cstat-no" title="statement not covered" ></span>if(o.type&amp;&amp;o.type!==a&amp;&amp;(this._destroyDatasetMeta(i),o=this.getDatasetMeta(i)),o.type=a,o.indexAxis=n.indexAxis||Rt(a,this.options),o.order=n.order||0,o.index=i,o.label=""+n.label,o.visible=this.isDatasetVisible(i),o.controller)<span class="cstat-no" title="statement not covered" >o.controller.updateIndex(i),o.controller.linkScales();e</span>lse{const e=<span class="cstat-no" title="statement not covered" >Ct.getController(a),</span>{datasetElementType:n,dataElementType:r}=<span class="cstat-no" title="statement not covered" >s.d.datasets[a];<span class="cstat-no" title="statement not covered" ></span>Object.assign(e,{dataElementType:Ct.getElement(r),datasetElementType:n&amp;&amp;Ct.getElement(n)}),o.controller=new e(this,i),t.push(o.controller)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn this._updateMetasets(),t}<span class="fstat-no" title="function not covered" ></span>_r</span>esetElements(){<span class="cstat-no" title="statement not covered" >(0,s.F)(this.data.datasets,(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(e).controller.reset()}</span>),this)}<span class="fstat-no" title="function not covered" ></span>re</span>set(){<span class="cstat-no" title="statement not covered" >this._resetElements(),this.notifyPlugins("reset")}<span class="fstat-no" title="function not covered" ></span>up</span>date(t){const e=<span class="cstat-no" title="statement not covered" >this.config;<span class="cstat-no" title="statement not covered" ></span>e.update();c</span>onst i=<span class="cstat-no" title="statement not covered" >this._options=e.createResolver(e.chartOptionScopes(),this.getContext()),</span>n=<span class="cstat-no" title="statement not covered" >this._animationsDisabled=!i.animation;<span class="cstat-no" title="statement not covered" ></span>if(this._updateScales(),this._checkEventBindings(),this._updateHiddenIndices(),this._plugins.invalidate(),!1===this.notifyPlugins("beforeUpdate",{mode:t,cancelable:!0}))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >this.buildOrUpdateControllers();<span class="cstat-no" title="statement not covered" ></span>this.notifyPlugins("beforeElementsUpdate");l</span>et a=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >0,</span>l=<span class="cstat-no" title="statement not covered" >this.data.datasets.length;</span>s&lt;l;s++){const{controller:t}=<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(s),</span>e=<span class="cstat-no" title="statement not covered" >!n&amp;&amp;-1===o.indexOf(t);<span class="cstat-no" title="statement not covered" ></span>t.buildOrUpdateElements(e),a=Math.max(+t.getMaxOverflow(),a)}<span class="cstat-no" title="statement not covered" ></span>a</span>=this._minPadding=i.layout.autoPadding?a:0,this._updateLayout(a),n||(0,s.F)(o,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.reset()}</span>)),this._updateDatasets(t),this.notifyPlugins("afterUpdate",{mode:t}),this._layers.sort(Gt("z","_idx"));c</span>onst{_active:r,_lastEvent:h}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>h?this._eventHandler(h,!0):r.length&amp;&amp;this._updateHoverStyles(r,r,!0),this.render()}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateScales(){<span class="cstat-no" title="statement not covered" >(0,s.F)(this.scales,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >Z.removeBox(this,t)}</span>)),this.ensureScalesHaveIDs(),this.buildOrUpdateScales()}<span class="fstat-no" title="function not covered" ></span>_c</span>heckEventBindings(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >new Set(Object.keys(this._listeners)),</span>i=<span class="cstat-no" title="statement not covered" >new Set(t.events);<span class="cstat-no" title="statement not covered" ></span>(0,s.ag)(e,i)&amp;&amp;!!this._responsiveListeners===t.responsive||(this.unbindEvents(),this.bindEvents())}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateHiddenIndices(){const{_hiddenIndices:t}=<span class="cstat-no" title="statement not covered" >this,</span>e=<span class="cstat-no" title="statement not covered" >this._getUniformDataChanges()||[];<span class="cstat-no" title="statement not covered" ></span>for(const{method:i,start:s,count:n}of e){<span class="cstat-no" title="statement not covered" >ee(t,s,"_removeElements"===i?-n:n)}</span>}<span class="fstat-no" title="function not covered" ></span>_g</span>etUniformDataChanges(){const t=<span class="cstat-no" title="statement not covered" >this._dataChanges;<span class="cstat-no" title="statement not covered" ></span>if(!t||!t.length)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his._dataChanges=[];c</span>onst e=<span class="cstat-no" title="statement not covered" >this.data.datasets.length,</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >new Set(t.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t[0]===e)</span>).map((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e+","+t.splice(1).join(","))</span>)),</span></span>n=<span class="cstat-no" title="statement not covered" >i(0);<span class="cstat-no" title="statement not covered" ></span>for(let o=<span class="cstat-no" title="statement not covered" >1;</span>o&lt;e;o++)<span class="cstat-no" title="statement not covered" >if(!(0,s.ag)(n,i(o)))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn Array.from(n).map((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.split(","))</span>).map((<span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >{method:t[1],start:+t[2],count:+t[3]})</span>))}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateLayout(t){<span class="cstat-no" title="statement not covered" >if(!1===this.notifyPlugins("beforeLayout",{cancelable:!0}))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >Z</span></span>.update(this,this.width,this.height,t);c</span>onst e=<span class="cstat-no" title="statement not covered" >this.chartArea,</span>i=<span class="cstat-no" title="statement not covered" >e.width&lt;=0||e.height&lt;=0;<span class="cstat-no" title="statement not covered" ></span>this._layers=[],(0,s.F)(this.boxes,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >i&amp;&amp;"chartArea"===t.position||(t.configure&amp;&amp;t.configure(),this._layers.push(...t._layers()))}</span>),this),this._layers.forEach((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >t._idx=e}</span>)),this.notifyPlugins("afterLayout")}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateDatasets(t){<span class="cstat-no" title="statement not covered" >if(!1!==this.notifyPlugins("beforeDatasetsUpdate",{mode:t,cancelable:!0})){<span class="cstat-no" title="statement not covered" >for(let t=<span class="cstat-no" title="statement not covered" >0,</span>e=<span class="cstat-no" title="statement not covered" >this.data.datasets.length;</span>t&lt;e;++t)<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(t).controller.configure();<span class="cstat-no" title="statement not covered" >f</span></span>or(let e=<span class="cstat-no" title="statement not covered" >0,</span>i=<span class="cstat-no" title="statement not covered" >this.data.datasets.length;</span>e&lt;i;++e)<span class="cstat-no" title="statement not covered" >this._updateDataset(e,(0,s.a7)(t)?t({datasetIndex:e}):t);<span class="cstat-no" title="statement not covered" >t</span></span>his.notifyPlugins("afterDatasetsUpdate",{mode:t})}</span>}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateDataset(t,e){const i=<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(t),</span>s=<span class="cstat-no" title="statement not covered" >{meta:i,index:t,mode:e,cancelable:!0};<span class="cstat-no" title="statement not covered" ></span>!1!==this.notifyPlugins("beforeDatasetUpdate",s)&amp;&amp;(i.controller._update(e),s.cancelable=!1,this.notifyPlugins("afterDatasetUpdate",s))}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >!1!==this.notifyPlugins("beforeRender",{cancelable:!0})&amp;&amp;(o.has(this)?this.attached&amp;&amp;!o.running(this)&amp;&amp;o.start(this):(this.draw(),Kt({chart:this})))}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(){let t;<span class="cstat-no" title="statement not covered" >if(this._resizeBeforeDraw){const{width:t,height:e}=<span class="cstat-no" title="statement not covered" >this._resizeBeforeDraw;<span class="cstat-no" title="statement not covered" ></span>this._resizeBeforeDraw=null,this._resize(t,e)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.clear(),this.width&lt;=0||this.height&lt;=0)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(!1===this.notifyPlugins("beforeDraw",{cancelable:!0}))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this._layers;<span class="cstat-no" title="statement not covered" ></span>for(t=0;t&lt;e.length&amp;&amp;e[t].z&lt;=0;++t)<span class="cstat-no" title="statement not covered" >e[t].draw(this.chartArea);<span class="cstat-no" title="statement not covered" >f</span></span>or(this._drawDatasets();t&lt;e.length;++t)<span class="cstat-no" title="statement not covered" >e[t].draw(this.chartArea);<span class="cstat-no" title="statement not covered" >t</span></span>his.notifyPlugins("afterDraw")}<span class="fstat-no" title="function not covered" ></span>_g</span>etSortedDatasetMetas(t){const e=<span class="cstat-no" title="statement not covered" >this._sortedMetasets,</span>i=<span class="cstat-no" title="statement not covered" >[];</span>let s,n;<span class="cstat-no" title="statement not covered" >for(s=0,n=e.length;s&lt;n;++s){const n=<span class="cstat-no" title="statement not covered" >e[s];<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;!n.visible||i.push(n)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}<span class="fstat-no" title="function not covered" ></span>ge</span>tSortedVisibleDatasetMetas(){<span class="cstat-no" title="statement not covered" >return this._getSortedDatasetMetas(!0)}<span class="fstat-no" title="function not covered" ></span>_d</span>rawDatasets(){<span class="cstat-no" title="statement not covered" >if(!1===this.notifyPlugins("beforeDatasetsDraw",{cancelable:!0}))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this.getSortedVisibleDatasetMetas();<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >t.length-1;</span>e&gt;=0;--e)<span class="cstat-no" title="statement not covered" >this._drawDataset(t[e]);<span class="cstat-no" title="statement not covered" >t</span></span>his.notifyPlugins("afterDatasetsDraw")}<span class="fstat-no" title="function not covered" ></span>_d</span>rawDataset(t){const e=<span class="cstat-no" title="statement not covered" >this.ctx,</span>i=<span class="cstat-no" title="statement not covered" >{meta:t,index:t.index,cancelable:!0},</span>n=<span class="cstat-no" title="statement not covered" >(0,s.ah)(this,t);<span class="cstat-no" title="statement not covered" ></span>!1!==this.notifyPlugins("beforeDatasetDraw",i)&amp;&amp;(n&amp;&amp;(0,s.Y)(e,n),t.controller.draw(),n&amp;&amp;(0,s.$)(e),i.cancelable=!1,this.notifyPlugins("afterDatasetDraw",i))}<span class="fstat-no" title="function not covered" ></span>is</span>PointInArea(t){<span class="cstat-no" title="statement not covered" >return(0,s.C)(t,this.chartArea,this._minPadding)}<span class="fstat-no" title="function not covered" ></span>ge</span>tElementsAtEventForMode(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >V.modes[e];<span class="cstat-no" title="statement not covered" ></span>return"function"===typeof n?n(this,t,i,s):[]}<span class="fstat-no" title="function not covered" ></span>ge</span>tDatasetMeta(t){const e=<span class="cstat-no" title="statement not covered" >this.data.datasets[t],</span>i=<span class="cstat-no" title="statement not covered" >this._metasets;</span>let s=<span class="cstat-no" title="statement not covered" >i.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t&amp;&amp;t._dataset===e)</span>).pop();<span class="cstat-no" title="statement not covered" ></span>return s||(s={type:null,data:[],dataset:null,controller:null,hidden:null,xAxisID:null,yAxisID:null,order:e&amp;&amp;e.order||0,index:t,_dataset:e,_parsed:[],_sorted:!1},i.push(s)),s}<span class="fstat-no" title="function not covered" ></span>ge</span>tContext(){<span class="cstat-no" title="statement not covered" >return this.$context||(this.$context=(0,s.j)(null,{chart:this,type:"chart"}))}<span class="fstat-no" title="function not covered" ></span>ge</span>tVisibleDatasetCount(){<span class="cstat-no" title="statement not covered" >return this.getSortedVisibleDatasetMetas().length}<span class="fstat-no" title="function not covered" ></span>is</span>DatasetVisible(t){const e=<span class="cstat-no" title="statement not covered" >this.data.datasets[t];<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(t);<span class="cstat-no" title="statement not covered" ></span>return"boolean"===typeof i.hidden?!i.hidden:!e.hidden}<span class="fstat-no" title="function not covered" ></span>se</span>tDatasetVisibility(t,e){<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(t).hidden=!e}<span class="fstat-no" title="function not covered" ></span>to</span>ggleDataVisibility(t){<span class="cstat-no" title="statement not covered" >this._hiddenIndices[t]=!this._hiddenIndices[t]}<span class="fstat-no" title="function not covered" ></span>ge</span>tDataVisibility(t){<span class="cstat-no" title="statement not covered" >return!this._hiddenIndices[t]}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateVisibility(t,e,i){const n=<span class="cstat-no" title="statement not covered" >i?"show":"hide",</span>o=<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(t),</span>a=<span class="cstat-no" title="statement not covered" >o.controller._resolveAnimations(void 0,n);<span class="cstat-no" title="statement not covered" ></span>(0,s.h)(e)?(o.data[e].hidden=!i,this.update()):(this.setDatasetVisibility(t,i),a.update(o,{visible:i}),this.update((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.datasetIndex===t?n:void 0)</span>))}<span class="fstat-no" title="function not covered" ></span>hi</span>de(t,e){<span class="cstat-no" title="statement not covered" >this._updateVisibility(t,e,!1)}<span class="fstat-no" title="function not covered" ></span>sh</span>ow(t,e){<span class="cstat-no" title="statement not covered" >this._updateVisibility(t,e,!0)}<span class="fstat-no" title="function not covered" ></span>_d</span>estroyDatasetMeta(t){const e=<span class="cstat-no" title="statement not covered" >this._metasets[t];<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;e.controller&amp;&amp;e.controller._destroy(),delete this._metasets[t]}<span class="fstat-no" title="function not covered" ></span>_s</span>top(){let t,e;<span class="cstat-no" title="statement not covered" >for(this.stop(),o.remove(this),t=0,e=this.data.datasets.length;t&lt;e;++t)<span class="cstat-no" title="statement not covered" >this._destroyDatasetMeta(t)}<span class="fstat-no" title="function not covered" ></span></span>de</span>stroy(){<span class="cstat-no" title="statement not covered" >this.notifyPlugins("beforeDestroy");c</span>onst{canvas:t,ctx:e}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>this._stop(),this.config.clearCache(),t&amp;&amp;(this.unbindEvents(),(0,s.af)(t,e),this.platform.releaseContext(e),this.canvas=null,this.ctx=null),delete Zt[this.id],this.notifyPlugins("afterDestroy")}<span class="fstat-no" title="function not covered" ></span>to</span>Base64Image(...t){<span class="cstat-no" title="statement not covered" >return this.canvas.toDataURL(...t)}<span class="fstat-no" title="function not covered" ></span>bi</span>ndEvents(){<span class="cstat-no" title="statement not covered" >this.bindUserEvents(),this.options.responsive?this.bindResponsiveEvents():this.attached=!0}<span class="fstat-no" title="function not covered" ></span>bi</span>ndUserEvents(){const t=<span class="cstat-no" title="statement not covered" >this._listeners,</span>e=<span class="cstat-no" title="statement not covered" >this.platform,</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(i</span>,s)=&gt;{<span class="cstat-no" title="statement not covered" >e.addEventListener(this,i,s),t[i]=s}</span>,</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,i)=&gt;{<span class="cstat-no" title="statement not covered" >t.offsetX=e,t.offsetY=i,this._eventHandler(t)}</span>;<span class="cstat-no" title="statement not covered" ></span>(0,s.F)(this.options.events,(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >i(t,n))</span>)}<span class="fstat-no" title="function not covered" ></span>bi</span>ndResponsiveEvents(){<span class="cstat-no" title="statement not covered" >this._responsiveListeners||(this._responsiveListeners={});c</span>onst t=<span class="cstat-no" title="statement not covered" >this._responsiveListeners,</span>e=<span class="cstat-no" title="statement not covered" >this.platform,</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(i</span>,s)=&gt;{<span class="cstat-no" title="statement not covered" >e.addEventListener(this,i,s),t[i]=s}</span>,</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(i</span>,s)=&gt;{<span class="cstat-no" title="statement not covered" >t[i]&amp;&amp;(e.removeEventListener(this,i,s),delete t[i])}</span>,</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >this.canvas&amp;&amp;this.resize(t,e)}</span>;</span>let o;const a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >s("attach",a),this.attached=!0,this.resize(),i("resize",n),i("detach",o)}</span>;<span class="cstat-no" title="statement not covered" ></span>o=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.attached=!1,s("resize",n),this._stop(),this._resize(0,0),i("attach",a)}</span>,e.isAttached(this.canvas)?a():o()}<span class="fstat-no" title="function not covered" ></span>un</span>bindEvents(){<span class="cstat-no" title="statement not covered" >(0,s.F)(this._listeners,(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >this.platform.removeEventListener(this,e,t)}</span>)),this._listeners={},(0,s.F)(this._responsiveListeners,(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >this.platform.removeEventListener(this,e,t)}</span>)),this._responsiveListeners=void 0}<span class="fstat-no" title="function not covered" ></span>up</span>dateHoverStyle(t,e,i){const s=<span class="cstat-no" title="statement not covered" >i?"set":"remove";</span>let n,o,a,r;<span class="cstat-no" title="statement not covered" >for("dataset"===e&amp;&amp;(n=this.getDatasetMeta(t[0].datasetIndex),n.controller["_"+s+"DatasetHoverStyle"]()),a=0,r=t.length;a&lt;r;++a){<span class="cstat-no" title="statement not covered" >o=t[a];c</span>onst e=<span class="cstat-no" title="statement not covered" >o&amp;&amp;this.getDatasetMeta(o.datasetIndex).controller;<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;e[s+"HoverStyle"](o.element,o.datasetIndex,o.index)}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>tActiveElements(){<span class="cstat-no" title="statement not covered" >return this._active||[]}<span class="fstat-no" title="function not covered" ></span>se</span>tActiveElements(t){const e=<span class="cstat-no" title="statement not covered" >this._active||[],</span>i=<span class="cstat-no" title="statement not covered" >t.map((<span class="fstat-no" title="function not covered" >({</span>datasetIndex:t,index:e})=&gt;{const i=<span class="cstat-no" title="statement not covered" >this.getDatasetMeta(t);<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >throw new Error("No dataset found at index "+t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{datasetIndex:t,element:i.data[e],index:e}}</span>));<span class="cstat-no" title="statement not covered" ></span>!(0,s.ai)(i,e)&amp;&amp;(this._active=i,this._lastEvent=null,this._updateHoverStyles(i,e))}<span class="fstat-no" title="function not covered" ></span>no</span>tifyPlugins(t,e,i){<span class="cstat-no" title="statement not covered" >return this._plugins.notify(this,t,e,i)}<span class="fstat-no" title="function not covered" ></span>is</span>PluginEnabled(t){<span class="cstat-no" title="statement not covered" >return 1===this._plugins._cache.filter((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.plugin.id===t)</span>).length}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateHoverStyles(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.options.hover,</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!e.some((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >t.datasetIndex===e.datasetIndex&amp;&amp;t.index===e.index)</span>))</span>),</span></span>o=<span class="cstat-no" title="statement not covered" >n(e,t),</span>a=<span class="cstat-no" title="statement not covered" >i?t:n(t,e);<span class="cstat-no" title="statement not covered" ></span>o.length&amp;&amp;this.updateHoverStyle(o,s.mode,!1),a.length&amp;&amp;s.mode&amp;&amp;this.updateHoverStyle(a,s.mode,!0)}<span class="fstat-no" title="function not covered" ></span>_e</span>ventHandler(t,e){const i=<span class="cstat-no" title="statement not covered" >{event:t,replay:e,cancelable:!0,inChartArea:this.isPointInArea(t)},</span>s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >(e.options.events||this.options.events).includes(t.native.type);<span class="cstat-no" title="statement not covered" ></span></span>if(!1===this.notifyPlugins("beforeEvent",i,s))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >this._handleEvent(t,e,i.inChartArea);<span class="cstat-no" title="statement not covered" ></span>return i.cancelable=!1,this.notifyPlugins("afterEvent",i,s),(n||i.changed)&amp;&amp;this.render(),this}<span class="fstat-no" title="function not covered" ></span>_h</span>andleEvent(t,e,i){const{_active:n=<span class="branch-0 cbranch-no" title="branch not covered" >[],</span>options:o}=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" >e,</span>r=<span class="cstat-no" title="statement not covered" >this._getActiveElements(t,n,i,a),</span>h=<span class="cstat-no" title="statement not covered" >(0,s.aj)(t),</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){<span class="cstat-no" title="statement not covered" >return i&amp;&amp;"mouseout"!==t.type?s?e:t:null}</span>(t,this._lastEvent,i,h);<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;(this._lastEvent=null,(0,s.Q)(o.onHover,[t,r,this],this),h&amp;&amp;(0,s.Q)(o.onClick,[t,r,this],this));c</span>onst c=<span class="cstat-no" title="statement not covered" >!(0,s.ai)(r,n);<span class="cstat-no" title="statement not covered" ></span>return(c||e)&amp;&amp;(this._active=r,this._updateHoverStyles(r,n,e)),this._lastEvent=l,c}<span class="fstat-no" title="function not covered" ></span>_g</span>etActiveElements(t,e,i,s){<span class="cstat-no" title="statement not covered" >if("mouseout"===t.type)<span class="cstat-no" title="statement not covered" >return[];<span class="cstat-no" title="statement not covered" >i</span></span>f(!i)<span class="cstat-no" title="statement not covered" >return e;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >this.options.hover;<span class="cstat-no" title="statement not covered" ></span>return this.getElementsAtEventForMode(t,n.mode,n,s)}</span>}function <span class="fstat-no" title="function not covered" >se(</span>){<span class="cstat-no" title="statement not covered" >return(0,s.F)(ie.instances,(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t._plugins.invalidate())</span>)}</span>function <span class="fstat-no" title="function not covered" >ne(</span>t,e,i,n){const o=(<span class="cstat-no" title="statement not covered" >a=t.options.borderRadius,(0,s.am)(a,["outerStart","outerEnd","innerStart","innerEnd"]))</span>;var a;const r=<span class="cstat-no" title="statement not covered" >(i-e)/2,</span>h=<span class="cstat-no" title="statement not covered" >Math.min(r,n*e/2),</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >(i-Math.min(r,t))*n/2;<span class="cstat-no" title="statement not covered" ></span>return(0,s.S)(t,0,Math.min(r,e))}</span>;<span class="cstat-no" title="statement not covered" ></span>return{outerStart:l(o.outerStart),outerEnd:l(o.outerEnd),innerStart:(0,s.S)(o.innerStart,0,h),innerEnd:(0,s.S)(o.innerEnd,0,h)}}</span>function <span class="fstat-no" title="function not covered" >oe(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return{x:i+t*Math.cos(e),y:s+t*Math.sin(e)}}</span>function <span class="fstat-no" title="function not covered" >ae(</span>t,e,i,n,o,a){const{x:r,y:h,startAngle:l,pixelMargin:c,innerRadius:d}=<span class="cstat-no" title="statement not covered" >e,</span>u=<span class="cstat-no" title="statement not covered" >Math.max(e.outerRadius+n+i-c,0),</span>g=<span class="cstat-no" title="statement not covered" >d&gt;0?d+n+i+c:0;</span>let f=<span class="cstat-no" title="statement not covered" >0;</span>const p=<span class="cstat-no" title="statement not covered" >o-l;<span class="cstat-no" title="statement not covered" ></span>if(n){const t=<span class="cstat-no" title="statement not covered" >((d&gt;0?d-n:0)+(u&gt;0?u-n:0))/2;<span class="cstat-no" title="statement not covered" ></span>f=(p-(0!==t?p*t/(t+n):p))/2}</span>c</span>onst x=<span class="cstat-no" title="statement not covered" >(p-Math.max(.001,p*u-i/s.P)/u)/2,</span>m=<span class="cstat-no" title="statement not covered" >l+x+f,</span>b=<span class="cstat-no" title="statement not covered" >o-x-f,</span>{outerStart:_,outerEnd:v,innerStart:y,innerEnd:M}=<span class="cstat-no" title="statement not covered" >ne(e,g,u,b-m),</span>w=<span class="cstat-no" title="statement not covered" >u-_,</span>k=<span class="cstat-no" title="statement not covered" >u-v,</span>S=<span class="cstat-no" title="statement not covered" >m+_/w,</span>D=<span class="cstat-no" title="statement not covered" >b-v/k,</span>P=<span class="cstat-no" title="statement not covered" >g+y,</span>A=<span class="cstat-no" title="statement not covered" >g+M,</span>C=<span class="cstat-no" title="statement not covered" >m+y/P,</span>T=<span class="cstat-no" title="statement not covered" >b-M/A;<span class="cstat-no" title="statement not covered" ></span>if(t.beginPath(),a){const e=<span class="cstat-no" title="statement not covered" >(S+D)/2;<span class="cstat-no" title="statement not covered" ></span>if(t.arc(r,h,u,S,e),t.arc(r,h,u,e,D),v&gt;0){const e=<span class="cstat-no" title="statement not covered" >oe(k,D,r,h);<span class="cstat-no" title="statement not covered" ></span>t.arc(e.x,e.y,v,D,b+s.H)}</span>c</span>onst i=<span class="cstat-no" title="statement not covered" >oe(A,b,r,h);<span class="cstat-no" title="statement not covered" ></span>if(t.lineTo(i.x,i.y),M&gt;0){const e=<span class="cstat-no" title="statement not covered" >oe(A,T,r,h);<span class="cstat-no" title="statement not covered" ></span>t.arc(e.x,e.y,M,b+s.H,T+Math.PI)}</span>c</span>onst n=<span class="cstat-no" title="statement not covered" >(b-M/g+(m+y/g))/2;<span class="cstat-no" title="statement not covered" ></span>if(t.arc(r,h,g,b-M/g,n,!0),t.arc(r,h,g,n,m+y/g,!0),y&gt;0){const e=<span class="cstat-no" title="statement not covered" >oe(P,C,r,h);<span class="cstat-no" title="statement not covered" ></span>t.arc(e.x,e.y,y,C+Math.PI,m-s.H)}</span>c</span>onst o=<span class="cstat-no" title="statement not covered" >oe(w,m,r,h);<span class="cstat-no" title="statement not covered" ></span>if(t.lineTo(o.x,o.y),_&gt;0){const e=<span class="cstat-no" title="statement not covered" >oe(w,S,r,h);<span class="cstat-no" title="statement not covered" ></span>t.arc(e.x,e.y,_,m-s.H,S)}</span>}</span>else{<span class="cstat-no" title="statement not covered" >t.moveTo(r,h);c</span>onst e=<span class="cstat-no" title="statement not covered" >Math.cos(S)*u+r,</span>i=<span class="cstat-no" title="statement not covered" >Math.sin(S)*u+h;<span class="cstat-no" title="statement not covered" ></span>t.lineTo(e,i);c</span>onst s=<span class="cstat-no" title="statement not covered" >Math.cos(D)*u+r,</span>n=<span class="cstat-no" title="statement not covered" >Math.sin(D)*u+h;<span class="cstat-no" title="statement not covered" ></span>t.lineTo(s,n)}<span class="cstat-no" title="statement not covered" ></span>t</span>.closePath()}</span>function <span class="fstat-no" title="function not covered" >re(</span>t,e,i,n,o){const{fullCircles:a,startAngle:r,circumference:h,options:l}=<span class="cstat-no" title="statement not covered" >e,</span>{borderWidth:c,borderJoinStyle:d,borderDash:u,borderDashOffset:g,borderRadius:f}=<span class="cstat-no" title="statement not covered" >l,</span>p=<span class="cstat-no" title="statement not covered" >"inner"===l.borderAlign;<span class="cstat-no" title="statement not covered" ></span>if(!c)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>.setLineDash(u||[]),t.lineDashOffset=g,p?(t.lineWidth=2*c,t.lineJoin=d||"round"):(t.lineWidth=c,t.lineJoin=d||"bevel");l</span>et x=<span class="cstat-no" title="statement not covered" >e.endAngle;<span class="cstat-no" title="statement not covered" ></span>if(a){<span class="cstat-no" title="statement not covered" >ae(t,e,i,n,x,o);<span class="cstat-no" title="statement not covered" >f</span>or(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;a;++e)<span class="cstat-no" title="statement not covered" >t.stroke();<span class="cstat-no" title="statement not covered" >i</span></span>sNaN(h)||(x=r+(h%s.T||s.T))}<span class="cstat-no" title="statement not covered" ></span>p</span>&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const{startAngle:n,pixelMargin:o,x:a,y:r,outerRadius:h,innerRadius:l}=<span class="cstat-no" title="statement not covered" >e;</span>let c=<span class="cstat-no" title="statement not covered" >o/h;<span class="cstat-no" title="statement not covered" ></span>t.beginPath(),t.arc(a,r,h,n-c,i+c),l&gt;o?(c=o/l,t.arc(a,r,l,i+c,n-c,!0)):t.arc(a,r,o,i+s.H,n-s.H),t.closePath(),t.clip()}</span>(t,e,x),l.selfJoin&amp;&amp;x-r&gt;=s.P&amp;&amp;0===f&amp;&amp;"miter"!==d&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const{startAngle:n,x:o,y:a,outerRadius:r,innerRadius:h,options:l}=<span class="cstat-no" title="statement not covered" >e,</span>{borderWidth:c,borderJoinStyle:d}=<span class="cstat-no" title="statement not covered" >l,</span>u=<span class="cstat-no" title="statement not covered" >Math.min(c/r,(0,s.al)(n-i));<span class="cstat-no" title="statement not covered" ></span>if(t.beginPath(),t.arc(o,a,r-c/2,n+u/2,i-u/2),h&gt;0){const e=<span class="cstat-no" title="statement not covered" >Math.min(c/h,(0,s.al)(n-i));<span class="cstat-no" title="statement not covered" ></span>t.arc(o,a,h+c/2,i-e/2,n+e/2,!0)}</span>else{const e=<span class="cstat-no" title="statement not covered" >Math.min(c/2,r*(0,s.al)(n-i));<span class="cstat-no" title="statement not covered" ></span>if("round"===d)<span class="cstat-no" title="statement not covered" >t.arc(o,a,e,i-s.P/2,n+s.P/2,!0);e</span>lse <span class="cstat-no" title="statement not covered" >if("bevel"===d){const r=<span class="cstat-no" title="statement not covered" >2*e*e,</span>h=<span class="cstat-no" title="statement not covered" >-r*Math.cos(i+s.P/2)+o,</span>l=<span class="cstat-no" title="statement not covered" >-r*Math.sin(i+s.P/2)+a,</span>c=<span class="cstat-no" title="statement not covered" >r*Math.cos(n+s.P/2)+o,</span>d=<span class="cstat-no" title="statement not covered" >r*Math.sin(n+s.P/2)+a;<span class="cstat-no" title="statement not covered" ></span>t.lineTo(h,l),t.lineTo(c,d)}</span>}<span class="cstat-no" title="statement not covered" ></span></span>t</span>.closePath(),t.moveTo(0,0),t.rect(0,0,t.canvas.width,t.canvas.height),t.clip("evenodd")}</span>(t,e,x),a||(ae(t,e,i,n,x,o),t.stroke())}</span>class he extends xt{static id=<span class="cstat-no" title="statement not covered" >"arc";</span>static defaults=<span class="cstat-no" title="statement not covered" >{borderAlign:"center",borderColor:"#fff",borderDash:[],borderDashOffset:0,borderJoinStyle:void 0,borderRadius:0,borderWidth:2,offset:0,spacing:0,angle:void 0,circular:!0,selfJoin:!1};</span>static defaultRoutes=<span class="cstat-no" title="statement not covered" >{backgroundColor:"backgroundColor"};</span>static descriptors=<span class="cstat-no" title="statement not covered" >{_scriptable:!0,_indexable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"borderDash"!==t}</span>;</span>circumference;endAngle;fullCircles;innerRadius;outerRadius;pixelMargin;startAngle;<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.options=void 0,this.circumference=void 0,this.startAngle=void 0,this.endAngle=void 0,this.innerRadius=void 0,this.outerRadius=void 0,this.pixelMargin=0,this.fullCircles=0,t&amp;&amp;Object.assign(this,t)}<span class="fstat-no" title="function not covered" ></span>in</span>Range(t,e,i){const n=<span class="cstat-no" title="statement not covered" >this.getProps(["x","y"],i),</span>{angle:o,distance:a}=<span class="cstat-no" title="statement not covered" >(0,s.D)(n,{x:t,y:e}),</span>{startAngle:r,endAngle:h,innerRadius:l,outerRadius:c,circumference:d}=<span class="cstat-no" title="statement not covered" >this.getProps(["startAngle","endAngle","innerRadius","outerRadius","circumference"],i),</span>u=<span class="cstat-no" title="statement not covered" >(this.options.spacing+this.options.borderWidth)/2,</span>g=<span class="cstat-no" title="statement not covered" >(0,s.v)(d,h-r),</span>f=<span class="cstat-no" title="statement not covered" >(0,s.p)(o,r,h)&amp;&amp;r!==h,</span>p=<span class="cstat-no" title="statement not covered" >g&gt;=s.T||f,</span>x=<span class="cstat-no" title="statement not covered" >(0,s.ak)(a,l+u,c+u);<span class="cstat-no" title="statement not covered" ></span>return p&amp;&amp;x}<span class="fstat-no" title="function not covered" ></span>ge</span>tCenterPoint(t){const{x:e,y:i,startAngle:s,endAngle:n,innerRadius:o,outerRadius:a}=<span class="cstat-no" title="statement not covered" >this.getProps(["x","y","startAngle","endAngle","innerRadius","outerRadius"],t),</span>{offset:r,spacing:h}=<span class="cstat-no" title="statement not covered" >this.options,</span>l=<span class="cstat-no" title="statement not covered" >(s+n)/2,</span>c=<span class="cstat-no" title="statement not covered" >(o+a+h+r)/2;<span class="cstat-no" title="statement not covered" ></span>return{x:e+Math.cos(l)*c,y:i+Math.sin(l)*c}}<span class="fstat-no" title="function not covered" ></span>to</span>oltipPosition(t){<span class="cstat-no" title="statement not covered" >return this.getCenterPoint(t)}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(t){const{options:e,circumference:i}=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >(e.offset||0)/4,</span>o=<span class="cstat-no" title="statement not covered" >(e.spacing||0)/2,</span>a=<span class="cstat-no" title="statement not covered" >e.circular;<span class="cstat-no" title="statement not covered" ></span>if(this.pixelMargin="inner"===e.borderAlign?.33:0,this.fullCircles=i&gt;s.T?Math.floor(i/s.T):0,0===i||this.innerRadius&lt;0||this.outerRadius&lt;0)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>.save();c</span>onst r=<span class="cstat-no" title="statement not covered" >(this.startAngle+this.endAngle)/2;<span class="cstat-no" title="statement not covered" ></span>t.translate(Math.cos(r)*n,Math.sin(r)*n);c</span>onst h=<span class="cstat-no" title="statement not covered" >n*(1-Math.sin(Math.min(s.P,i||0)));<span class="cstat-no" title="statement not covered" ></span>t.fillStyle=e.backgroundColor,t.strokeStyle=e.borderColor,<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,n,o){const{fullCircles:a,startAngle:r,circumference:h}=<span class="cstat-no" title="statement not covered" >e;</span>let l=<span class="cstat-no" title="statement not covered" >e.endAngle;<span class="cstat-no" title="statement not covered" ></span>if(a){<span class="cstat-no" title="statement not covered" >ae(t,e,i,n,l,o);<span class="cstat-no" title="statement not covered" >f</span>or(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;a;++e)<span class="cstat-no" title="statement not covered" >t.fill();<span class="cstat-no" title="statement not covered" >i</span></span>sNaN(h)||(l=r+(h%s.T||s.T))}<span class="cstat-no" title="statement not covered" ></span>a</span>e(t,e,i,n,l,o),t.fill()}</span>(t,this,h,o,a),re(t,this,h,o,a),t.restore()}</span>}function <span class="fstat-no" title="function not covered" >le(</span>t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >e)</span>{<span class="cstat-no" title="statement not covered" >t.lineCap=(0,s.v)(i.borderCapStyle,e.borderCapStyle),t.setLineDash((0,s.v)(i.borderDash,e.borderDash)),t.lineDashOffset=(0,s.v)(i.borderDashOffset,e.borderDashOffset),t.lineJoin=(0,s.v)(i.borderJoinStyle,e.borderJoinStyle),t.lineWidth=(0,s.v)(i.borderWidth,e.borderWidth),t.strokeStyle=(0,s.v)(i.borderColor,e.borderColor)}</span>function <span class="fstat-no" title="function not covered" >ce(</span>t,e,i){<span class="cstat-no" title="statement not covered" >t.lineTo(i.x,i.y)}</span>function <span class="fstat-no" title="function not covered" >de(</span>t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const s=<span class="cstat-no" title="statement not covered" >t.length,</span>{start:n=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>end:o=<span class="branch-0 cbranch-no" title="branch not covered" >s-1}</span>=<span class="cstat-no" title="statement not covered" >i,</span>{start:a,end:r}=<span class="cstat-no" title="statement not covered" >e,</span>h=<span class="cstat-no" title="statement not covered" >Math.max(n,a),</span>l=<span class="cstat-no" title="statement not covered" >Math.min(o,r),</span>c=<span class="cstat-no" title="statement not covered" >n&lt;a&amp;&amp;o&lt;a||n&gt;r&amp;&amp;o&gt;r;<span class="cstat-no" title="statement not covered" ></span>return{count:s,start:h,loop:e.loop,ilen:l&lt;h&amp;&amp;!c?s+l-h:l-h}}</span>function <span class="fstat-no" title="function not covered" >ue(</span>t,e,i,n){const{points:o,options:a}=<span class="cstat-no" title="statement not covered" >e,</span>{count:r,start:h,loop:l,ilen:c}=<span class="cstat-no" title="statement not covered" >de(o,i,n),</span>d=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.stepped?s.at:t.tension||"monotone"===t.cubicInterpolationMode?s.au:ce}</span>(a);</span>let u,g,f,{move:p=<span class="branch-0 cbranch-no" title="branch not covered" >!0,</span>reverse:x}=<span class="cstat-no" title="statement not covered" >n||{};<span class="cstat-no" title="statement not covered" ></span>for(u=0;u&lt;=c;++u)<span class="cstat-no" title="statement not covered" >g=o[(h+(x?c-u:u))%r],g.skip||(p?(t.moveTo(g.x,g.y),p=!1):d(t,f,g,x,a.stepped),f=g);<span class="cstat-no" title="statement not covered" >r</span></span>eturn l&amp;&amp;(g=o[(h+(x?c:0))%r],d(t,f,g,x,a.stepped)),!!l}</span>function <span class="fstat-no" title="function not covered" >ge(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >e.points,</span>{count:o,start:a,ilen:r}=<span class="cstat-no" title="statement not covered" >de(n,i,s),</span>{move:h=<span class="branch-0 cbranch-no" title="branch not covered" >!0,</span>reverse:l}=<span class="cstat-no" title="statement not covered" >s||{};</span>let c,d,u,g,f,p,x=<span class="cstat-no" title="statement not covered" >0,</span>m=<span class="cstat-no" title="statement not covered" >0;</span>const b=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(a+(l?r-t:t))%o,</span></span>_=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >g!==f&amp;&amp;(t.lineTo(x,f),t.lineTo(x,g),t.lineTo(x,p))}</span>;<span class="cstat-no" title="statement not covered" ></span>for(h&amp;&amp;(d=n[b(0)],t.moveTo(d.x,d.y)),c=0;c&lt;=r;++c){<span class="cstat-no" title="statement not covered" >if(d=n[b(c)],d.skip)<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >d.x,</span>i=<span class="cstat-no" title="statement not covered" >d.y,</span>s=<span class="cstat-no" title="statement not covered" >0|e;<span class="cstat-no" title="statement not covered" ></span>s===u?(i&lt;g?g=i:i&gt;f&amp;&amp;(f=i),x=(m*x+e)/++m):(_(),t.lineTo(e,i),u=s,m=0,g=f=i),p=i}<span class="cstat-no" title="statement not covered" ></span>_</span>()}</span>function <span class="fstat-no" title="function not covered" >fe(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.options,</span>i=<span class="cstat-no" title="statement not covered" >e.borderDash&amp;&amp;e.borderDash.length;<span class="cstat-no" title="statement not covered" ></span>return!t._decimated&amp;&amp;!t._loop&amp;&amp;!e.tension&amp;&amp;"monotone"!==e.cubicInterpolationMode&amp;&amp;!e.stepped&amp;&amp;!i?ge:ue}</span>const pe=<span class="cstat-no" title="statement not covered" >"function"===typeof Path2D;</span>function <span class="fstat-no" title="function not covered" >xe(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >pe&amp;&amp;!e.options.segment?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){let n=<span class="cstat-no" title="statement not covered" >e._path;<span class="cstat-no" title="statement not covered" ></span>n||(n=e._path=new Path2D,e.path(n,i,s)&amp;&amp;n.closePath()),le(t,e.options),t.stroke(n)}</span>(t,e,i,s):<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const{segments:n,options:o}=<span class="cstat-no" title="statement not covered" >e,</span>a=<span class="cstat-no" title="statement not covered" >fe(e);<span class="cstat-no" title="statement not covered" ></span>for(const r of n)<span class="cstat-no" title="statement not covered" >le(t,o,r.style),t.beginPath(),a(t,e,r,{start:i,end:i+s-1})&amp;&amp;t.closePath(),t.stroke()}</span></span>(t,e,i,s)}</span>class me extends xt{static id=<span class="cstat-no" title="statement not covered" >"line";</span>static defaults=<span class="cstat-no" title="statement not covered" >{borderCapStyle:"butt",borderDash:[],borderDashOffset:0,borderJoinStyle:"miter",borderWidth:3,capBezierPoints:!0,cubicInterpolationMode:"default",fill:!1,spanGaps:!1,stepped:!1,tension:0};</span>static defaultRoutes=<span class="cstat-no" title="statement not covered" >{backgroundColor:"backgroundColor",borderColor:"borderColor"};</span>static descriptors=<span class="cstat-no" title="statement not covered" >{_scriptable:!0,_indexable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"borderDash"!==t&amp;&amp;"fill"!==t}</span>;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.animated=!0,this.options=void 0,this._chart=void 0,this._loop=void 0,this._fullLoop=void 0,this._path=void 0,this._points=void 0,this._segments=void 0,this._decimated=!1,this._pointsUpdated=!1,this._datasetIndex=void 0,t&amp;&amp;Object.assign(this,t)}<span class="fstat-no" title="function not covered" ></span>up</span>dateControlPoints(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if((i.tension||"monotone"===i.cubicInterpolationMode)&amp;&amp;!i.stepped&amp;&amp;!this._pointsUpdated){const n=<span class="cstat-no" title="statement not covered" >i.spanGaps?this._loop:this._fullLoop;<span class="cstat-no" title="statement not covered" ></span>(0,s.an)(this._points,i,t,n,e),this._pointsUpdated=!0}</span>}<span class="fstat-no" title="function not covered" ></span>se</span>t points(t){<span class="cstat-no" title="statement not covered" >this._points=t,delete this._segments,delete this._path,this._pointsUpdated=!1}<span class="fstat-no" title="function not covered" ></span>ge</span>t points(){<span class="cstat-no" title="statement not covered" >return this._points}<span class="fstat-no" title="function not covered" ></span>ge</span>t segments(){<span class="cstat-no" title="statement not covered" >return this._segments||(this._segments=(0,s.ao)(this,this.options.segment))}<span class="fstat-no" title="function not covered" ></span>fi</span>rst(){const t=<span class="cstat-no" title="statement not covered" >this.segments,</span>e=<span class="cstat-no" title="statement not covered" >this.points;<span class="cstat-no" title="statement not covered" ></span>return t.length&amp;&amp;e[t[0].start]}<span class="fstat-no" title="function not covered" ></span>la</span>st(){const t=<span class="cstat-no" title="statement not covered" >this.segments,</span>e=<span class="cstat-no" title="statement not covered" >this.points,</span>i=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;e[t[i-1].end]}<span class="fstat-no" title="function not covered" ></span>in</span>terpolate(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options,</span>n=<span class="cstat-no" title="statement not covered" >t[e],</span>o=<span class="cstat-no" title="statement not covered" >this.points,</span>a=<span class="cstat-no" title="statement not covered" >(0,s.ap)(this,{property:e,start:n,end:n});<span class="cstat-no" title="statement not covered" ></span>if(!a.length)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >[],</span>h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >return t.stepped?s.aq:t.tension||"monotone"===t.cubicInterpolationMode?s.ar:s.as}</span>(i);</span>let l,c;<span class="cstat-no" title="statement not covered" >for(l=0,c=a.length;l&lt;c;++l){const{start:s,end:c}=<span class="cstat-no" title="statement not covered" >a[l],</span>d=<span class="cstat-no" title="statement not covered" >o[s],</span>u=<span class="cstat-no" title="statement not covered" >o[c];<span class="cstat-no" title="statement not covered" ></span>if(d===u){<span class="cstat-no" title="statement not covered" >r.push(d);<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>c</span>onst g=<span class="cstat-no" title="statement not covered" >h(d,u,Math.abs((n-d[e])/(u[e]-d[e])),i.stepped);<span class="cstat-no" title="statement not covered" ></span>g[e]=t[e],r.push(g)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn 1===r.length?r[0]:r}<span class="fstat-no" title="function not covered" ></span>pa</span>thSegment(t,e,i){<span class="cstat-no" title="statement not covered" >return fe(this)(t,this,e,i)}<span class="fstat-no" title="function not covered" ></span>pa</span>th(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.segments,</span>n=<span class="cstat-no" title="statement not covered" >fe(this);</span>let o=<span class="cstat-no" title="statement not covered" >this._loop;<span class="cstat-no" title="statement not covered" ></span>e=e||0,i=i||this.points.length-e;<span class="cstat-no" title="statement not covered" >f</span>or(const a of s)<span class="cstat-no" title="statement not covered" >o&amp;=n(t,this,a,{start:e,end:e+i-1});<span class="cstat-no" title="statement not covered" >r</span></span>eturn!!o}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >this.options||{};<span class="cstat-no" title="statement not covered" ></span>(this.points||[]).length&amp;&amp;n.borderWidth&amp;&amp;(t.save(),xe(t,this,i,s),t.restore()),this.animated&amp;&amp;(this._pointsUpdated=!1,this._path=void 0)}</span>}function <span class="fstat-no" title="function not covered" >be(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >t.options,</span>{[i]:o}=<span class="cstat-no" title="statement not covered" >t.getProps([i],s);<span class="cstat-no" title="statement not covered" ></span>return Math.abs(e-o)&lt;n.radius+n.hitRadius}</span>class _e extends xt{static id=<span class="cstat-no" title="statement not covered" >"point";</span>parsed;skip;stop;static defaults=<span class="cstat-no" title="statement not covered" >{borderWidth:1,hitRadius:1,hoverBorderWidth:1,hoverRadius:4,pointStyle:"circle",radius:3,rotation:0};</span>static defaultRoutes=<span class="cstat-no" title="statement not covered" >{backgroundColor:"backgroundColor",borderColor:"borderColor"};<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.options=void 0,this.parsed=void 0,this.skip=void 0,this.stop=void 0,t&amp;&amp;Object.assign(this,t)}<span class="fstat-no" title="function not covered" ></span>in</span>Range(t,e,i){const s=<span class="cstat-no" title="statement not covered" >this.options,</span>{x:n,y:o}=<span class="cstat-no" title="statement not covered" >this.getProps(["x","y"],i);<span class="cstat-no" title="statement not covered" ></span>return Math.pow(t-n,2)+Math.pow(e-o,2)&lt;Math.pow(s.hitRadius+s.radius,2)}<span class="fstat-no" title="function not covered" ></span>in</span>XRange(t,e){<span class="cstat-no" title="statement not covered" >return be(this,t,"x",e)}<span class="fstat-no" title="function not covered" ></span>in</span>YRange(t,e){<span class="cstat-no" title="statement not covered" >return be(this,t,"y",e)}<span class="fstat-no" title="function not covered" ></span>ge</span>tCenterPoint(t){const{x:e,y:i}=<span class="cstat-no" title="statement not covered" >this.getProps(["x","y"],t);<span class="cstat-no" title="statement not covered" ></span>return{x:e,y:i}}<span class="fstat-no" title="function not covered" ></span>si</span>ze(t){let e=<span class="cstat-no" title="statement not covered" >(t=t||this.options||{}).radius||0;<span class="cstat-no" title="statement not covered" ></span>e=Math.max(e,e&amp;&amp;t.hoverRadius||0);<span class="cstat-no" title="statement not covered" >r</span>eturn 2*(e+(e&amp;&amp;t.borderWidth||0))}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>this.skip||i.radius&lt;.1||!(0,s.C)(this,e,this.size(i)/2)||(t.strokeStyle=i.borderColor,t.lineWidth=i.borderWidth,t.fillStyle=i.backgroundColor,(0,s.av)(t,i,this.x,this.y))}<span class="fstat-no" title="function not covered" ></span>ge</span>tRange(){const t=<span class="cstat-no" title="statement not covered" >this.options||{};<span class="cstat-no" title="statement not covered" ></span>return t.radius+t.hitRadius}</span>}function <span class="fstat-no" title="function not covered" >ve(</span>t,e){const{x:i,y:s,base:n,width:o,height:a}=<span class="cstat-no" title="statement not covered" >t.getProps(["x","y","base","width","height"],e);</span>let r,h,l,c,d;<span class="cstat-no" title="statement not covered" >return t.horizontal?(d=a/2,r=Math.min(i,n),h=Math.max(i,n),l=s-d,c=s+d):(d=o/2,r=i-d,h=i+d,l=Math.min(s,n),c=Math.max(s,n)),{left:r,top:l,right:h,bottom:c}}</span>function <span class="fstat-no" title="function not covered" >ye(</span>t,e,i,n){<span class="cstat-no" title="statement not covered" >return t?0:(0,s.S)(e,i,n)}</span>function <span class="fstat-no" title="function not covered" >Me(</span>t){const e=<span class="cstat-no" title="statement not covered" >ve(t),</span>i=<span class="cstat-no" title="statement not covered" >e.right-e.left,</span>n=<span class="cstat-no" title="statement not covered" >e.bottom-e.top,</span>o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const n=<span class="cstat-no" title="statement not covered" >t.options.borderWidth,</span>o=<span class="cstat-no" title="statement not covered" >t.borderSkipped,</span>a=<span class="cstat-no" title="statement not covered" >(0,s.ax)(n);<span class="cstat-no" title="statement not covered" ></span>return{t:ye(o.top,a.top,0,i),r:ye(o.right,a.right,0,e),b:ye(o.bottom,a.bottom,0,i),l:ye(o.left,a.left,0,e)}}</span>(t,i/2,n/2),</span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const{enableBorderRadius:n}=<span class="cstat-no" title="statement not covered" >t.getProps(["enableBorderRadius"]),</span>o=<span class="cstat-no" title="statement not covered" >t.options.borderRadius,</span>a=<span class="cstat-no" title="statement not covered" >(0,s.ay)(o),</span>r=<span class="cstat-no" title="statement not covered" >Math.min(e,i),</span>h=<span class="cstat-no" title="statement not covered" >t.borderSkipped,</span>l=<span class="cstat-no" title="statement not covered" >n||(0,s.i)(o);<span class="cstat-no" title="statement not covered" ></span>return{topLeft:ye(!l||h.top||h.left,a.topLeft,0,r),topRight:ye(!l||h.top||h.right,a.topRight,0,r),bottomLeft:ye(!l||h.bottom||h.left,a.bottomLeft,0,r),bottomRight:ye(!l||h.bottom||h.right,a.bottomRight,0,r)}}</span>(t,i/2,n/2);<span class="cstat-no" title="statement not covered" ></span>return{outer:{x:e.left,y:e.top,w:i,h:n,radius:a},inner:{x:e.left+o.l,y:e.top+o.t,w:i-o.l-o.r,h:n-o.t-o.b,radius:{topLeft:Math.max(0,a.topLeft-Math.max(o.t,o.l)),topRight:Math.max(0,a.topRight-Math.max(o.t,o.r)),bottomLeft:Math.max(0,a.bottomLeft-Math.max(o.b,o.l)),bottomRight:Math.max(0,a.bottomRight-Math.max(o.b,o.r))}}}}</span>function <span class="fstat-no" title="function not covered" >we(</span>t,e,i,n){const o=<span class="cstat-no" title="statement not covered" >null===e,</span>a=<span class="cstat-no" title="statement not covered" >null===i,</span>r=<span class="cstat-no" title="statement not covered" >t&amp;&amp;!(o&amp;&amp;a)&amp;&amp;ve(t,n);<span class="cstat-no" title="statement not covered" ></span>return r&amp;&amp;(o||(0,s.ak)(e,r.left,r.right))&amp;&amp;(a||(0,s.ak)(i,r.top,r.bottom))}</span>function <span class="fstat-no" title="function not covered" >ke(</span>t,e){<span class="cstat-no" title="statement not covered" >t.rect(e.x,e.y,e.w,e.h)}</span>function <span class="fstat-no" title="function not covered" >Se(</span>t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const s=<span class="cstat-no" title="statement not covered" >t.x!==i.x?-e:0,</span>n=<span class="cstat-no" title="statement not covered" >t.y!==i.y?-e:0,</span>o=<span class="cstat-no" title="statement not covered" >(t.x+t.w!==i.x+i.w?e:0)-s,</span>a=<span class="cstat-no" title="statement not covered" >(t.y+t.h!==i.y+i.h?e:0)-n;<span class="cstat-no" title="statement not covered" ></span>return{x:t.x+s,y:t.y+n,w:t.w+o,h:t.h+a,radius:t.radius}}</span>class De extends xt{static id=<span class="cstat-no" title="statement not covered" >"bar";</span>static defaults=<span class="cstat-no" title="statement not covered" >{borderSkipped:"start",borderWidth:0,borderRadius:0,inflateAmount:"auto",pointStyle:void 0};</span>static defaultRoutes=<span class="cstat-no" title="statement not covered" >{backgroundColor:"backgroundColor",borderColor:"borderColor"};<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.options=void 0,this.horizontal=void 0,this.base=void 0,this.width=void 0,this.height=void 0,this.inflateAmount=void 0,t&amp;&amp;Object.assign(this,t)}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(t){const{inflateAmount:e,options:{borderColor:i,backgroundColor:n}}=<span class="cstat-no" title="statement not covered" >this,</span>{inner:o,outer:a}=<span class="cstat-no" title="statement not covered" >Me(this),</span>r=<span class="cstat-no" title="statement not covered" >(h=a.radius).topLeft||h.topRight||h.bottomLeft||h.bottomRight?s.aw:ke;</span>var h;<span class="cstat-no" title="statement not covered" >t.save(),a.w===o.w&amp;&amp;a.h===o.h||(t.beginPath(),r(t,Se(a,e,o)),t.clip(),r(t,Se(o,-e,a)),t.fillStyle=i,t.fill("evenodd")),t.beginPath(),r(t,Se(o,e)),t.fillStyle=n,t.fill(),t.restore()}<span class="fstat-no" title="function not covered" ></span>in</span>Range(t,e,i){<span class="cstat-no" title="statement not covered" >return we(this,t,e,i)}<span class="fstat-no" title="function not covered" ></span>in</span>XRange(t,e){<span class="cstat-no" title="statement not covered" >return we(this,t,null,e)}<span class="fstat-no" title="function not covered" ></span>in</span>YRange(t,e){<span class="cstat-no" title="statement not covered" >return we(this,null,t,e)}<span class="fstat-no" title="function not covered" ></span>ge</span>tCenterPoint(t){const{x:e,y:i,base:s,horizontal:n}=<span class="cstat-no" title="statement not covered" >this.getProps(["x","y","base","horizontal"],t);<span class="cstat-no" title="statement not covered" ></span>return{x:n?(e+s)/2:e,y:n?i:(i+s)/2}}<span class="fstat-no" title="function not covered" ></span>ge</span>tRange(t){<span class="cstat-no" title="statement not covered" >return"x"===t?this.width/2:this.height/2}</span>}function <span class="fstat-no" title="function not covered" >Pe(</span>t,e,i,n){<span class="cstat-no" title="statement not covered" >if(n)<span class="cstat-no" title="statement not covered" >return;l</span></span>et o=<span class="cstat-no" title="statement not covered" >e[t],</span>a=<span class="cstat-no" title="statement not covered" >i[t];<span class="cstat-no" title="statement not covered" ></span>return"angle"===t&amp;&amp;(o=(0,s.al)(o),a=(0,s.al)(a)),{property:t,start:o,end:a}}</span>function <span class="fstat-no" title="function not covered" >Ae(</span>t,e,i){<span class="cstat-no" title="statement not covered" >for(;e&gt;t;e--){const t=<span class="cstat-no" title="statement not covered" >i[e];<span class="cstat-no" title="statement not covered" ></span>if(!isNaN(t.x)&amp;&amp;!isNaN(t.y))<span class="cstat-no" title="statement not covered" >break}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn e}</span>function <span class="fstat-no" title="function not covered" >Ce(</span>t,e,i,s){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;e?s(t[i],e[i]):t?t[i]:e?e[i]:0}</span>function <span class="fstat-no" title="function not covered" >Te(</span>t,e){let i=<span class="cstat-no" title="statement not covered" >[],</span>n=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return(0,s.b)(t)?(n=!0,i=t):i=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const{x:i=<span class="branch-0 cbranch-no" title="branch not covered" >null,</span>y:s=<span class="branch-0 cbranch-no" title="branch not covered" >null}</span>=<span class="cstat-no" title="statement not covered" >t||{},</span>n=<span class="cstat-no" title="statement not covered" >e.points,</span>o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return e.segments.forEach((<span class="fstat-no" title="function not covered" >({</span>start:t,end:e})=&gt;{<span class="cstat-no" title="statement not covered" >e=Ae(t,e,n);c</span>onst a=<span class="cstat-no" title="statement not covered" >n[t],</span>r=<span class="cstat-no" title="statement not covered" >n[e];<span class="cstat-no" title="statement not covered" ></span>null!==s?(o.push({x:a.x,y:s}),o.push({x:r.x,y:s})):null!==i&amp;&amp;(o.push({x:i,y:a.y}),o.push({x:i,y:r.y}))}</span>)),o}</span>(t,e),i.length?new me({points:i,options:{tension:0},_loop:n,_fullLoop:n}):null}</span>function <span class="fstat-no" title="function not covered" >Oe(</span>t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;!1!==t.fill}</span>function <span class="fstat-no" title="function not covered" >Ee(</span>t,e,i){let n=<span class="cstat-no" title="statement not covered" >t[e].fill;</span>const o=<span class="cstat-no" title="statement not covered" >[e];</span>let a;<span class="cstat-no" title="statement not covered" >if(!i)<span class="cstat-no" title="statement not covered" >return n;<span class="cstat-no" title="statement not covered" >f</span></span>or(;!1!==n&amp;&amp;-1===o.indexOf(n);){<span class="cstat-no" title="statement not covered" >if(!(0,s.g)(n))<span class="cstat-no" title="statement not covered" >return n;<span class="cstat-no" title="statement not covered" >i</span></span>f(a=t[n],!a)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(a.visible)<span class="cstat-no" title="statement not covered" >return n;<span class="cstat-no" title="statement not covered" >o</span></span>.push(n),n=a.fill}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>function <span class="fstat-no" title="function not covered" >Re(</span>t,e,i){const n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >t.options,</span>i=<span class="cstat-no" title="statement not covered" >e.fill;</span>let n=<span class="cstat-no" title="statement not covered" >(0,s.v)(i&amp;&amp;i.target,i);<span class="cstat-no" title="statement not covered" ></span>void 0===n&amp;&amp;(n=!!e.backgroundColor);<span class="cstat-no" title="statement not covered" >i</span>f(!1===n||null===n)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(!0===n)<span class="cstat-no" title="statement not covered" >return"origin";<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>(t);<span class="cstat-no" title="statement not covered" ></span>if((0,s.i)(n))<span class="cstat-no" title="statement not covered" >return!isNaN(n.value)&amp;&amp;n;l</span></span>et o=<span class="cstat-no" title="statement not covered" >parseFloat(n);<span class="cstat-no" title="statement not covered" ></span>return(0,s.g)(o)&amp;&amp;Math.floor(o)===o?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){<span class="cstat-no" title="statement not covered" >"-"!==t&amp;&amp;"+"!==t||(i=e+i);<span class="cstat-no" title="statement not covered" >i</span>f(i===e||i&lt;0||i&gt;=s)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>(n[0],e,o,i):["origin","start","end","stack","shape"].indexOf(n)&gt;=0&amp;&amp;n}</span>function <span class="fstat-no" title="function not covered" >Ie(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;i.length;n++){const o=<span class="cstat-no" title="statement not covered" >i[n],</span>{first:a,last:r,point:h}=<span class="cstat-no" title="statement not covered" >Le(o,e,"x");<span class="cstat-no" title="statement not covered" ></span>if(!(!h||a&amp;&amp;r))<span class="cstat-no" title="statement not covered" >if(a)<span class="cstat-no" title="statement not covered" >s.unshift(h);e</span>lse <span class="cstat-no" title="statement not covered" >if(t.push(h),!r)<span class="cstat-no" title="statement not covered" >break}<span class="cstat-no" title="statement not covered" ></span></span></span></span>t</span>.push(...s)}</span>function <span class="fstat-no" title="function not covered" >Le(</span>t,e,i){const n=<span class="cstat-no" title="statement not covered" >t.interpolate(e,i);<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >return{};c</span></span>onst o=<span class="cstat-no" title="statement not covered" >n[i],</span>a=<span class="cstat-no" title="statement not covered" >t.segments,</span>r=<span class="cstat-no" title="statement not covered" >t.points;</span>let h=<span class="cstat-no" title="statement not covered" >!1,</span>l=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>for(let c=<span class="cstat-no" title="statement not covered" >0;</span>c&lt;a.length;c++){const t=<span class="cstat-no" title="statement not covered" >a[c],</span>e=<span class="cstat-no" title="statement not covered" >r[t.start][i],</span>n=<span class="cstat-no" title="statement not covered" >r[t.end][i];<span class="cstat-no" title="statement not covered" ></span>if((0,s.ak)(o,e,n)){<span class="cstat-no" title="statement not covered" >h=o===e,l=o===n;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{first:h,last:l,point:n}}</span>class ze{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.x=t.x,this.y=t.y,this.radius=t.radius}<span class="fstat-no" title="function not covered" ></span>pa</span>thSegment(t,e,i){const{x:n,y:o,radius:a}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>return e=e||{start:0,end:s.T},t.arc(n,o,a,e.end,e.start,!0),!i.bounds}<span class="fstat-no" title="function not covered" ></span>in</span>terpolate(t){const{x:e,y:i,radius:s}=<span class="cstat-no" title="statement not covered" >this,</span>n=<span class="cstat-no" title="statement not covered" >t.angle;<span class="cstat-no" title="statement not covered" ></span>return{x:e+Math.cos(n)*s,y:i+Math.sin(n)*s,angle:n}}</span>}function <span class="fstat-no" title="function not covered" >Fe(</span>t){const{chart:e,fill:i,line:n}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if((0,s.g)(i))<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >t.getDatasetMeta(e);<span class="cstat-no" title="statement not covered" ></span>return i&amp;&amp;t.isDatasetVisible(e)?i.dataset:null}</span>(e,i);<span class="cstat-no" title="statement not covered" >i</span></span>f("stack"===i)<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t){const{scale:e,index:i,line:s}=<span class="cstat-no" title="statement not covered" >t,</span>n=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >s.segments,</span>a=<span class="cstat-no" title="statement not covered" >s.points,</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >t.getMatchingVisibleMetas("line");<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;s.length;n++){const t=<span class="cstat-no" title="statement not covered" >s[n];<span class="cstat-no" title="statement not covered" ></span>if(t.index===e)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >t</span></span>.hidden||i.unshift(t.dataset)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>(e,i);<span class="cstat-no" title="statement not covered" ></span>r.push(Te({x:null,y:e.bottom},s));<span class="cstat-no" title="statement not covered" >f</span>or(let h=<span class="cstat-no" title="statement not covered" >0;</span>h&lt;o.length;h++){const t=<span class="cstat-no" title="statement not covered" >o[h];<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >t.start;</span>e&lt;=t.end;e++)<span class="cstat-no" title="statement not covered" >Ie(n,a[e],r)}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn new me({points:n,options:{}})}</span>(t);<span class="cstat-no" title="statement not covered" >i</span></span>f("shape"===i)<span class="cstat-no" title="statement not covered" >return!0;c</span></span>onst o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >if((t.scale||{}).getPointPositionForValue)<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t){const{scale:e,fill:i}=<span class="cstat-no" title="statement not covered" >t,</span>n=<span class="cstat-no" title="statement not covered" >e.options,</span>o=<span class="cstat-no" title="statement not covered" >e.getLabels().length,</span>a=<span class="cstat-no" title="statement not covered" >n.reverse?e.max:e.min,</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){let n;<span class="cstat-no" title="statement not covered" >return n="start"===t?i:"end"===t?e.options.reverse?e.min:e.max:(0,s.i)(t)?t.value:e.getBaseValue(),n}</span>(i,e,a),</span>h=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(n.grid.circular){const t=<span class="cstat-no" title="statement not covered" >e.getPointPositionForValue(0,a);<span class="cstat-no" title="statement not covered" ></span>return new ze({x:t.x,y:t.y,radius:e.getDistanceFromCenterForValue(r)})}<span class="cstat-no" title="statement not covered" ></span>f</span>or(let s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;o;++s)<span class="cstat-no" title="statement not covered" >h.push(e.getPointPositionForValue(s,r));<span class="cstat-no" title="statement not covered" >r</span></span>eturn h}</span>(t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn <span class="fstat-no" title="function not covered" >fu</span>nction(t){const{scale:e=<span class="branch-0 cbranch-no" title="branch not covered" >{},</span>fill:i}=<span class="cstat-no" title="statement not covered" >t,</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){let i=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>return"start"===t?i=e.bottom:"end"===t?i=e.top:(0,s.i)(t)?i=e.getPixelForValue(t.value):e.getBasePixel&amp;&amp;(i=e.getBasePixel()),i}</span>(i,e);<span class="cstat-no" title="statement not covered" ></span>if((0,s.g)(n)){const t=<span class="cstat-no" title="statement not covered" >e.isHorizontal();<span class="cstat-no" title="statement not covered" ></span>return{x:t?n:null,y:t?null:n}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn null}</span>(t)}</span>(t);<span class="cstat-no" title="statement not covered" ></span>return o instanceof ze?o:Te(o,n)}</span>function <span class="fstat-no" title="function not covered" >Be(</span>t,e,i){const n=<span class="cstat-no" title="statement not covered" >Fe(e),</span>{chart:o,index:a,line:r,scale:h,axis:l}=<span class="cstat-no" title="statement not covered" >e,</span>c=<span class="cstat-no" title="statement not covered" >r.options,</span>d=<span class="cstat-no" title="statement not covered" >c.fill,</span>u=<span class="cstat-no" title="statement not covered" >c.backgroundColor,</span>{above:g=<span class="branch-0 cbranch-no" title="branch not covered" >u,</span>below:f=<span class="branch-0 cbranch-no" title="branch not covered" >u}</span>=<span class="cstat-no" title="statement not covered" >d||{},</span>p=<span class="cstat-no" title="statement not covered" >o.getDatasetMeta(a),</span>x=<span class="cstat-no" title="statement not covered" >(0,s.ah)(o,p);<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;r.points.length&amp;&amp;((0,s.Y)(t,i),<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const{line:i,target:s,above:n,below:o,area:a,scale:r,clip:h}=<span class="cstat-no" title="statement not covered" >e,</span>l=<span class="cstat-no" title="statement not covered" >i._loop?"angle":e.axis;<span class="cstat-no" title="statement not covered" ></span>t.save();l</span>et c=<span class="cstat-no" title="statement not covered" >o;<span class="cstat-no" title="statement not covered" ></span>o!==n&amp;&amp;("x"===l?(He(t,s,a.top),We(t,{line:i,target:s,color:n,scale:r,property:l,clip:h}),t.restore(),t.save(),He(t,s,a.bottom)):"y"===l&amp;&amp;(Ve(t,s,a.left),We(t,{line:i,target:s,color:o,scale:r,property:l,clip:h}),t.restore(),t.save(),Ve(t,s,a.right),c=n));<span class="cstat-no" title="statement not covered" >W</span>e(t,{line:i,target:s,color:c,scale:r,property:l,clip:h}),t.restore()}</span>(t,{line:r,target:n,above:g,below:f,area:i,scale:h,axis:l,clip:x}),(0,s.$)(t))}</span>function <span class="fstat-no" title="function not covered" >He(</span>t,e,i){const{segments:s,points:n}=<span class="cstat-no" title="statement not covered" >e;</span>let o=<span class="cstat-no" title="statement not covered" >!0,</span>a=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>t.beginPath();<span class="cstat-no" title="statement not covered" >f</span>or(const r of s){const{start:s,end:h}=<span class="cstat-no" title="statement not covered" >r,</span>l=<span class="cstat-no" title="statement not covered" >n[s],</span>c=<span class="cstat-no" title="statement not covered" >n[Ae(s,h,n)];<span class="cstat-no" title="statement not covered" ></span>o?(t.moveTo(l.x,l.y),o=!1):(t.lineTo(l.x,i),t.lineTo(l.x,l.y)),a=!!e.pathSegment(t,r,{move:a}),a?t.closePath():t.lineTo(c.x,i)}<span class="cstat-no" title="statement not covered" ></span>t</span>.lineTo(e.first().x,i),t.closePath(),t.clip()}</span>function <span class="fstat-no" title="function not covered" >Ve(</span>t,e,i){const{segments:s,points:n}=<span class="cstat-no" title="statement not covered" >e;</span>let o=<span class="cstat-no" title="statement not covered" >!0,</span>a=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>t.beginPath();<span class="cstat-no" title="statement not covered" >f</span>or(const r of s){const{start:s,end:h}=<span class="cstat-no" title="statement not covered" >r,</span>l=<span class="cstat-no" title="statement not covered" >n[s],</span>c=<span class="cstat-no" title="statement not covered" >n[Ae(s,h,n)];<span class="cstat-no" title="statement not covered" ></span>o?(t.moveTo(l.x,l.y),o=!1):(t.lineTo(i,l.y),t.lineTo(l.x,l.y)),a=!!e.pathSegment(t,r,{move:a}),a?t.closePath():t.lineTo(i,c.y)}<span class="cstat-no" title="statement not covered" ></span>t</span>.lineTo(i,e.first().y),t.closePath(),t.clip()}</span>function <span class="fstat-no" title="function not covered" >We(</span>t,e){const{line:i,target:n,property:o,color:a,scale:r,clip:h}=<span class="cstat-no" title="statement not covered" >e,</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){const n=<span class="cstat-no" title="statement not covered" >t.segments,</span>o=<span class="cstat-no" title="statement not covered" >t.points,</span>a=<span class="cstat-no" title="statement not covered" >e.points,</span>r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(const h of n){let{start:t,end:n}=<span class="cstat-no" title="statement not covered" >h;<span class="cstat-no" title="statement not covered" ></span>n=Ae(t,n,o);c</span>onst l=<span class="cstat-no" title="statement not covered" >Pe(i,o[t],o[n],h.loop);<span class="cstat-no" title="statement not covered" ></span>if(!e.segments){<span class="cstat-no" title="statement not covered" >r.push({source:h,target:l,start:o[t],end:o[n]});<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>c</span>onst c=<span class="cstat-no" title="statement not covered" >(0,s.ap)(e,l);<span class="cstat-no" title="statement not covered" ></span>for(const e of c){const t=<span class="cstat-no" title="statement not covered" >Pe(i,a[e.start],a[e.end],e.loop),</span>n=<span class="cstat-no" title="statement not covered" >(0,s.az)(h,o,t);<span class="cstat-no" title="statement not covered" ></span>for(const s of n)<span class="cstat-no" title="statement not covered" >r.push({source:s,target:e,start:{[i]:Ce(l,t,"start",Math.max)},end:{[i]:Ce(l,t,"end",Math.min)}})}</span></span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}</span>(i,n,o);<span class="cstat-no" title="statement not covered" ></span>for(const{source:s,target:c,start:d,end:u}of l){const{style:{backgroundColor:e=<span class="branch-0 cbranch-no" title="branch not covered" >a}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{}}</span>=<span class="cstat-no" title="statement not covered" >s,</span>l=<span class="cstat-no" title="statement not covered" >!0!==n;<span class="cstat-no" title="statement not covered" ></span>t.save(),t.fillStyle=e,Ne(t,r,h,l&amp;&amp;Pe(o,d,u)),t.beginPath();c</span>onst g=<span class="cstat-no" title="statement not covered" >!!i.pathSegment(t,s);</span>let f;<span class="cstat-no" title="statement not covered" >if(l){<span class="cstat-no" title="statement not covered" >g?t.closePath():je(t,n,u,o);c</span>onst e=<span class="cstat-no" title="statement not covered" >!!n.pathSegment(t,c,{move:g,reverse:!0});<span class="cstat-no" title="statement not covered" ></span>f=g&amp;&amp;e,f||je(t,n,d,o)}<span class="cstat-no" title="statement not covered" ></span>t</span>.closePath(),t.fill(f?"evenodd":"nonzero"),t.restore()}</span>}</span>function <span class="fstat-no" title="function not covered" >Ne(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >e.chart.chartArea,</span>{property:o,start:a,end:r}=<span class="cstat-no" title="statement not covered" >s||{};<span class="cstat-no" title="statement not covered" ></span>if("x"===o||"y"===o){let e,s,h,l;<span class="cstat-no" title="statement not covered" >"x"===o?(e=a,s=n.top,h=r,l=n.bottom):(e=n.left,s=a,h=n.right,l=r),t.beginPath(),i&amp;&amp;(e=Math.max(e,i.left),h=Math.min(h,i.right),s=Math.max(s,i.top),l=Math.min(l,i.bottom)),t.rect(e,s,h-e,l-s),t.clip()}</span>}</span>function <span class="fstat-no" title="function not covered" >je(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >e.interpolate(i,s);<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;t.lineTo(n.x,n.y)}</span>var $e=<span class="cstat-no" title="statement not covered" >{id:"filler",<span class="fstat-no" title="function not covered" >af</span>terDatasetsUpdate(t,e,i){const s=<span class="cstat-no" title="statement not covered" >(t.data.datasets||[]).length,</span>n=<span class="cstat-no" title="statement not covered" >[];</span>let o,a,r,h;<span class="cstat-no" title="statement not covered" >for(a=0;a&lt;s;++a)<span class="cstat-no" title="statement not covered" >o=t.getDatasetMeta(a),r=o.dataset,h=null,r&amp;&amp;r.options&amp;&amp;r instanceof me&amp;&amp;(h={visible:t.isDatasetVisible(a),index:a,fill:Re(r,a,s),chart:t,axis:o.controller.options.indexAxis,scale:o.vScale,line:r}),o.$filler=h,n.push(h);<span class="cstat-no" title="statement not covered" >f</span></span>or(a=0;a&lt;s;++a)<span class="cstat-no" title="statement not covered" >h=n[a],h&amp;&amp;!1!==h.fill&amp;&amp;(h.fill=Ee(n,a,i.propagate))}</span></span>,<span class="fstat-no" title="function not covered" >be</span>foreDraw(t,e,i){const s=<span class="cstat-no" title="statement not covered" >"beforeDraw"===i.drawTime,</span>n=<span class="cstat-no" title="statement not covered" >t.getSortedVisibleDatasetMetas(),</span>o=<span class="cstat-no" title="statement not covered" >t.chartArea;<span class="cstat-no" title="statement not covered" ></span>for(let a=<span class="cstat-no" title="statement not covered" >n.length-1;</span>a&gt;=0;--a){const e=<span class="cstat-no" title="statement not covered" >n[a].$filler;<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;(e.line.updateControlPoints(o,e.axis),s&amp;&amp;e.fill&amp;&amp;Be(t.ctx,e,o))}</span>}</span>,<span class="fstat-no" title="function not covered" >be</span>foreDatasetsDraw(t,e,i){<span class="cstat-no" title="statement not covered" >if("beforeDatasetsDraw"!==i.drawTime)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >t.getSortedVisibleDatasetMetas();<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >s.length-1;</span>n&gt;=0;--n){const e=<span class="cstat-no" title="statement not covered" >s[n].$filler;<span class="cstat-no" title="statement not covered" ></span>Oe(e)&amp;&amp;Be(t.ctx,e,t.chartArea)}</span>}</span>,<span class="fstat-no" title="function not covered" >be</span>foreDatasetDraw(t,e,i){const s=<span class="cstat-no" title="statement not covered" >e.meta.$filler;<span class="cstat-no" title="statement not covered" ></span>Oe(s)&amp;&amp;"beforeDatasetDraw"===i.drawTime&amp;&amp;Be(t.ctx,s,t.chartArea)}</span>,defaults:{propagate:!0,drawTime:"beforeDatasetDraw"}};</span>const Ue=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{let{boxHeight:i=<span class="branch-0 cbranch-no" title="branch not covered" >e,</span>boxWidth:s=<span class="branch-0 cbranch-no" title="branch not covered" >e}</span>=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return t.usePointStyle&amp;&amp;(i=Math.min(i,e),s=t.pointStyleWidth||Math.min(s,e)),{boxWidth:s,boxHeight:i,itemHeight:Math.max(e,i)}}</span>;</span>class Ye extends xt{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this._added=!1,this.legendHitBoxes=[],this._hoveredItem=null,this.doughnutMode=!1,this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this.legendItems=void 0,this.columnSizes=void 0,this.lineWidths=void 0,this.maxHeight=void 0,this.maxWidth=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.height=void 0,this.width=void 0,this._margins=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}<span class="fstat-no" title="function not covered" ></span>up</span>date(t,e,i){<span class="cstat-no" title="statement not covered" >this.maxWidth=t,this.maxHeight=e,this._margins=i,this.setDimensions(),this.buildLabels(),this.fit()}<span class="fstat-no" title="function not covered" ></span>se</span>tDimensions(){<span class="cstat-no" title="statement not covered" >this.isHorizontal()?(this.width=this.maxWidth,this.left=this._margins.left,this.right=this.width):(this.height=this.maxHeight,this.top=this._margins.top,this.bottom=this.height)}<span class="fstat-no" title="function not covered" ></span>bu</span>ildLabels(){const t=<span class="cstat-no" title="statement not covered" >this.options.labels||{};</span>let e=<span class="cstat-no" title="statement not covered" >(0,s.Q)(t.generateLabels,[this.chart],this)||[];<span class="cstat-no" title="statement not covered" ></span>t.filter&amp;&amp;(e=e.filter((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >t.filter(e,this.chart.data))</span>)),t.sort&amp;&amp;(e=e.sort((<span class="fstat-no" title="function not covered" >(e</span>,i)=&gt;<span class="cstat-no" title="statement not covered" >t.sort(e,i,this.chart.data))</span>)),this.options.reverse&amp;&amp;e.reverse(),this.legendItems=e}<span class="fstat-no" title="function not covered" ></span>fi</span>t(){const{options:t,ctx:e}=<span class="cstat-no" title="statement not covered" >this;<span class="cstat-no" title="statement not covered" ></span>if(!t.display)<span class="cstat-no" title="statement not covered" >return void(this.width=this.height=0);c</span></span>onst i=<span class="cstat-no" title="statement not covered" >t.labels,</span>n=<span class="cstat-no" title="statement not covered" >(0,s.a0)(i.font),</span>o=<span class="cstat-no" title="statement not covered" >n.size,</span>a=<span class="cstat-no" title="statement not covered" >this._computeTitleHeight(),</span>{boxWidth:r,itemHeight:h}=<span class="cstat-no" title="statement not covered" >Ue(i,o);</span>let l,c;<span class="cstat-no" title="statement not covered" >e.font=n.string,this.isHorizontal()?(l=this.maxWidth,c=this._fitRows(a,o,r,h)+10):(c=this.maxHeight,l=this._fitCols(a,n,r,h)+10),this.width=Math.min(l,t.maxWidth||this.maxWidth),this.height=Math.min(c,t.maxHeight||this.maxHeight)}<span class="fstat-no" title="function not covered" ></span>_f</span>itRows(t,e,i,s){const{ctx:n,maxWidth:o,options:{labels:{padding:a}}}=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >this.legendHitBoxes=[],</span>h=<span class="cstat-no" title="statement not covered" >this.lineWidths=[0],</span>l=<span class="cstat-no" title="statement not covered" >s+a;</span>let c=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>n.textAlign="left",n.textBaseline="middle";l</span>et d=<span class="cstat-no" title="statement not covered" >-1,</span>u=<span class="cstat-no" title="statement not covered" >-l;<span class="cstat-no" title="statement not covered" ></span>return this.legendItems.forEach((<span class="fstat-no" title="function not covered" >(t</span>,g)=&gt;{const f=<span class="cstat-no" title="statement not covered" >i+e/2+n.measureText(t.text).width;<span class="cstat-no" title="statement not covered" ></span>(0===g||h[h.length-1]+f+2*a&gt;o)&amp;&amp;(c+=l,h[h.length-(g&gt;0?0:1)]=0,u+=l,d++),r[g]={left:0,top:u,row:d,width:f,height:s},h[h.length-1]+=f+a}</span>)),c}<span class="fstat-no" title="function not covered" ></span>_f</span>itCols(t,e,i,s){const{ctx:n,maxHeight:o,options:{labels:{padding:a}}}=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >this.legendHitBoxes=[],</span>h=<span class="cstat-no" title="statement not covered" >this.columnSizes=[],</span>l=<span class="cstat-no" title="statement not covered" >o-t;</span>let c=<span class="cstat-no" title="statement not covered" >a,</span>d=<span class="cstat-no" title="statement not covered" >0,</span>u=<span class="cstat-no" title="statement not covered" >0,</span>g=<span class="cstat-no" title="statement not covered" >0,</span>f=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return this.legendItems.forEach((<span class="fstat-no" title="function not covered" >(t</span>,o)=&gt;{const{itemWidth:p,itemHeight:x}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s,n){const o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){let n=<span class="cstat-no" title="statement not covered" >t.text;<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;"string"!==typeof n&amp;&amp;(n=n.reduce((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t.length&gt;e.length?t:e)</span>));<span class="cstat-no" title="statement not covered" >r</span>eturn e+i.size/2+s.measureText(n).width}</span>(s,t,e,i),</span>a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){let s=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>"string"!==typeof e.text&amp;&amp;(s=Xe(e,i));<span class="cstat-no" title="statement not covered" >r</span>eturn s}</span>(n,s,e.lineHeight);<span class="cstat-no" title="statement not covered" ></span>return{itemWidth:o,itemHeight:a}}</span>(i,e,n,t,s);<span class="cstat-no" title="statement not covered" ></span>o&gt;0&amp;&amp;u+x+2*a&gt;l&amp;&amp;(c+=d+a,h.push({width:d,height:u}),g+=d+a,f++,d=u=0),r[o]={left:g,top:u,col:f,width:p,height:x},d=Math.max(d,p),u+=x+a}</span>)),c+=d,h.push({width:d,height:u}),c}<span class="fstat-no" title="function not covered" ></span>ad</span>justHitBoxes(){<span class="cstat-no" title="statement not covered" >if(!this.options.display)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this._computeTitleHeight(),</span>{legendHitBoxes:e,options:{align:i,labels:{padding:n},rtl:o}}=<span class="cstat-no" title="statement not covered" >this,</span>a=<span class="cstat-no" title="statement not covered" >(0,s.aA)(o,this.left,this.width);<span class="cstat-no" title="statement not covered" ></span>if(this.isHorizontal()){let o=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >(0,s.a2)(i,this.left+n,this.right-this.lineWidths[o]);<span class="cstat-no" title="statement not covered" ></span>for(const h of e)<span class="cstat-no" title="statement not covered" >o!==h.row&amp;&amp;(o=h.row,r=(0,s.a2)(i,this.left+n,this.right-this.lineWidths[o])),h.top+=this.top+t+n,h.left=a.leftForLtr(a.x(r),h.width),r+=h.width+n}</span></span>else{let o=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >(0,s.a2)(i,this.top+t+n,this.bottom-this.columnSizes[o].height);<span class="cstat-no" title="statement not covered" ></span>for(const h of e)<span class="cstat-no" title="statement not covered" >h.col!==o&amp;&amp;(o=h.col,r=(0,s.a2)(i,this.top+t+n,this.bottom-this.columnSizes[o].height)),h.top=r,h.left+=this.left+n,h.left=a.leftForLtr(a.x(h.left),h.width),r+=h.height+n}</span></span>}<span class="fstat-no" title="function not covered" ></span>is</span>Horizontal(){<span class="cstat-no" title="statement not covered" >return"top"===this.options.position||"bottom"===this.options.position}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(){<span class="cstat-no" title="statement not covered" >if(this.options.display){const t=<span class="cstat-no" title="statement not covered" >this.ctx;<span class="cstat-no" title="statement not covered" ></span>(0,s.Y)(t,this),this._draw(),(0,s.$)(t)}</span>}<span class="fstat-no" title="function not covered" ></span>_d</span>raw(){const{options:t,columnSizes:e,lineWidths:i,ctx:n}=<span class="cstat-no" title="statement not covered" >this,</span>{align:o,labels:a}=<span class="cstat-no" title="statement not covered" >t,</span>r=<span class="cstat-no" title="statement not covered" >s.d.color,</span>h=<span class="cstat-no" title="statement not covered" >(0,s.aA)(t.rtl,this.left,this.width),</span>l=<span class="cstat-no" title="statement not covered" >(0,s.a0)(a.font),</span>{padding:c}=<span class="cstat-no" title="statement not covered" >a,</span>d=<span class="cstat-no" title="statement not covered" >l.size,</span>u=<span class="cstat-no" title="statement not covered" >d/2;</span>let g;<span class="cstat-no" title="statement not covered" >this.drawTitle(),n.textAlign=h.textAlign("left"),n.textBaseline="middle",n.lineWidth=.5,n.font=l.string;c</span>onst{boxWidth:f,boxHeight:p,itemHeight:x}=<span class="cstat-no" title="statement not covered" >Ue(a,d),</span>m=<span class="cstat-no" title="statement not covered" >this.isHorizontal(),</span>b=<span class="cstat-no" title="statement not covered" >this._computeTitleHeight();<span class="cstat-no" title="statement not covered" ></span>g=m?{x:(0,s.a2)(o,this.left+c,this.right-i[0]),y:this.top+c+b,line:0}:{x:this.left+c,y:(0,s.a2)(o,this.top+b+c,this.bottom-e[0].height),line:0},(0,s.aB)(this.ctx,t.textDirection);c</span>onst _=<span class="cstat-no" title="statement not covered" >x+c;<span class="cstat-no" title="statement not covered" ></span>this.legendItems.forEach((<span class="fstat-no" title="function not covered" >(v</span>,y)=&gt;{<span class="cstat-no" title="statement not covered" >n.strokeStyle=v.fontColor,n.fillStyle=v.fontColor;c</span>onst M=<span class="cstat-no" title="statement not covered" >n.measureText(v.text).width,</span>w=<span class="cstat-no" title="statement not covered" >h.textAlign(v.textAlign||(v.textAlign=a.textAlign)),</span>k=<span class="cstat-no" title="statement not covered" >f+u+M;</span>let S=<span class="cstat-no" title="statement not covered" >g.x,</span>D=<span class="cstat-no" title="statement not covered" >g.y;<span class="cstat-no" title="statement not covered" ></span>h.setWidth(this.width),m?y&gt;0&amp;&amp;S+k+c&gt;this.right&amp;&amp;(D=g.y+=_,g.line++,S=g.x=(0,s.a2)(o,this.left+c,this.right-i[g.line])):y&gt;0&amp;&amp;D+_&gt;this.bottom&amp;&amp;(S=g.x=S+e[g.line].width+c,g.line++,D=g.y=(0,s.a2)(o,this.top+b+c,this.bottom-e[g.line].height));<span class="cstat-no" title="statement not covered" >i</span>f(<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >if(isNaN(f)||f&lt;=0||isNaN(p)||p&lt;0)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >n</span></span>.save();c</span>onst o=<span class="cstat-no" title="statement not covered" >(0,s.v)(i.lineWidth,1);<span class="cstat-no" title="statement not covered" ></span>if(n.fillStyle=(0,s.v)(i.fillStyle,r),n.lineCap=(0,s.v)(i.lineCap,"butt"),n.lineDashOffset=(0,s.v)(i.lineDashOffset,0),n.lineJoin=(0,s.v)(i.lineJoin,"miter"),n.lineWidth=o,n.strokeStyle=(0,s.v)(i.strokeStyle,r),n.setLineDash((0,s.v)(i.lineDash,[])),a.usePointStyle){const r=<span class="cstat-no" title="statement not covered" >{radius:p*Math.SQRT2/2,pointStyle:i.pointStyle,rotation:i.rotation,borderWidth:o},</span>l=<span class="cstat-no" title="statement not covered" >h.xPlus(t,f/2),</span>c=<span class="cstat-no" title="statement not covered" >e+u;<span class="cstat-no" title="statement not covered" ></span>(0,s.aE)(n,r,l,c,a.pointStyleWidth&amp;&amp;f)}</span>else{const a=<span class="cstat-no" title="statement not covered" >e+Math.max((d-p)/2,0),</span>r=<span class="cstat-no" title="statement not covered" >h.leftForLtr(t,f),</span>l=<span class="cstat-no" title="statement not covered" >(0,s.ay)(i.borderRadius);<span class="cstat-no" title="statement not covered" ></span>n.beginPath(),Object.values(l).some((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >0!==t)</span>)?(0,s.aw)(n,{x:r,y:a,w:f,h:p,radius:l}):n.rect(r,a,f,p),n.fill(),0!==o&amp;&amp;n.stroke()}<span class="cstat-no" title="statement not covered" ></span>n</span>.restore()}</span>(h.x(S),D,v),S=(0,s.aC)(w,S+f+u,m?S+k:this.right,t.rtl),<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){<span class="cstat-no" title="statement not covered" >(0,s.Z)(n,i.text,t,e+x/2,l,{strikethrough:i.hidden,textAlign:h.textAlign(i.textAlign)})}</span>(h.x(S),D,v),m)<span class="cstat-no" title="statement not covered" >g.x+=k+c;e</span>lse <span class="cstat-no" title="statement not covered" >if("string"!==typeof v.text){const t=<span class="cstat-no" title="statement not covered" >l.lineHeight;<span class="cstat-no" title="statement not covered" ></span>g.y+=Xe(v,t)+c}</span>else <span class="cstat-no" title="statement not covered" >g.y+=_}</span></span></span>)),(0,s.aD)(this.ctx,t.textDirection)}<span class="fstat-no" title="function not covered" ></span>dr</span>awTitle(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >t.title,</span>i=<span class="cstat-no" title="statement not covered" >(0,s.a0)(e.font),</span>n=<span class="cstat-no" title="statement not covered" >(0,s.E)(e.padding);<span class="cstat-no" title="statement not covered" ></span>if(!e.display)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >(0,s.aA)(t.rtl,this.left,this.width),</span>a=<span class="cstat-no" title="statement not covered" >this.ctx,</span>r=<span class="cstat-no" title="statement not covered" >e.position,</span>h=<span class="cstat-no" title="statement not covered" >i.size/2,</span>l=<span class="cstat-no" title="statement not covered" >n.top+h;</span>let c,d=<span class="cstat-no" title="statement not covered" >this.left,</span>u=<span class="cstat-no" title="statement not covered" >this.width;<span class="cstat-no" title="statement not covered" ></span>if(this.isHorizontal())<span class="cstat-no" title="statement not covered" >u=Math.max(...this.lineWidths),c=this.top+l,d=(0,s.a2)(t.align,d,this.right-u);e</span>lse{const e=<span class="cstat-no" title="statement not covered" >this.columnSizes.reduce((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >Math.max(t,e.height))</span>,0);<span class="cstat-no" title="statement not covered" ></span>c=l+(0,s.a2)(t.align,this.top,this.bottom-e-t.labels.padding-this._computeTitleHeight())}</span>c</span>onst g=<span class="cstat-no" title="statement not covered" >(0,s.a2)(r,d,d+u);<span class="cstat-no" title="statement not covered" ></span>a.textAlign=o.textAlign((0,s.a1)(r)),a.textBaseline="middle",a.strokeStyle=e.color,a.fillStyle=e.color,a.font=i.string,(0,s.Z)(a,e.text,g,c,i)}<span class="fstat-no" title="function not covered" ></span>_c</span>omputeTitleHeight(){const t=<span class="cstat-no" title="statement not covered" >this.options.title,</span>e=<span class="cstat-no" title="statement not covered" >(0,s.a0)(t.font),</span>i=<span class="cstat-no" title="statement not covered" >(0,s.E)(t.padding);<span class="cstat-no" title="statement not covered" ></span>return t.display?e.lineHeight+i.height:0}<span class="fstat-no" title="function not covered" ></span>_g</span>etLegendItemAt(t,e){let i,n,o;<span class="cstat-no" title="statement not covered" >if((0,s.ak)(t,this.left,this.right)&amp;&amp;(0,s.ak)(e,this.top,this.bottom))<span class="cstat-no" title="statement not covered" >for(o=this.legendHitBoxes,i=0;i&lt;o.length;++i)<span class="cstat-no" title="statement not covered" >if(n=o[i],(0,s.ak)(t,n.left,n.left+n.width)&amp;&amp;(0,s.ak)(e,n.top,n.top+n.height))<span class="cstat-no" title="statement not covered" >return this.legendItems[i];<span class="cstat-no" title="statement not covered" >r</span></span></span></span>eturn null}<span class="fstat-no" title="function not covered" ></span>ha</span>ndleEvent(t){const e=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if(!<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(("mousemove"===t||"mouseout"===t)&amp;&amp;(e.onHover||e.onLeave))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(e.onClick&amp;&amp;("click"===t||"mouseup"===t))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span>eturn!1}</span>(t.type,e))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >this._getLegendItemAt(t.x,t.y);<span class="cstat-no" title="statement not covered" ></span>if("mousemove"===t.type||"mouseout"===t.type){const a=<span class="cstat-no" title="statement not covered" >this._hoveredItem,</span>r=(<span class="cstat-no" title="statement not covered" >o=i,null!==(n=a)&amp;&amp;null!==o&amp;&amp;n.datasetIndex===o.datasetIndex&amp;&amp;n.index===o.index)</span>;<span class="cstat-no" title="statement not covered" >a&amp;&amp;!r&amp;&amp;(0,s.Q)(e.onLeave,[t,a,this],this),this._hoveredItem=i,i&amp;&amp;!r&amp;&amp;(0,s.Q)(e.onHover,[t,i,this],this)}</span>else <span class="cstat-no" title="statement not covered" >i&amp;&amp;(0,s.Q)(e.onClick,[t,i,this],this);v</span></span>ar n,o}}function <span class="fstat-no" title="function not covered" >Xe(</span>t,e){<span class="cstat-no" title="statement not covered" >return e*(t.text?t.text.length:0)}</span>var Qe=<span class="cstat-no" title="statement not covered" >{id:"legend",_element:Ye,<span class="fstat-no" title="function not covered" >st</span>art(t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.legend=new Ye({ctx:t.ctx,options:i,chart:t});<span class="cstat-no" title="statement not covered" ></span>Z.configure(t,s,i),Z.addBox(t,s)}</span>,<span class="fstat-no" title="function not covered" >st</span>op(t){<span class="cstat-no" title="statement not covered" >Z.removeBox(t,t.legend),delete t.legend}</span>,<span class="fstat-no" title="function not covered" >be</span>foreUpdate(t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.legend;<span class="cstat-no" title="statement not covered" ></span>Z.configure(t,s,i),s.options=i}</span>,<span class="fstat-no" title="function not covered" >af</span>terUpdate(t){const e=<span class="cstat-no" title="statement not covered" >t.legend;<span class="cstat-no" title="statement not covered" ></span>e.buildLabels(),e.adjustHitBoxes()}</span>,<span class="fstat-no" title="function not covered" >af</span>terEvent(t,e){<span class="cstat-no" title="statement not covered" >e.replay||t.legend.handleEvent(e.event)}</span>,defaults:{display:!0,position:"top",align:"center",fullSize:!0,reverse:!1,weight:1e3,<span class="fstat-no" title="function not covered" >on</span>Click(t,e,i){const s=<span class="cstat-no" title="statement not covered" >e.datasetIndex,</span>n=<span class="cstat-no" title="statement not covered" >i.chart;<span class="cstat-no" title="statement not covered" ></span>n.isDatasetVisible(s)?(n.hide(s),e.hidden=!0):(n.show(s),e.hidden=!1)}</span>,onHover:null,onLeave:null,labels:{color:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.chart.options.color,</span>boxWidth:40,padding:10,<span class="fstat-no" title="function not covered" >ge</span>nerateLabels(t){const e=<span class="cstat-no" title="statement not covered" >t.data.datasets,</span>{labels:{usePointStyle:i,pointStyle:n,textAlign:o,color:a,useBorderRadius:r,borderRadius:h}}=<span class="cstat-no" title="statement not covered" >t.legend.options;<span class="cstat-no" title="statement not covered" ></span>return t._getSortedDatasetMetas().map((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const l=<span class="cstat-no" title="statement not covered" >t.controller.getStyle(i?0:void 0),</span>c=<span class="cstat-no" title="statement not covered" >(0,s.E)(l.borderWidth);<span class="cstat-no" title="statement not covered" ></span>return{text:e[t.index].label,fillStyle:l.backgroundColor,fontColor:a,hidden:!t.visible,lineCap:l.borderCapStyle,lineDash:l.borderDash,lineDashOffset:l.borderDashOffset,lineJoin:l.borderJoinStyle,lineWidth:(c.width+c.height)/4,strokeStyle:l.borderColor,pointStyle:n||l.pointStyle,rotation:l.rotation,textAlign:o||l.textAlign,borderRadius:r&amp;&amp;(h||l.borderRadius),datasetIndex:t.index}}</span>),this)}</span>},title:{color:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.chart.options.color,</span>display:!1,position:"center",text:""}},descriptors:{_scriptable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!t.startsWith("on"),</span>labels:{_scriptable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!["generateLabels","filter","sort"].includes(t)}</span>}};</span>class Ge extends xt{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.chart=t.chart,this.options=t.options,this.ctx=t.ctx,this._padding=void 0,this.top=void 0,this.bottom=void 0,this.left=void 0,this.right=void 0,this.width=void 0,this.height=void 0,this.position=void 0,this.weight=void 0,this.fullSize=void 0}<span class="fstat-no" title="function not covered" ></span>up</span>date(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if(this.left=0,this.top=0,!i.display)<span class="cstat-no" title="statement not covered" >return void(this.width=this.height=this.right=this.bottom=0);<span class="cstat-no" title="statement not covered" >t</span></span>his.width=this.right=t,this.height=this.bottom=e;c</span>onst n=<span class="cstat-no" title="statement not covered" >(0,s.b)(i.text)?i.text.length:1;<span class="cstat-no" title="statement not covered" ></span>this._padding=(0,s.E)(i.padding);c</span>onst o=<span class="cstat-no" title="statement not covered" >n*(0,s.a0)(i.font).lineHeight+this._padding.height;<span class="cstat-no" title="statement not covered" ></span>this.isHorizontal()?this.height=o:this.width=o}<span class="fstat-no" title="function not covered" ></span>is</span>Horizontal(){const t=<span class="cstat-no" title="statement not covered" >this.options.position;<span class="cstat-no" title="statement not covered" ></span>return"top"===t||"bottom"===t}<span class="fstat-no" title="function not covered" ></span>_d</span>rawArgs(t){const{top:e,left:i,bottom:n,right:o,options:a}=<span class="cstat-no" title="statement not covered" >this,</span>r=<span class="cstat-no" title="statement not covered" >a.align;</span>let h,l,c,d=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return this.isHorizontal()?(l=(0,s.a2)(r,i,o),c=e+t,h=o-i):("left"===a.position?(l=i+t,c=(0,s.a2)(r,n,e),d=-.5*s.P):(l=o-t,c=(0,s.a2)(r,e,n),d=.5*s.P),h=n-e),{titleX:l,titleY:c,maxWidth:h,rotation:d}}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(){const t=<span class="cstat-no" title="statement not covered" >this.ctx,</span>e=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if(!e.display)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >(0,s.a0)(e.font),</span>n=<span class="cstat-no" title="statement not covered" >i.lineHeight/2+this._padding.top,</span>{titleX:o,titleY:a,maxWidth:r,rotation:h}=<span class="cstat-no" title="statement not covered" >this._drawArgs(n);<span class="cstat-no" title="statement not covered" ></span>(0,s.Z)(t,e.text,0,0,i,{color:e.color,maxWidth:r,rotation:h,textAlign:(0,s.a1)(e.align),textBaseline:"middle",translation:[o,a]})}</span>}var Ke=<span class="cstat-no" title="statement not covered" >{id:"title",_element:Ge,<span class="fstat-no" title="function not covered" >st</span>art(t,e,i){<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >new Ge({ctx:t.ctx,options:e,chart:t});<span class="cstat-no" title="statement not covered" ></span>Z.configure(t,i,e),Z.addBox(t,i),t.titleBlock=i}</span>(t,i)}</span>,<span class="fstat-no" title="function not covered" >st</span>op(t){const e=<span class="cstat-no" title="statement not covered" >t.titleBlock;<span class="cstat-no" title="statement not covered" ></span>Z.removeBox(t,e),delete t.titleBlock}</span>,<span class="fstat-no" title="function not covered" >be</span>foreUpdate(t,e,i){const s=<span class="cstat-no" title="statement not covered" >t.titleBlock;<span class="cstat-no" title="statement not covered" ></span>Z.configure(t,s,i),s.options=i}</span>,defaults:{align:"center",display:!1,font:{weight:"bold"},fullSize:!0,padding:10,position:"top",text:"",weight:2e3},defaultRoutes:{color:"color"},descriptors:{_scriptable:!0,_indexable:!1}};<span class="cstat-no" title="statement not covered" ></span>new WeakMap;c</span>onst Je=<span class="cstat-no" title="statement not covered" >{<span class="fstat-no" title="function not covered" >av</span>erage(t){<span class="cstat-no" title="statement not covered" >if(!t.length)<span class="cstat-no" title="statement not covered" >return!1;l</span></span>et e,i,s=<span class="cstat-no" title="statement not covered" >new Set,</span>n=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(e=0,i=t.length;e&lt;i;++e){const i=<span class="cstat-no" title="statement not covered" >t[e].element;<span class="cstat-no" title="statement not covered" ></span>if(i&amp;&amp;i.hasValue()){const t=<span class="cstat-no" title="statement not covered" >i.tooltipPosition();<span class="cstat-no" title="statement not covered" ></span>s.add(t.x),n+=t.y,++o}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(0===o||0===s.size)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span>eturn{x:[...s].reduce((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t+e)</span>)/s.size,y:n/o}}</span>,<span class="fstat-no" title="function not covered" >ne</span>arest(t,e){<span class="cstat-no" title="statement not covered" >if(!t.length)<span class="cstat-no" title="statement not covered" >return!1;l</span></span>et i,n,o,a=<span class="cstat-no" title="statement not covered" >e.x,</span>r=<span class="cstat-no" title="statement not covered" >e.y,</span>h=<span class="cstat-no" title="statement not covered" >Number.POSITIVE_INFINITY;<span class="cstat-no" title="statement not covered" ></span>for(i=0,n=t.length;i&lt;n;++i){const n=<span class="cstat-no" title="statement not covered" >t[i].element;<span class="cstat-no" title="statement not covered" ></span>if(n&amp;&amp;n.hasValue()){const t=<span class="cstat-no" title="statement not covered" >n.getCenterPoint(),</span>i=<span class="cstat-no" title="statement not covered" >(0,s.aF)(e,t);<span class="cstat-no" title="statement not covered" ></span>i&lt;h&amp;&amp;(h=i,o=n)}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(o){const t=<span class="cstat-no" title="statement not covered" >o.tooltipPosition();<span class="cstat-no" title="statement not covered" ></span>a=t.x,r=t.y}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{x:a,y:r}}</span>};</span>function <span class="fstat-no" title="function not covered" >qe(</span>t,e){<span class="cstat-no" title="statement not covered" >return e&amp;&amp;((0,s.b)(e)?Array.prototype.push.apply(t,e):t.push(e)),t}</span>function <span class="fstat-no" title="function not covered" >Ze(</span>t){<span class="cstat-no" title="statement not covered" >return("string"===typeof t||t instanceof String)&amp;&amp;t.indexOf("\n")&gt;-1?t.split("\n"):t}</span>function <span class="fstat-no" title="function not covered" >ti(</span>t,e){const{element:i,datasetIndex:s,index:n}=<span class="cstat-no" title="statement not covered" >e,</span>o=<span class="cstat-no" title="statement not covered" >t.getDatasetMeta(s).controller,</span>{label:a,value:r}=<span class="cstat-no" title="statement not covered" >o.getLabelAndValue(n);<span class="cstat-no" title="statement not covered" ></span>return{chart:t,label:a,parsed:o.getParsed(n),raw:t.data.datasets[s].data[n],formattedValue:r,dataset:o.getDataset(),dataIndex:n,datasetIndex:s,element:i}}</span>function <span class="fstat-no" title="function not covered" >ei(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >t.chart.ctx,</span>{body:n,footer:o,title:a}=<span class="cstat-no" title="statement not covered" >t,</span>{boxWidth:r,boxHeight:h}=<span class="cstat-no" title="statement not covered" >e,</span>l=<span class="cstat-no" title="statement not covered" >(0,s.a0)(e.bodyFont),</span>c=<span class="cstat-no" title="statement not covered" >(0,s.a0)(e.titleFont),</span>d=<span class="cstat-no" title="statement not covered" >(0,s.a0)(e.footerFont),</span>u=<span class="cstat-no" title="statement not covered" >a.length,</span>g=<span class="cstat-no" title="statement not covered" >o.length,</span>f=<span class="cstat-no" title="statement not covered" >n.length,</span>p=<span class="cstat-no" title="statement not covered" >(0,s.E)(e.padding);</span>let x=<span class="cstat-no" title="statement not covered" >p.height,</span>m=<span class="cstat-no" title="statement not covered" >0,</span>b=<span class="cstat-no" title="statement not covered" >n.reduce((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t+e.before.length+e.lines.length+e.after.length)</span>,0);<span class="cstat-no" title="statement not covered" ></span>if(b+=t.beforeBody.length+t.afterBody.length,u&amp;&amp;(x+=u*c.lineHeight+(u-1)*e.titleSpacing+e.titleMarginBottom),b){<span class="cstat-no" title="statement not covered" >x+=f*(e.displayColors?Math.max(h,l.lineHeight):l.lineHeight)+(b-f)*l.lineHeight+(b-1)*e.bodySpacing}<span class="cstat-no" title="statement not covered" ></span>g</span>&amp;&amp;(x+=e.footerMarginTop+g*d.lineHeight+(g-1)*e.footerSpacing);l</span>et _=<span class="cstat-no" title="statement not covered" >0;</span>const v=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >m=Math.max(m,i.measureText(t).width+_)}</span>;<span class="cstat-no" title="statement not covered" ></span>return i.save(),i.font=c.string,(0,s.F)(t.title,v),i.font=l.string,(0,s.F)(t.beforeBody.concat(t.afterBody),v),_=e.displayColors?r+2+e.boxPadding:0,(0,s.F)(n,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >(0,s.F)(t.before,v),(0,s.F)(t.lines,v),(0,s.F)(t.after,v)}</span>)),_=0,i.font=d.string,(0,s.F)(t.footer,v),i.restore(),m+=p.width,{width:m,height:x}}</span>function <span class="fstat-no" title="function not covered" >ii(</span>t,e,i,s){const{x:n,width:o}=<span class="cstat-no" title="statement not covered" >i,</span>{width:a,chartArea:{left:r,right:h}}=<span class="cstat-no" title="statement not covered" >t;</span>let l=<span class="cstat-no" title="statement not covered" >"center";<span class="cstat-no" title="statement not covered" ></span>return"center"===s?l=n&lt;=(r+h)/2?"left":"right":n&lt;=o/2?l="left":n&gt;=a-o/2&amp;&amp;(l="right"),<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i,s){const{x:n,width:o}=<span class="cstat-no" title="statement not covered" >s,</span>a=<span class="cstat-no" title="statement not covered" >i.caretSize+i.caretPadding;<span class="cstat-no" title="statement not covered" ></span>return"left"===t&amp;&amp;n+o+a&gt;e.width||"right"===t&amp;&amp;n-o-a&lt;0||void 0}</span>(l,t,e,i)&amp;&amp;(l="center"),l}</span>function <span class="fstat-no" title="function not covered" >si(</span>t,e,i){const s=<span class="cstat-no" title="statement not covered" >i.yAlign||e.yAlign||<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const{y:i,height:s}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return i&lt;s/2?"top":i&gt;t.height-s/2?"bottom":"center"}</span>(t,i);<span class="cstat-no" title="statement not covered" ></span>return{xAlign:i.xAlign||e.xAlign||ii(t,e,i,s),yAlign:s}}</span>function <span class="fstat-no" title="function not covered" >ni(</span>t,e,i,n){const{caretSize:o,caretPadding:a,cornerRadius:r}=<span class="cstat-no" title="statement not covered" >t,</span>{xAlign:h,yAlign:l}=<span class="cstat-no" title="statement not covered" >i,</span>c=<span class="cstat-no" title="statement not covered" >o+a,</span>{topLeft:d,topRight:u,bottomLeft:g,bottomRight:f}=<span class="cstat-no" title="statement not covered" >(0,s.ay)(r);</span>let p=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){let{x:i,width:s}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return"right"===e?i-=s:"center"===e&amp;&amp;(i-=s/2),i}</span>(e,h);</span>const x=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,i){let{y:s,height:n}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return"top"===e?s+=i:s-="bottom"===e?n+i:n/2,s}</span>(e,l,c);<span class="cstat-no" title="statement not covered" ></span>return"center"===l?"left"===h?p+=c:"right"===h&amp;&amp;(p-=c):"left"===h?p-=Math.max(d,g)+o:"right"===h&amp;&amp;(p+=Math.max(u,f)+o),{x:(0,s.S)(p,0,n.width-e.width),y:(0,s.S)(x,0,n.height-e.height)}}</span>function <span class="fstat-no" title="function not covered" >oi(</span>t,e,i){const n=<span class="cstat-no" title="statement not covered" >(0,s.E)(i.padding);<span class="cstat-no" title="statement not covered" ></span>return"center"===e?t.x+t.width/2:"right"===e?t.x+t.width-n.right:t.x+n.left}</span>function <span class="fstat-no" title="function not covered" >ai(</span>t){<span class="cstat-no" title="statement not covered" >return qe([],Ze(t))}</span>function <span class="fstat-no" title="function not covered" >ri(</span>t,e){const i=<span class="cstat-no" title="statement not covered" >e&amp;&amp;e.dataset&amp;&amp;e.dataset.tooltip&amp;&amp;e.dataset.tooltip.callbacks;<span class="cstat-no" title="statement not covered" ></span>return i?t.override(i):t}</span>const hi=<span class="cstat-no" title="statement not covered" >{beforeTitle:s.aG,<span class="fstat-no" title="function not covered" >ti</span>tle(t){<span class="cstat-no" title="statement not covered" >if(t.length&gt;0){const e=<span class="cstat-no" title="statement not covered" >t[0],</span>i=<span class="cstat-no" title="statement not covered" >e.chart.data.labels,</span>s=<span class="cstat-no" title="statement not covered" >i?i.length:0;<span class="cstat-no" title="statement not covered" ></span>if(this&amp;&amp;this.options&amp;&amp;"dataset"===this.options.mode)<span class="cstat-no" title="statement not covered" >return e.dataset.label||"";<span class="cstat-no" title="statement not covered" >i</span></span>f(e.label)<span class="cstat-no" title="statement not covered" >return e.label;<span class="cstat-no" title="statement not covered" >i</span></span>f(s&gt;0&amp;&amp;e.dataIndex&lt;s)<span class="cstat-no" title="statement not covered" >return i[e.dataIndex]}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn""}</span>,afterTitle:s.aG,beforeBody:s.aG,beforeLabel:s.aG,<span class="fstat-no" title="function not covered" >la</span>bel(t){<span class="cstat-no" title="statement not covered" >if(this&amp;&amp;this.options&amp;&amp;"dataset"===this.options.mode)<span class="cstat-no" title="statement not covered" >return t.label+": "+t.formattedValue||t.formattedValue;l</span></span>et e=<span class="cstat-no" title="statement not covered" >t.dataset.label||"";<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;(e+=": ");c</span>onst i=<span class="cstat-no" title="statement not covered" >t.formattedValue;<span class="cstat-no" title="statement not covered" ></span>return(0,s.k)(i)||(e+=i),e}</span>,<span class="fstat-no" title="function not covered" >la</span>belColor(t){const e=<span class="cstat-no" title="statement not covered" >t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);<span class="cstat-no" title="statement not covered" ></span>return{borderColor:e.borderColor,backgroundColor:e.backgroundColor,borderWidth:e.borderWidth,borderDash:e.borderDash,borderDashOffset:e.borderDashOffset,borderRadius:0}}</span>,<span class="fstat-no" title="function not covered" >la</span>belTextColor(){<span class="cstat-no" title="statement not covered" >return this.options.bodyColor}</span>,<span class="fstat-no" title="function not covered" >la</span>belPointStyle(t){const e=<span class="cstat-no" title="statement not covered" >t.chart.getDatasetMeta(t.datasetIndex).controller.getStyle(t.dataIndex);<span class="cstat-no" title="statement not covered" ></span>return{pointStyle:e.pointStyle,rotation:e.rotation}}</span>,afterLabel:s.aG,afterBody:s.aG,beforeFooter:s.aG,footer:s.aG,afterFooter:s.aG};</span>function <span class="fstat-no" title="function not covered" >li(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >t[e].call(i,s);<span class="cstat-no" title="statement not covered" ></span>return"undefined"===typeof n?hi[e].call(i,s):n}</span>class ci extends xt{static positioners=<span class="cstat-no" title="statement not covered" >Je;<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(),this.opacity=0,this._active=[],this._eventPosition=void 0,this._size=void 0,this._cachedAnimations=void 0,this._tooltipItems=[],this.$animations=void 0,this.$context=void 0,this.chart=t.chart,this.options=t.options,this.dataPoints=void 0,this.title=void 0,this.beforeBody=void 0,this.body=void 0,this.afterBody=void 0,this.footer=void 0,this.xAlign=void 0,this.yAlign=void 0,this.x=void 0,this.y=void 0,this.height=void 0,this.width=void 0,this.caretX=void 0,this.caretY=void 0,this.labelColors=void 0,this.labelPointStyles=void 0,this.labelTextColors=void 0}<span class="fstat-no" title="function not covered" ></span>in</span>itialize(t){<span class="cstat-no" title="statement not covered" >this.options=t,this._cachedAnimations=void 0,this.$context=void 0}<span class="fstat-no" title="function not covered" ></span>_r</span>esolveAnimations(){const t=<span class="cstat-no" title="statement not covered" >this._cachedAnimations;<span class="cstat-no" title="statement not covered" ></span>if(t)<span class="cstat-no" title="statement not covered" >return t;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.chart,</span>i=<span class="cstat-no" title="statement not covered" >this.options.setContext(this.getContext()),</span>s=<span class="cstat-no" title="statement not covered" >i.enabled&amp;&amp;e.options.animation&amp;&amp;i.animations,</span>n=<span class="cstat-no" title="statement not covered" >new l(this.chart,s);<span class="cstat-no" title="statement not covered" ></span>return s._cacheable&amp;&amp;(this._cachedAnimations=Object.freeze(n)),n}<span class="fstat-no" title="function not covered" ></span>ge</span>tContext(){<span class="cstat-no" title="statement not covered" >return this.$context||(this.$context=(t=this.chart.getContext(),e=this,i=this._tooltipItems,(0,s.j)(t,{tooltip:e,tooltipItems:i,type:"tooltip"})));v</span>ar t,e,i}<span class="fstat-no" title="function not covered" >ge</span>tTitle(t,e){const{callbacks:i}=<span class="cstat-no" title="statement not covered" >e,</span>s=<span class="cstat-no" title="statement not covered" >li(i,"beforeTitle",this,t),</span>n=<span class="cstat-no" title="statement not covered" >li(i,"title",this,t),</span>o=<span class="cstat-no" title="statement not covered" >li(i,"afterTitle",this,t);</span>let a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return a=qe(a,Ze(s)),a=qe(a,Ze(n)),a=qe(a,Ze(o)),a}<span class="fstat-no" title="function not covered" ></span>ge</span>tBeforeBody(t,e){<span class="cstat-no" title="statement not covered" >return ai(li(e.callbacks,"beforeBody",this,t))}<span class="fstat-no" title="function not covered" ></span>ge</span>tBody(t,e){const{callbacks:i}=<span class="cstat-no" title="statement not covered" >e,</span>n=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return(0,s.F)(t,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >{before:[],lines:[],after:[]},</span>s=<span class="cstat-no" title="statement not covered" >ri(i,t);<span class="cstat-no" title="statement not covered" ></span>qe(e.before,Ze(li(s,"beforeLabel",this,t))),qe(e.lines,li(s,"label",this,t)),qe(e.after,Ze(li(s,"afterLabel",this,t))),n.push(e)}</span>)),n}<span class="fstat-no" title="function not covered" ></span>ge</span>tAfterBody(t,e){<span class="cstat-no" title="statement not covered" >return ai(li(e.callbacks,"afterBody",this,t))}<span class="fstat-no" title="function not covered" ></span>ge</span>tFooter(t,e){const{callbacks:i}=<span class="cstat-no" title="statement not covered" >e,</span>s=<span class="cstat-no" title="statement not covered" >li(i,"beforeFooter",this,t),</span>n=<span class="cstat-no" title="statement not covered" >li(i,"footer",this,t),</span>o=<span class="cstat-no" title="statement not covered" >li(i,"afterFooter",this,t);</span>let a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return a=qe(a,Ze(s)),a=qe(a,Ze(n)),a=qe(a,Ze(o)),a}<span class="fstat-no" title="function not covered" ></span>_c</span>reateItems(t){const e=<span class="cstat-no" title="statement not covered" >this._active,</span>i=<span class="cstat-no" title="statement not covered" >this.chart.data,</span>n=<span class="cstat-no" title="statement not covered" >[],</span>o=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >[];</span>let r,h,l=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(r=0,h=e.length;r&lt;h;++r)<span class="cstat-no" title="statement not covered" >l.push(ti(this.chart,e[r]));<span class="cstat-no" title="statement not covered" >r</span></span>eturn t.filter&amp;&amp;(l=l.filter((<span class="fstat-no" title="function not covered" >(e</span>,s,n)=&gt;<span class="cstat-no" title="statement not covered" >t.filter(e,s,n,i))</span>)),t.itemSort&amp;&amp;(l=l.sort((<span class="fstat-no" title="function not covered" >(e</span>,s)=&gt;<span class="cstat-no" title="statement not covered" >t.itemSort(e,s,i))</span>)),(0,s.F)(l,(<span class="fstat-no" title="function not covered" >e=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >ri(t.callbacks,e);<span class="cstat-no" title="statement not covered" ></span>n.push(li(i,"labelColor",this,e)),o.push(li(i,"labelPointStyle",this,e)),a.push(li(i,"labelTextColor",this,e))}</span>)),this.labelColors=n,this.labelPointStyles=o,this.labelTextColors=a,this.dataPoints=l,l}<span class="fstat-no" title="function not covered" ></span>up</span>date(t,e){const i=<span class="cstat-no" title="statement not covered" >this.options.setContext(this.getContext()),</span>s=<span class="cstat-no" title="statement not covered" >this._active;</span>let n,o=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(s.length){const t=<span class="cstat-no" title="statement not covered" >Je[i.position].call(this,s,this._eventPosition);<span class="cstat-no" title="statement not covered" ></span>o=this._createItems(i),this.title=this.getTitle(o,i),this.beforeBody=this.getBeforeBody(o,i),this.body=this.getBody(o,i),this.afterBody=this.getAfterBody(o,i),this.footer=this.getFooter(o,i);c</span>onst e=<span class="cstat-no" title="statement not covered" >this._size=ei(this,i),</span>a=<span class="cstat-no" title="statement not covered" >Object.assign({},t,e),</span>r=<span class="cstat-no" title="statement not covered" >si(this.chart,i,a),</span>h=<span class="cstat-no" title="statement not covered" >ni(i,a,r,this.chart);<span class="cstat-no" title="statement not covered" ></span>this.xAlign=r.xAlign,this.yAlign=r.yAlign,n={opacity:1,x:h.x,y:h.y,width:e.width,height:e.height,caretX:t.x,caretY:t.y}}</span>else <span class="cstat-no" title="statement not covered" >0!==this.opacity&amp;&amp;(n={opacity:0});<span class="cstat-no" title="statement not covered" >t</span></span>his._tooltipItems=o,this.$context=void 0,n&amp;&amp;this._resolveAnimations().update(this,n),t&amp;&amp;i.external&amp;&amp;i.external.call(this,{chart:this.chart,tooltip:this,replay:e})}<span class="fstat-no" title="function not covered" ></span>dr</span>awCaret(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >this.getCaretPosition(t,i,s);<span class="cstat-no" title="statement not covered" ></span>e.lineTo(n.x1,n.y1),e.lineTo(n.x2,n.y2),e.lineTo(n.x3,n.y3)}<span class="fstat-no" title="function not covered" ></span>ge</span>tCaretPosition(t,e,i){const{xAlign:n,yAlign:o}=<span class="cstat-no" title="statement not covered" >this,</span>{caretSize:a,cornerRadius:r}=<span class="cstat-no" title="statement not covered" >i,</span>{topLeft:h,topRight:l,bottomLeft:c,bottomRight:d}=<span class="cstat-no" title="statement not covered" >(0,s.ay)(r),</span>{x:u,y:g}=<span class="cstat-no" title="statement not covered" >t,</span>{width:f,height:p}=<span class="cstat-no" title="statement not covered" >e;</span>let x,m,b,_,v,y;<span class="cstat-no" title="statement not covered" >return"center"===o?(v=g+p/2,"left"===n?(x=u,m=x-a,_=v+a,y=v-a):(x=u+f,m=x+a,_=v-a,y=v+a),b=x):(m="left"===n?u+Math.max(h,c)+a:"right"===n?u+f-Math.max(l,d)-a:this.caretX,"top"===o?(_=g,v=_-a,x=m-a,b=m+a):(_=g+p,v=_+a,x=m+a,b=m-a),y=_),{x1:x,x2:m,x3:b,y1:_,y2:v,y3:y}}<span class="fstat-no" title="function not covered" ></span>dr</span>awTitle(t,e,i){const n=<span class="cstat-no" title="statement not covered" >this.title,</span>o=<span class="cstat-no" title="statement not covered" >n.length;</span>let a,r,h;<span class="cstat-no" title="statement not covered" >if(o){const l=<span class="cstat-no" title="statement not covered" >(0,s.aA)(i.rtl,this.x,this.width);<span class="cstat-no" title="statement not covered" ></span>for(t.x=oi(this,i.titleAlign,i),e.textAlign=l.textAlign(i.titleAlign),e.textBaseline="middle",a=(0,s.a0)(i.titleFont),r=i.titleSpacing,e.fillStyle=i.titleColor,e.font=a.string,h=0;h&lt;o;++h)<span class="cstat-no" title="statement not covered" >e.fillText(n[h],l.x(t.x),t.y+a.lineHeight/2),t.y+=a.lineHeight+r,h+1===o&amp;&amp;(t.y+=i.titleMarginBottom-r)}</span></span>}<span class="fstat-no" title="function not covered" ></span>_d</span>rawColorBox(t,e,i,n,o){const a=<span class="cstat-no" title="statement not covered" >this.labelColors[i],</span>r=<span class="cstat-no" title="statement not covered" >this.labelPointStyles[i],</span>{boxHeight:h,boxWidth:l}=<span class="cstat-no" title="statement not covered" >o,</span>c=<span class="cstat-no" title="statement not covered" >(0,s.a0)(o.bodyFont),</span>d=<span class="cstat-no" title="statement not covered" >oi(this,"left",o),</span>u=<span class="cstat-no" title="statement not covered" >n.x(d),</span>g=<span class="cstat-no" title="statement not covered" >h&lt;c.lineHeight?(c.lineHeight-h)/2:0,</span>f=<span class="cstat-no" title="statement not covered" >e.y+g;<span class="cstat-no" title="statement not covered" ></span>if(o.usePointStyle){const e=<span class="cstat-no" title="statement not covered" >{radius:Math.min(l,h)/2,pointStyle:r.pointStyle,rotation:r.rotation,borderWidth:1},</span>i=<span class="cstat-no" title="statement not covered" >n.leftForLtr(u,l)+l/2,</span>c=<span class="cstat-no" title="statement not covered" >f+h/2;<span class="cstat-no" title="statement not covered" ></span>t.strokeStyle=o.multiKeyBackground,t.fillStyle=o.multiKeyBackground,(0,s.av)(t,e,i,c),t.strokeStyle=a.borderColor,t.fillStyle=a.backgroundColor,(0,s.av)(t,e,i,c)}</span>else{<span class="cstat-no" title="statement not covered" >t.lineWidth=(0,s.i)(a.borderWidth)?Math.max(...Object.values(a.borderWidth)):a.borderWidth||1,t.strokeStyle=a.borderColor,t.setLineDash(a.borderDash||[]),t.lineDashOffset=a.borderDashOffset||0;c</span>onst e=<span class="cstat-no" title="statement not covered" >n.leftForLtr(u,l),</span>i=<span class="cstat-no" title="statement not covered" >n.leftForLtr(n.xPlus(u,1),l-2),</span>r=<span class="cstat-no" title="statement not covered" >(0,s.ay)(a.borderRadius);<span class="cstat-no" title="statement not covered" ></span>Object.values(r).some((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >0!==t)</span>)?(t.beginPath(),t.fillStyle=o.multiKeyBackground,(0,s.aw)(t,{x:e,y:f,w:l,h:h,radius:r}),t.fill(),t.stroke(),t.fillStyle=a.backgroundColor,t.beginPath(),(0,s.aw)(t,{x:i,y:f+1,w:l-2,h:h-2,radius:r}),t.fill()):(t.fillStyle=o.multiKeyBackground,t.fillRect(e,f,l,h),t.strokeRect(e,f,l,h),t.fillStyle=a.backgroundColor,t.fillRect(i,f+1,l-2,h-2))}<span class="cstat-no" title="statement not covered" ></span>t</span>.fillStyle=this.labelTextColors[i]}<span class="fstat-no" title="function not covered" ></span>dr</span>awBody(t,e,i){const{body:n}=<span class="cstat-no" title="statement not covered" >this,</span>{bodySpacing:o,bodyAlign:a,displayColors:r,boxHeight:h,boxWidth:l,boxPadding:c}=<span class="cstat-no" title="statement not covered" >i,</span>d=<span class="cstat-no" title="statement not covered" >(0,s.a0)(i.bodyFont);</span>let u=<span class="cstat-no" title="statement not covered" >d.lineHeight,</span>g=<span class="cstat-no" title="statement not covered" >0;</span>const f=<span class="cstat-no" title="statement not covered" >(0,s.aA)(i.rtl,this.x,this.width),</span>p=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(i){<span class="cstat-no" title="statement not covered" >e.fillText(i,f.x(t.x+g),t.y+u/2),t.y+=u+o}</span>,</span>x=<span class="cstat-no" title="statement not covered" >f.textAlign(a);</span>let m,b,_,v,y,M,w;<span class="cstat-no" title="statement not covered" >for(e.textAlign=a,e.textBaseline="middle",e.font=d.string,t.x=oi(this,x,i),e.fillStyle=i.bodyColor,(0,s.F)(this.beforeBody,p),g=r&amp;&amp;"right"!==x?"center"===a?l/2+c:l+2+c:0,v=0,M=n.length;v&lt;M;++v){<span class="cstat-no" title="statement not covered" >for(m=n[v],b=this.labelTextColors[v],e.fillStyle=b,(0,s.F)(m.before,p),_=m.lines,r&amp;&amp;_.length&amp;&amp;(this._drawColorBox(e,t,v,f,i),u=Math.max(d.lineHeight,h)),y=0,w=_.length;y&lt;w;++y)<span class="cstat-no" title="statement not covered" >p(_[y]),u=d.lineHeight;<span class="cstat-no" title="statement not covered" >(</span></span>0,s.F)(m.after,p)}<span class="cstat-no" title="statement not covered" ></span>g</span>=0,u=d.lineHeight,(0,s.F)(this.afterBody,p),t.y-=o}<span class="fstat-no" title="function not covered" ></span>dr</span>awFooter(t,e,i){const n=<span class="cstat-no" title="statement not covered" >this.footer,</span>o=<span class="cstat-no" title="statement not covered" >n.length;</span>let a,r;<span class="cstat-no" title="statement not covered" >if(o){const h=<span class="cstat-no" title="statement not covered" >(0,s.aA)(i.rtl,this.x,this.width);<span class="cstat-no" title="statement not covered" ></span>for(t.x=oi(this,i.footerAlign,i),t.y+=i.footerMarginTop,e.textAlign=h.textAlign(i.footerAlign),e.textBaseline="middle",a=(0,s.a0)(i.footerFont),e.fillStyle=i.footerColor,e.font=a.string,r=0;r&lt;o;++r)<span class="cstat-no" title="statement not covered" >e.fillText(n[r],h.x(t.x),t.y+a.lineHeight/2),t.y+=a.lineHeight+i.footerSpacing}</span></span>}<span class="fstat-no" title="function not covered" ></span>dr</span>awBackground(t,e,i,n){const{xAlign:o,yAlign:a}=<span class="cstat-no" title="statement not covered" >this,</span>{x:r,y:h}=<span class="cstat-no" title="statement not covered" >t,</span>{width:l,height:c}=<span class="cstat-no" title="statement not covered" >i,</span>{topLeft:d,topRight:u,bottomLeft:g,bottomRight:f}=<span class="cstat-no" title="statement not covered" >(0,s.ay)(n.cornerRadius);<span class="cstat-no" title="statement not covered" ></span>e.fillStyle=n.backgroundColor,e.strokeStyle=n.borderColor,e.lineWidth=n.borderWidth,e.beginPath(),e.moveTo(r+d,h),"top"===a&amp;&amp;this.drawCaret(t,e,i,n),e.lineTo(r+l-u,h),e.quadraticCurveTo(r+l,h,r+l,h+u),"center"===a&amp;&amp;"right"===o&amp;&amp;this.drawCaret(t,e,i,n),e.lineTo(r+l,h+c-f),e.quadraticCurveTo(r+l,h+c,r+l-f,h+c),"bottom"===a&amp;&amp;this.drawCaret(t,e,i,n),e.lineTo(r+g,h+c),e.quadraticCurveTo(r,h+c,r,h+c-g),"center"===a&amp;&amp;"left"===o&amp;&amp;this.drawCaret(t,e,i,n),e.lineTo(r,h+d),e.quadraticCurveTo(r,h,r+d,h),e.closePath(),e.fill(),n.borderWidth&gt;0&amp;&amp;e.stroke()}<span class="fstat-no" title="function not covered" ></span>_u</span>pdateAnimationTarget(t){const e=<span class="cstat-no" title="statement not covered" >this.chart,</span>i=<span class="cstat-no" title="statement not covered" >this.$animations,</span>s=<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.x,</span>n=<span class="cstat-no" title="statement not covered" >i&amp;&amp;i.y;<span class="cstat-no" title="statement not covered" ></span>if(s||n){const i=<span class="cstat-no" title="statement not covered" >Je[t.position].call(this,this._active,this._eventPosition);<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >this._size=ei(this,t),</span>a=<span class="cstat-no" title="statement not covered" >Object.assign({},i,this._size),</span>r=<span class="cstat-no" title="statement not covered" >si(e,t,a),</span>h=<span class="cstat-no" title="statement not covered" >ni(t,a,r,e);<span class="cstat-no" title="statement not covered" ></span>s._to===h.x&amp;&amp;n._to===h.y||(this.xAlign=r.xAlign,this.yAlign=r.yAlign,this.width=o.width,this.height=o.height,this.caretX=i.x,this.caretY=i.y,this._resolveAnimations().update(this,h))}</span>}<span class="fstat-no" title="function not covered" ></span>_w</span>illRender(){<span class="cstat-no" title="statement not covered" >return!!this.opacity}<span class="fstat-no" title="function not covered" ></span>dr</span>aw(t){const e=<span class="cstat-no" title="statement not covered" >this.options.setContext(this.getContext());</span>let i=<span class="cstat-no" title="statement not covered" >this.opacity;<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his._updateAnimationTarget(e);c</span>onst n=<span class="cstat-no" title="statement not covered" >{width:this.width,height:this.height},</span>o=<span class="cstat-no" title="statement not covered" >{x:this.x,y:this.y};<span class="cstat-no" title="statement not covered" ></span>i=Math.abs(i)&lt;.001?0:i;c</span>onst a=<span class="cstat-no" title="statement not covered" >(0,s.E)(e.padding),</span>r=<span class="cstat-no" title="statement not covered" >this.title.length||this.beforeBody.length||this.body.length||this.afterBody.length||this.footer.length;<span class="cstat-no" title="statement not covered" ></span>e.enabled&amp;&amp;r&amp;&amp;(t.save(),t.globalAlpha=i,this.drawBackground(o,t,n,e),(0,s.aB)(t,e.textDirection),o.y+=a.top,this.drawTitle(o,t,e),this.drawBody(o,t,e),this.drawFooter(o,t,e),(0,s.aD)(t,e.textDirection),t.restore())}<span class="fstat-no" title="function not covered" ></span>ge</span>tActiveElements(){<span class="cstat-no" title="statement not covered" >return this._active||[]}<span class="fstat-no" title="function not covered" ></span>se</span>tActiveElements(t,e){const i=<span class="cstat-no" title="statement not covered" >this._active,</span>n=<span class="cstat-no" title="statement not covered" >t.map((<span class="fstat-no" title="function not covered" >({</span>datasetIndex:t,index:e})=&gt;{const i=<span class="cstat-no" title="statement not covered" >this.chart.getDatasetMeta(t);<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >throw new Error("Cannot find a dataset at index "+t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn{datasetIndex:t,element:i.data[e],index:e}}</span>)),</span>o=<span class="cstat-no" title="statement not covered" >!(0,s.ai)(i,n),</span>a=<span class="cstat-no" title="statement not covered" >this._positionChanged(n,e);<span class="cstat-no" title="statement not covered" ></span>(o||a)&amp;&amp;(this._active=n,this._eventPosition=e,this._ignoreReplayEvents=!0,this.update(!0))}<span class="fstat-no" title="function not covered" ></span>ha</span>ndleEvent(t,e,i=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>{<span class="cstat-no" title="statement not covered" >if(e&amp;&amp;this._ignoreReplayEvents)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >t</span></span>his._ignoreReplayEvents=!1;c</span>onst n=<span class="cstat-no" title="statement not covered" >this.options,</span>o=<span class="cstat-no" title="statement not covered" >this._active||[],</span>a=<span class="cstat-no" title="statement not covered" >this._getActiveElements(t,o,e,i),</span>r=<span class="cstat-no" title="statement not covered" >this._positionChanged(a,t),</span>h=<span class="cstat-no" title="statement not covered" >e||!(0,s.ai)(a,o)||r;<span class="cstat-no" title="statement not covered" ></span>return h&amp;&amp;(this._active=a,(n.enabled||n.external)&amp;&amp;(this._eventPosition={x:t.x,y:t.y},this.update(!0,e))),h}<span class="fstat-no" title="function not covered" ></span>_g</span>etActiveElements(t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if("mouseout"===t.type)<span class="cstat-no" title="statement not covered" >return[];<span class="cstat-no" title="statement not covered" >i</span></span>f(!s)<span class="cstat-no" title="statement not covered" >return e.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this.chart.data.datasets[t.datasetIndex]&amp;&amp;void 0!==this.chart.getDatasetMeta(t.datasetIndex).controller.getParsed(t.index))</span>);c</span></span>onst o=<span class="cstat-no" title="statement not covered" >this.chart.getElementsAtEventForMode(t,n.mode,n,i);<span class="cstat-no" title="statement not covered" ></span>return n.reverse&amp;&amp;o.reverse(),o}<span class="fstat-no" title="function not covered" ></span>_p</span>ositionChanged(t,e){const{caretX:i,caretY:s,options:n}=<span class="cstat-no" title="statement not covered" >this,</span>o=<span class="cstat-no" title="statement not covered" >Je[n.position].call(this,t,e);<span class="cstat-no" title="statement not covered" ></span>return!1!==o&amp;&amp;(i!==o.x||s!==o.y)}</span>}var di=<span class="cstat-no" title="statement not covered" >{id:"tooltip",_element:ci,positioners:Je,<span class="fstat-no" title="function not covered" >af</span>terInit(t,e,i){<span class="cstat-no" title="statement not covered" >i&amp;&amp;(t.tooltip=new ci({chart:t,options:i}))}</span>,<span class="fstat-no" title="function not covered" >be</span>foreUpdate(t,e,i){<span class="cstat-no" title="statement not covered" >t.tooltip&amp;&amp;t.tooltip.initialize(i)}</span>,<span class="fstat-no" title="function not covered" >re</span>set(t,e,i){<span class="cstat-no" title="statement not covered" >t.tooltip&amp;&amp;t.tooltip.initialize(i)}</span>,<span class="fstat-no" title="function not covered" >af</span>terDraw(t){const e=<span class="cstat-no" title="statement not covered" >t.tooltip;<span class="cstat-no" title="statement not covered" ></span>if(e&amp;&amp;e._willRender()){const i=<span class="cstat-no" title="statement not covered" >{tooltip:e};<span class="cstat-no" title="statement not covered" ></span>if(!1===t.notifyPlugins("beforeTooltipDraw",{...i,cancelable:!0}))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >e</span></span>.draw(t.ctx),t.notifyPlugins("afterTooltipDraw",i)}</span>}</span>,<span class="fstat-no" title="function not covered" >af</span>terEvent(t,e){<span class="cstat-no" title="statement not covered" >if(t.tooltip){const i=<span class="cstat-no" title="statement not covered" >e.replay;<span class="cstat-no" title="statement not covered" ></span>t.tooltip.handleEvent(e.event,i,e.inChartArea)&amp;&amp;(e.changed=!0)}</span>}</span>,defaults:{enabled:!0,external:null,position:"average",backgroundColor:"rgba(0,0,0,0.8)",titleColor:"#fff",titleFont:{weight:"bold"},titleSpacing:2,titleMarginBottom:6,titleAlign:"left",bodyColor:"#fff",bodySpacing:2,bodyFont:{},bodyAlign:"left",footerColor:"#fff",footerSpacing:2,footerMarginTop:6,footerFont:{weight:"bold"},footerAlign:"left",padding:6,caretPadding:2,caretSize:5,cornerRadius:6,boxHeight:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e.bodyFont.size,</span>boxWidth:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e.bodyFont.size,</span>multiKeyBackground:"#fff",displayColors:!0,boxPadding:0,borderColor:"rgba(0,0,0,0)",borderWidth:0,animation:{duration:400,easing:"easeOutQuart"},animations:{numbers:{type:"number",properties:["x","y","width","height","caretX","caretY"]},opacity:{easing:"linear",duration:200}},callbacks:hi},defaultRoutes:{bodyFont:"font",footerFont:"font",titleFont:"font"},descriptors:{_scriptable:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"filter"!==t&amp;&amp;"itemSort"!==t&amp;&amp;"external"!==t,</span>_indexable:!1,callbacks:{_scriptable:!1,_indexable:!1},animation:{_fallback:!1},animations:{_fallback:"animation"}},additionalOptionScopes:["interaction"]};</span>function <span class="fstat-no" title="function not covered" >ui(</span>t,e,i,s){const n=<span class="cstat-no" title="statement not covered" >t.indexOf(e);<span class="cstat-no" title="statement not covered" ></span>if(-1===n)<span class="cstat-no" title="statement not covered" >return(<span class="fstat-no" title="function not covered" >(t</span>,e,i,s)=&gt;(<span class="cstat-no" title="statement not covered" >"string"===typeof e?(i=t.push(e)-1,s.unshift({index:i,label:e})):isNaN(e)&amp;&amp;(i=null),i)</span>)(t,e,i,s);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n!==t.lastIndexOf(e)?i:n}</span>function <span class="fstat-no" title="function not covered" >gi(</span>t){const e=<span class="cstat-no" title="statement not covered" >this.getLabels();<span class="cstat-no" title="statement not covered" ></span>return t&gt;=0&amp;&amp;t&lt;e.length?e[t]:t}</span>class fi extends Dt{static id=<span class="cstat-no" title="statement not covered" >"category";</span>static defaults=<span class="cstat-no" title="statement not covered" >{ticks:{callback:gi}};<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t),this._startValue=void 0,this._valueRange=0,this._addedLabels=[]}<span class="fstat-no" title="function not covered" ></span>in</span>it(t){const e=<span class="cstat-no" title="statement not covered" >this._addedLabels;<span class="cstat-no" title="statement not covered" ></span>if(e.length){const t=<span class="cstat-no" title="statement not covered" >this.getLabels();<span class="cstat-no" title="statement not covered" ></span>for(const{index:i,label:s}of e)<span class="cstat-no" title="statement not covered" >t[i]===s&amp;&amp;t.splice(i,1);<span class="cstat-no" title="statement not covered" >t</span></span>his._addedLabels=[]}<span class="cstat-no" title="statement not covered" ></span>s</span>uper.init(t)}<span class="fstat-no" title="function not covered" ></span>pa</span>rse(t,e){<span class="cstat-no" title="statement not covered" >if((0,s.k)(t))<span class="cstat-no" title="statement not covered" >return null;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >this.getLabels();<span class="cstat-no" title="statement not covered" ></span>return(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >null===t?null:(0,s.S)(Math.round(t),0,e))</span>(e=isFinite(e)&amp;&amp;i[e]===t?e:ui(i,t,(0,s.v)(e,t),this._addedLabels),i.length-1)}<span class="fstat-no" title="function not covered" ></span>de</span>termineDataLimits(){const{minDefined:t,maxDefined:e}=<span class="cstat-no" title="statement not covered" >this.getUserBounds();</span>let{min:i,max:s}=<span class="cstat-no" title="statement not covered" >this.getMinMax(!0);<span class="cstat-no" title="statement not covered" ></span>"ticks"===this.options.bounds&amp;&amp;(t||(i=0),e||(s=this.getLabels().length-1)),this.min=i,this.max=s}<span class="fstat-no" title="function not covered" ></span>bu</span>ildTicks(){const t=<span class="cstat-no" title="statement not covered" >this.min,</span>e=<span class="cstat-no" title="statement not covered" >this.max,</span>i=<span class="cstat-no" title="statement not covered" >this.options.offset,</span>s=<span class="cstat-no" title="statement not covered" >[];</span>let n=<span class="cstat-no" title="statement not covered" >this.getLabels();<span class="cstat-no" title="statement not covered" ></span>n=0===t&amp;&amp;e===n.length-1?n:n.slice(t,e+1),this._valueRange=Math.max(n.length-(i?0:1),1),this._startValue=this.min-(i?.5:0);<span class="cstat-no" title="statement not covered" >f</span>or(let o=<span class="cstat-no" title="statement not covered" >t;</span>o&lt;=e;o++)<span class="cstat-no" title="statement not covered" >s.push({value:o});<span class="cstat-no" title="statement not covered" >r</span></span>eturn s}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelForValue(t){<span class="cstat-no" title="statement not covered" >return gi.call(this,t)}<span class="fstat-no" title="function not covered" ></span>co</span>nfigure(){<span class="cstat-no" title="statement not covered" >super.configure(),this.isHorizontal()||(this._reversePixels=!this._reversePixels)}<span class="fstat-no" title="function not covered" ></span>ge</span>tPixelForValue(t){<span class="cstat-no" title="statement not covered" >return"number"!==typeof t&amp;&amp;(t=this.parse(t)),null===t?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}<span class="fstat-no" title="function not covered" ></span>ge</span>tPixelForTick(t){const e=<span class="cstat-no" title="statement not covered" >this.ticks;<span class="cstat-no" title="statement not covered" ></span>return t&lt;0||t&gt;e.length-1?null:this.getPixelForValue(e[t].value)}<span class="fstat-no" title="function not covered" ></span>ge</span>tValueForPixel(t){<span class="cstat-no" title="statement not covered" >return Math.round(this._startValue+this.getDecimalForPixel(t)*this._valueRange)}<span class="fstat-no" title="function not covered" ></span>ge</span>tBasePixel(){<span class="cstat-no" title="statement not covered" >return this.bottom}</span>}function <span class="fstat-no" title="function not covered" >pi(</span>t,e,{horizontal:i,minRotation:n}){const o=<span class="cstat-no" title="statement not covered" >(0,s.t)(n),</span>a=<span class="cstat-no" title="statement not covered" >(i?Math.sin(o):Math.cos(o))||.001,</span>r=<span class="cstat-no" title="statement not covered" >.75*e*(""+t).length;<span class="cstat-no" title="statement not covered" ></span>return Math.min(e/a,r)}</span>class xi extends Dt{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t),this.start=void 0,this.end=void 0,this._startValue=void 0,this._endValue=void 0,this._valueRange=0}<span class="fstat-no" title="function not covered" ></span>pa</span>rse(t,e){<span class="cstat-no" title="statement not covered" >return(0,s.k)(t)||("number"===typeof t||t instanceof Number)&amp;&amp;!isFinite(+t)?null:+t}<span class="fstat-no" title="function not covered" ></span>ha</span>ndleTickRangeOptions(){const{beginAtZero:t}=<span class="cstat-no" title="statement not covered" >this.options,</span>{minDefined:e,maxDefined:i}=<span class="cstat-no" title="statement not covered" >this.getUserBounds();</span>let{min:n,max:o}=<span class="cstat-no" title="statement not covered" >this;</span>const a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >n=e?n:t,</span></span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >o=i?o:t;<span class="cstat-no" title="statement not covered" ></span></span>if(t){const t=<span class="cstat-no" title="statement not covered" >(0,s.s)(n),</span>e=<span class="cstat-no" title="statement not covered" >(0,s.s)(o);<span class="cstat-no" title="statement not covered" ></span>t&lt;0&amp;&amp;e&lt;0?r(0):t&gt;0&amp;&amp;e&gt;0&amp;&amp;a(0)}<span class="cstat-no" title="statement not covered" ></span>i</span>f(n===o){let e=<span class="cstat-no" title="statement not covered" >0===o?1:Math.abs(.05*o);<span class="cstat-no" title="statement not covered" ></span>r(o+e),t||a(n-e)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.min=n,this.max=o}<span class="fstat-no" title="function not covered" ></span>ge</span>tTickLimit(){const t=<span class="cstat-no" title="statement not covered" >this.options.ticks;</span>let e,{maxTicksLimit:i,stepSize:s}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return s?(e=Math.ceil(this.max/s)-Math.floor(this.min/s)+1,e&gt;1e3&amp;&amp;(console.warn(`scales.${this.id}.ticks.stepSize: ${s} would result generating up to ${e} ticks. Limiting to 1000.`),e=1e3)):(e=this.computeTickLimit(),i=i||11),i&amp;&amp;(e=Math.min(i,e)),e}<span class="fstat-no" title="function not covered" ></span>co</span>mputeTickLimit(){<span class="cstat-no" title="statement not covered" >return Number.POSITIVE_INFINITY}<span class="fstat-no" title="function not covered" ></span>bu</span>ildTicks(){const t=<span class="cstat-no" title="statement not covered" >this.options,</span>e=<span class="cstat-no" title="statement not covered" >t.ticks;</span>let i=<span class="cstat-no" title="statement not covered" >this.getTickLimit();<span class="cstat-no" title="statement not covered" ></span>i=Math.max(2,i);c</span>onst n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const i=<span class="cstat-no" title="statement not covered" >[],</span>{bounds:n,step:o,min:a,max:r,precision:h,count:l,maxTicks:c,maxDigits:d,includeBounds:u}=<span class="cstat-no" title="statement not covered" >t,</span>g=<span class="cstat-no" title="statement not covered" >o||1,</span>f=<span class="cstat-no" title="statement not covered" >c-1,</span>{min:p,max:x}=<span class="cstat-no" title="statement not covered" >e,</span>m=<span class="cstat-no" title="statement not covered" >!(0,s.k)(a),</span>b=<span class="cstat-no" title="statement not covered" >!(0,s.k)(r),</span>_=<span class="cstat-no" title="statement not covered" >!(0,s.k)(l),</span>v=<span class="cstat-no" title="statement not covered" >(x-p)/(d+1);</span>let y,M,w,k,S=<span class="cstat-no" title="statement not covered" >(0,s.aI)((x-p)/f/g)*g;<span class="cstat-no" title="statement not covered" ></span>if(S&lt;1e-14&amp;&amp;!m&amp;&amp;!b)<span class="cstat-no" title="statement not covered" >return[{value:p},{value:x}];<span class="cstat-no" title="statement not covered" >k</span></span>=Math.ceil(x/S)-Math.floor(p/S),k&gt;f&amp;&amp;(S=(0,s.aI)(k*S/f/g)*g),(0,s.k)(h)||(y=Math.pow(10,h),S=Math.ceil(S*y)/y),"ticks"===n?(M=Math.floor(p/S)*S,w=Math.ceil(x/S)*S):(M=p,w=x),m&amp;&amp;b&amp;&amp;o&amp;&amp;(0,s.aJ)((r-a)/o,S/1e3)?(k=Math.round(Math.min((r-a)/S,c)),S=(r-a)/k,M=a,w=r):_?(M=m?a:M,w=b?r:w,k=l-1,S=(w-M)/k):(k=(w-M)/S,k=(0,s.aK)(k,Math.round(k),S/1e3)?Math.round(k):Math.ceil(k));c</span>onst D=<span class="cstat-no" title="statement not covered" >Math.max((0,s.aL)(S),(0,s.aL)(M));<span class="cstat-no" title="statement not covered" ></span>y=Math.pow(10,(0,s.k)(h)?D:h),M=Math.round(M*y)/y,w=Math.round(w*y)/y;l</span>et P=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(m&amp;&amp;(u&amp;&amp;M!==a?(i.push({value:a}),M&lt;a&amp;&amp;P++,(0,s.aK)(Math.round((M+P*S)*y)/y,a,pi(a,v,t))&amp;&amp;P++):M&lt;a&amp;&amp;P++);P&lt;k;++P){const t=<span class="cstat-no" title="statement not covered" >Math.round((M+P*S)*y)/y;<span class="cstat-no" title="statement not covered" ></span>if(b&amp;&amp;t&gt;r)<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >i</span></span>.push({value:t})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn b&amp;&amp;u&amp;&amp;w!==r?i.length&amp;&amp;(0,s.aK)(i[i.length-1].value,r,pi(r,v,t))?i[i.length-1].value=r:i.push({value:r}):b&amp;&amp;w!==r||i.push({value:w}),i}</span>({maxTicks:i,bounds:t.bounds,min:t.min,max:t.max,precision:e.precision,step:e.stepSize,count:e.count,maxDigits:this._maxDigits(),horizontal:this.isHorizontal(),minRotation:e.minRotation||0,includeBounds:!1!==e.includeBounds},this._range||this);<span class="cstat-no" title="statement not covered" ></span>return"ticks"===t.bounds&amp;&amp;(0,s.aH)(n,this,"value"),t.reverse?(n.reverse(),this.start=this.max,this.end=this.min):(this.start=this.min,this.end=this.max),n}<span class="fstat-no" title="function not covered" ></span>co</span>nfigure(){const t=<span class="cstat-no" title="statement not covered" >this.ticks;</span>let e=<span class="cstat-no" title="statement not covered" >this.min,</span>i=<span class="cstat-no" title="statement not covered" >this.max;<span class="cstat-no" title="statement not covered" ></span>if(super.configure(),this.options.offset&amp;&amp;t.length){const s=<span class="cstat-no" title="statement not covered" >(i-e)/Math.max(t.length-1,1)/2;<span class="cstat-no" title="statement not covered" ></span>e-=s,i+=s}<span class="cstat-no" title="statement not covered" ></span>t</span>his._startValue=e,this._endValue=i,this._valueRange=i-e}<span class="fstat-no" title="function not covered" ></span>ge</span>tLabelForValue(t){<span class="cstat-no" title="statement not covered" >return(0,s.o)(t,this.chart.options.locale,this.options.ticks.format)}</span>}class mi extends xi{static id=<span class="cstat-no" title="statement not covered" >"linear";</span>static defaults=<span class="cstat-no" title="statement not covered" >{ticks:{callback:s.aM.formatters.numeric}};<span class="fstat-no" title="function not covered" ></span>de</span>termineDataLimits(){const{min:t,max:e}=<span class="cstat-no" title="statement not covered" >this.getMinMax(!0);<span class="cstat-no" title="statement not covered" ></span>this.min=(0,s.g)(t)?t:0,this.max=(0,s.g)(e)?e:1,this.handleTickRangeOptions()}<span class="fstat-no" title="function not covered" ></span>co</span>mputeTickLimit(){const t=<span class="cstat-no" title="statement not covered" >this.isHorizontal(),</span>e=<span class="cstat-no" title="statement not covered" >t?this.width:this.height,</span>i=<span class="cstat-no" title="statement not covered" >(0,s.t)(this.options.ticks.minRotation),</span>n=<span class="cstat-no" title="statement not covered" >(t?Math.sin(i):Math.cos(i))||.001,</span>o=<span class="cstat-no" title="statement not covered" >this._resolveTickFontOptions(0);<span class="cstat-no" title="statement not covered" ></span>return Math.ceil(e/Math.min(40,o.lineHeight/n))}<span class="fstat-no" title="function not covered" ></span>ge</span>tPixelForValue(t){<span class="cstat-no" title="statement not covered" >return null===t?NaN:this.getPixelForDecimal((t-this._startValue)/this._valueRange)}<span class="fstat-no" title="function not covered" ></span>ge</span>tValueForPixel(t){<span class="cstat-no" title="statement not covered" >return this._startValue+this.getDecimalForPixel(t)*this._valueRange}</span>}<span class="cstat-no" title="statement not covered" >s.aM.formatters.logarithmic;<span class="cstat-no" title="statement not covered" >s</span>.aM.formatters.numeric}</span>}]);</span></pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2025-11-10T08:05:28.828Z
            </div>
        <script src="../../../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../../../sorter.js"></script>
        <script src="../../../../../block-navigation.js"></script>
    </body>
</html>
    