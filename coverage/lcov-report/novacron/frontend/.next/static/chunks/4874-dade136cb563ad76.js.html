
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for novacron/frontend/.next/static/chunks/4874-dade136cb563ad76.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../../../index.html">All files</a> / <a href="index.html">novacron/frontend/.next/static/chunks</a> 4874-dade136cb563ad76.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/212</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/280</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/82</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/1</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">"use strict";<span class="cstat-no" title="statement not covered" >(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[4874],{99808:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,r){var s=<span class="cstat-no" title="statement not covered" >r(2265);</span>var n=<span class="cstat-no" title="statement not covered" >"function"===typeof Object.is?Object.is:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t===e&amp;&amp;(0!==t||1/t===1/e)||t!==t&amp;&amp;e!==e}</span>,</span>i=<span class="cstat-no" title="statement not covered" >s.useState,</span>u=<span class="cstat-no" title="statement not covered" >s.useEffect,</span>o=<span class="cstat-no" title="statement not covered" >s.useLayoutEffect,</span>c=<span class="cstat-no" title="statement not covered" >s.useDebugValue;</span>function <span class="fstat-no" title="function not covered" >a(</span>t){var e=<span class="cstat-no" title="statement not covered" >t.getSnapshot;<span class="cstat-no" title="statement not covered" ></span>t=t.value;<span class="cstat-no" title="statement not covered" >t</span>ry{var r=<span class="cstat-no" title="statement not covered" >e();<span class="cstat-no" title="statement not covered" ></span>return!n(t,r)}</span>catch(s){<span class="cstat-no" title="statement not covered" >return!0}</span>}</span>var l=<span class="cstat-no" title="statement not covered" >"undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement?<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return e()}</span>:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){var r=<span class="cstat-no" title="statement not covered" >e(),</span>s=<span class="cstat-no" title="statement not covered" >i({inst:{value:r,getSnapshot:e}}),</span>n=<span class="cstat-no" title="statement not covered" >s[0].inst,</span>l=<span class="cstat-no" title="statement not covered" >s[1];<span class="cstat-no" title="statement not covered" ></span>return o((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >n.value=r,n.getSnapshot=e,a(n)&amp;&amp;l({inst:n})}</span>),[t,r,e]),u((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return a(n)&amp;&amp;l({inst:n}),t((<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >a(n)&amp;&amp;l({inst:n})}</span>))}</span>),[t]),c(r),r}</span>;<span class="cstat-no" title="statement not covered" ></span>e.useSyncExternalStore=void 0!==s.useSyncExternalStore?s.useSyncExternalStore:l}</span>,26272:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,r){<span class="cstat-no" title="statement not covered" >t.exports=r(99808)}</span>,64874:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,r){<span class="cstat-no" title="statement not covered" >r.d(e,{a:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return E}</span>});v</span>ar s=<span class="cstat-no" title="statement not covered" >r(46504),</span>n=<span class="cstat-no" title="statement not covered" >r(17156),</span>i=<span class="cstat-no" title="statement not covered" >r(88202),</span>u=<span class="cstat-no" title="statement not covered" >r(29492),</span>o=<span class="cstat-no" title="statement not covered" >r(43238);</span>class c extends u.l{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >super(),this.client=t,this.options=e,this.trackedProps=new Set,this.selectError=null,this.bindMethods(),this.setOptions(e)}<span class="fstat-no" title="function not covered" ></span>bi</span>ndMethods(){<span class="cstat-no" title="statement not covered" >this.remove=this.remove.bind(this),this.refetch=this.refetch.bind(this)}<span class="fstat-no" title="function not covered" ></span>on</span>Subscribe(){<span class="cstat-no" title="statement not covered" >1===this.listeners.size&amp;&amp;(this.currentQuery.addObserver(this),a(this.currentQuery,this.options)&amp;&amp;this.executeFetch(),this.updateTimers())}<span class="fstat-no" title="function not covered" ></span>on</span>Unsubscribe(){<span class="cstat-no" title="statement not covered" >this.hasListeners()||this.destroy()}<span class="fstat-no" title="function not covered" ></span>sh</span>ouldFetchOnReconnect(){<span class="cstat-no" title="statement not covered" >return l(this.currentQuery,this.options,this.options.refetchOnReconnect)}<span class="fstat-no" title="function not covered" ></span>sh</span>ouldFetchOnWindowFocus(){<span class="cstat-no" title="statement not covered" >return l(this.currentQuery,this.options,this.options.refetchOnWindowFocus)}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(){<span class="cstat-no" title="statement not covered" >this.listeners=new Set,this.clearStaleTimeout(),this.clearRefetchInterval(),this.currentQuery.removeObserver(this)}<span class="fstat-no" title="function not covered" ></span>se</span>tOptions(t,e){const r=<span class="cstat-no" title="statement not covered" >this.options,</span>n=<span class="cstat-no" title="statement not covered" >this.currentQuery;<span class="cstat-no" title="statement not covered" ></span>if(this.options=this.client.defaultQueryOptions(t),(0,s.VS)(r,this.options)||this.client.getQueryCache().notify({type:"observerOptionsUpdated",query:this.currentQuery,observer:this}),"undefined"!==typeof this.options.enabled&amp;&amp;"boolean"!==typeof this.options.enabled)<span class="cstat-no" title="statement not covered" >throw new Error("Expected enabled to be a boolean");<span class="cstat-no" title="statement not covered" >t</span></span>his.options.queryKey||(this.options.queryKey=r.queryKey),this.updateQuery();c</span>onst i=<span class="cstat-no" title="statement not covered" >this.hasListeners();<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;h(this.currentQuery,n,this.options,r)&amp;&amp;this.executeFetch(),this.updateResult(e),!i||this.currentQuery===n&amp;&amp;this.options.enabled===r.enabled&amp;&amp;this.options.staleTime===r.staleTime||this.updateStaleTimeout();c</span>onst u=<span class="cstat-no" title="statement not covered" >this.computeRefetchInterval();<span class="cstat-no" title="statement not covered" ></span>!i||this.currentQuery===n&amp;&amp;this.options.enabled===r.enabled&amp;&amp;u===this.currentRefetchInterval||this.updateRefetchInterval(u)}<span class="fstat-no" title="function not covered" ></span>ge</span>tOptimisticResult(t){const e=<span class="cstat-no" title="statement not covered" >this.client.getQueryCache().build(this.client,t),</span>r=<span class="cstat-no" title="statement not covered" >this.createResult(e,t);<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e,r){<span class="cstat-no" title="statement not covered" >if(r.keepPreviousData)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(void 0!==r.placeholderData)<span class="cstat-no" title="statement not covered" >return e.isPlaceholderData;<span class="cstat-no" title="statement not covered" >i</span></span>f(!(0,s.VS)(t.getCurrentResult(),e))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span>eturn!1}</span>(this,r,t)&amp;&amp;(this.currentResult=r,this.currentResultOptions=this.options,this.currentResultState=this.currentQuery.state),r}<span class="fstat-no" title="function not covered" ></span>ge</span>tCurrentResult(){<span class="cstat-no" title="statement not covered" >return this.currentResult}<span class="fstat-no" title="function not covered" ></span>tr</span>ackResult(t){const e=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>return Object.keys(t).forEach((<span class="fstat-no" title="function not covered" >r=</span>&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,r,{configurable:!1,enumerable:!0,get:<span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >this.trackedProps.add(r),t[r])</span>})}</span>)),e}<span class="fstat-no" title="function not covered" ></span>ge</span>tCurrentQuery(){<span class="cstat-no" title="statement not covered" >return this.currentQuery}<span class="fstat-no" title="function not covered" ></span>re</span>move(){<span class="cstat-no" title="statement not covered" >this.client.getQueryCache().remove(this.currentQuery)}<span class="fstat-no" title="function not covered" ></span>re</span>fetch({refetchPage:t,...e}=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return this.fetch({...e,meta:{refetchPage:t}})}<span class="fstat-no" title="function not covered" ></span>fe</span>tchOptimistic(t){const e=<span class="cstat-no" title="statement not covered" >this.client.defaultQueryOptions(t),</span>r=<span class="cstat-no" title="statement not covered" >this.client.getQueryCache().build(this.client,e);<span class="cstat-no" title="statement not covered" ></span>return r.isFetchingOptimistic=!0,r.fetch().then((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.createResult(r,e))</span>)}<span class="fstat-no" title="function not covered" ></span>fe</span>tch(t){var e;<span class="cstat-no" title="statement not covered" >return this.executeFetch({...t,cancelRefetch:null==(e=t.cancelRefetch)||e}).then((<span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >this.updateResult(),this.currentResult)</span>))}<span class="fstat-no" title="function not covered" ></span>ex</span>ecuteFetch(t){<span class="cstat-no" title="statement not covered" >this.updateQuery();l</span>et e=<span class="cstat-no" title="statement not covered" >this.currentQuery.fetch(this.options,t);<span class="cstat-no" title="statement not covered" ></span>return null!=t&amp;&amp;t.throwOnError||(e=e.catch(s.ZT)),e}<span class="fstat-no" title="function not covered" ></span>up</span>dateStaleTimeout(){<span class="cstat-no" title="statement not covered" >if(this.clearStaleTimeout(),s.sk||this.currentResult.isStale||!(0,s.PN)(this.options.staleTime))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >(0,s.Kp)(this.currentResult.dataUpdatedAt,this.options.staleTime)+1;<span class="cstat-no" title="statement not covered" ></span>this.staleTimeoutId=setTimeout((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.currentResult.isStale||this.updateResult()}</span>),t)}<span class="fstat-no" title="function not covered" ></span>co</span>mputeRefetchInterval(){var t;<span class="cstat-no" title="statement not covered" >return"function"===typeof this.options.refetchInterval?this.options.refetchInterval(this.currentResult.data,this.currentQuery):null!=(t=this.options.refetchInterval)&amp;&amp;t}<span class="fstat-no" title="function not covered" ></span>up</span>dateRefetchInterval(t){<span class="cstat-no" title="statement not covered" >this.clearRefetchInterval(),this.currentRefetchInterval=t,!s.sk&amp;&amp;!1!==this.options.enabled&amp;&amp;(0,s.PN)(this.currentRefetchInterval)&amp;&amp;0!==this.currentRefetchInterval&amp;&amp;(this.refetchIntervalId=setInterval((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >(this.options.refetchIntervalInBackground||i.j.isFocused())&amp;&amp;this.executeFetch()}</span>),this.currentRefetchInterval))}<span class="fstat-no" title="function not covered" ></span>up</span>dateTimers(){<span class="cstat-no" title="statement not covered" >this.updateStaleTimeout(),this.updateRefetchInterval(this.computeRefetchInterval())}<span class="fstat-no" title="function not covered" ></span>cl</span>earStaleTimeout(){<span class="cstat-no" title="statement not covered" >this.staleTimeoutId&amp;&amp;(clearTimeout(this.staleTimeoutId),this.staleTimeoutId=void 0)}<span class="fstat-no" title="function not covered" ></span>cl</span>earRefetchInterval(){<span class="cstat-no" title="statement not covered" >this.refetchIntervalId&amp;&amp;(clearInterval(this.refetchIntervalId),this.refetchIntervalId=void 0)}<span class="fstat-no" title="function not covered" ></span>cr</span>eateResult(t,e){const r=<span class="cstat-no" title="statement not covered" >this.currentQuery,</span>n=<span class="cstat-no" title="statement not covered" >this.options,</span>i=<span class="cstat-no" title="statement not covered" >this.currentResult,</span>u=<span class="cstat-no" title="statement not covered" >this.currentResultState,</span>c=<span class="cstat-no" title="statement not covered" >this.currentResultOptions,</span>l=<span class="cstat-no" title="statement not covered" >t!==r,</span>p=<span class="cstat-no" title="statement not covered" >l?t.state:this.currentQueryInitialState,</span>f=<span class="cstat-no" title="statement not covered" >l?this.currentResult:this.previousQueryResult,</span>{state:y}=<span class="cstat-no" title="statement not covered" >t;</span>let R,{dataUpdatedAt:v,error:m,errorUpdatedAt:S,fetchStatus:b,status:E}=<span class="cstat-no" title="statement not covered" >y,</span>g=<span class="cstat-no" title="statement not covered" >!1,</span>Q=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if(e._optimisticResults){const s=<span class="cstat-no" title="statement not covered" >this.hasListeners(),</span>i=<span class="cstat-no" title="statement not covered" >!s&amp;&amp;a(t,e),</span>u=<span class="cstat-no" title="statement not covered" >s&amp;&amp;h(t,r,e,n);<span class="cstat-no" title="statement not covered" ></span>(i||u)&amp;&amp;(b=(0,o.Kw)(t.options.networkMode)?"fetching":"paused",v||(E="loading")),"isRestoring"===e._optimisticResults&amp;&amp;(b="idle")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e.keepPreviousData&amp;&amp;!y.dataUpdatedAt&amp;&amp;null!=f&amp;&amp;f.isSuccess&amp;&amp;"error"!==E)<span class="cstat-no" title="statement not covered" >R=f.data,v=f.dataUpdatedAt,E=f.status,g=!0;e</span>lse <span class="cstat-no" title="statement not covered" >if(e.select&amp;&amp;"undefined"!==typeof y.data)<span class="cstat-no" title="statement not covered" >if(i&amp;&amp;y.data===(null==u?void 0:u.data)&amp;&amp;e.select===this.selectFn)<span class="cstat-no" title="statement not covered" >R=this.selectResult;e</span>lse <span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >this.selectFn=e.select,R=e.select(y.data),R=(0,s.oE)(null==i?void 0:i.data,R,e),this.selectResult=R,this.selectError=null}</span>catch(T){<span class="cstat-no" title="statement not covered" >0,this.selectError=T}</span>e</span></span>lse <span class="cstat-no" title="statement not covered" >R=y.data;<span class="cstat-no" title="statement not covered" >i</span></span></span>f("undefined"!==typeof e.placeholderData&amp;&amp;"undefined"===typeof R&amp;&amp;"loading"===E){let t;<span class="cstat-no" title="statement not covered" >if(null!=i&amp;&amp;i.isPlaceholderData&amp;&amp;e.placeholderData===(null==c?void 0:c.placeholderData))<span class="cstat-no" title="statement not covered" >t=i.data;e</span>lse <span class="cstat-no" title="statement not covered" >if(t="function"===typeof e.placeholderData?e.placeholderData():e.placeholderData,e.select&amp;&amp;"undefined"!==typeof t)<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >t=e.select(t),this.selectError=null}</span>catch(T){<span class="cstat-no" title="statement not covered" >0,this.selectError=T}<span class="cstat-no" title="statement not covered" ></span>"</span></span></span>undefined"!==typeof t&amp;&amp;(E="success",R=(0,s.oE)(null==i?void 0:i.data,t,e),Q=!0)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.selectError&amp;&amp;(m=this.selectError,R=this.selectResult,S=Date.now(),E="error");c</span>onst I=<span class="cstat-no" title="statement not covered" >"fetching"===b,</span>C=<span class="cstat-no" title="statement not covered" >"loading"===E,</span>O=<span class="cstat-no" title="statement not covered" >"error"===E;<span class="cstat-no" title="statement not covered" ></span>return{status:E,fetchStatus:b,isLoading:C,isSuccess:"success"===E,isError:O,isInitialLoading:C&amp;&amp;I,data:R,dataUpdatedAt:v,error:m,errorUpdatedAt:S,failureCount:y.fetchFailureCount,failureReason:y.fetchFailureReason,errorUpdateCount:y.errorUpdateCount,isFetched:y.dataUpdateCount&gt;0||y.errorUpdateCount&gt;0,isFetchedAfterMount:y.dataUpdateCount&gt;p.dataUpdateCount||y.errorUpdateCount&gt;p.errorUpdateCount,isFetching:I,isRefetching:I&amp;&amp;!C,isLoadingError:O&amp;&amp;0===y.dataUpdatedAt,isPaused:"paused"===b,isPlaceholderData:Q,isPreviousData:g,isRefetchError:O&amp;&amp;0!==y.dataUpdatedAt,isStale:d(t,e),refetch:this.refetch,remove:this.remove}}<span class="fstat-no" title="function not covered" ></span>up</span>dateResult(t){const e=<span class="cstat-no" title="statement not covered" >this.currentResult,</span>r=<span class="cstat-no" title="statement not covered" >this.createResult(this.currentQuery,this.options);<span class="cstat-no" title="statement not covered" ></span>if(this.currentResultState=this.currentQuery.state,this.currentResultOptions=this.options,(0,s.VS)(r,e))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.currentResult=r;c</span>onst n=<span class="cstat-no" title="statement not covered" >{cache:!0};<span class="cstat-no" title="statement not covered" ></span>!1!==(null==t?void 0:t.listeners)&amp;&amp;(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return!0;c</span></span>onst{notifyOnChangeProps:t}=<span class="cstat-no" title="statement not covered" >this.options,</span>r=<span class="cstat-no" title="statement not covered" >"function"===typeof t?t():t;<span class="cstat-no" title="statement not covered" ></span>if("all"===r||!r&amp;&amp;!this.trackedProps.size)<span class="cstat-no" title="statement not covered" >return!0;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >new Set(null!=r?r:this.trackedProps);<span class="cstat-no" title="statement not covered" ></span>return this.options.useErrorBoundary&amp;&amp;s.add("error"),Object.keys(this.currentResult).some((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const r=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return this.currentResult[r]!==e[r]&amp;&amp;s.has(r)}</span>))}</span>)()&amp;&amp;(n.listeners=!0),this.notify({...n,...t})}<span class="fstat-no" title="function not covered" ></span>up</span>dateQuery(){const t=<span class="cstat-no" title="statement not covered" >this.client.getQueryCache().build(this.client,this.options);<span class="cstat-no" title="statement not covered" ></span>if(t===this.currentQuery)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.currentQuery;<span class="cstat-no" title="statement not covered" ></span>this.currentQuery=t,this.currentQueryInitialState=t.state,this.previousQueryResult=this.currentResult,this.hasListeners()&amp;&amp;(null==e||e.removeObserver(this),t.addObserver(this))}<span class="fstat-no" title="function not covered" ></span>on</span>QueryUpdate(t){const e=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>"success"===t.type?e.onSuccess=!t.manual:"error"!==t.type||(0,o.DV)(t.error)||(e.onError=!0),this.updateResult(e),this.hasListeners()&amp;&amp;this.updateTimers()}<span class="fstat-no" title="function not covered" ></span>no</span>tify(t){<span class="cstat-no" title="statement not covered" >n.V.batch((<span class="fstat-no" title="function not covered" >()</span>=&gt;{var e,r,s,n;<span class="cstat-no" title="statement not covered" >if(t.onSuccess)<span class="cstat-no" title="statement not covered" >null==(e=(r=this.options).onSuccess)||e.call(r,this.currentResult.data),null==(s=(n=this.options).onSettled)||s.call(n,this.currentResult.data,null);e</span>lse <span class="cstat-no" title="statement not covered" >if(t.onError){var i,u,o,c;<span class="cstat-no" title="statement not covered" >null==(i=(u=this.options).onError)||i.call(u,this.currentResult.error),null==(o=(c=this.options).onSettled)||o.call(c,void 0,this.currentResult.error)}<span class="cstat-no" title="statement not covered" ></span>t</span></span>.listeners&amp;&amp;this.listeners.forEach((<span class="fstat-no" title="function not covered" >({</span>listener:t})=&gt;{<span class="cstat-no" title="statement not covered" >t(this.currentResult)}</span>)),t.cache&amp;&amp;this.client.getQueryCache().notify({query:this.currentQuery,type:"observerResultsUpdated"})}</span>))}</span>}function <span class="fstat-no" title="function not covered" >a(</span>t,e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return!1!==e.enabled&amp;&amp;!t.state.dataUpdatedAt&amp;&amp;!("error"===t.state.status&amp;&amp;!1===e.retryOnMount)}</span>(t,e)||t.state.dataUpdatedAt&gt;0&amp;&amp;l(t,e,e.refetchOnMount)}</span>function <span class="fstat-no" title="function not covered" >l(</span>t,e,r){<span class="cstat-no" title="statement not covered" >if(!1!==e.enabled){const s=<span class="cstat-no" title="statement not covered" >"function"===typeof r?r(t):r;<span class="cstat-no" title="statement not covered" ></span>return"always"===s||!1!==s&amp;&amp;d(t,e)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>function <span class="fstat-no" title="function not covered" >h(</span>t,e,r,s){<span class="cstat-no" title="statement not covered" >return!1!==r.enabled&amp;&amp;(t!==e||!1===s.enabled)&amp;&amp;(!r.suspense||"error"!==t.state.status)&amp;&amp;d(t,r)}</span>function <span class="fstat-no" title="function not covered" >d(</span>t,e){<span class="cstat-no" title="statement not covered" >return t.isStaleByTime(e.staleTime)}</span>var p=<span class="cstat-no" title="statement not covered" >r(2265),</span>f=<span class="cstat-no" title="statement not covered" >r(45321);</span>function <span class="fstat-no" title="function not covered" >y(</span>){let t=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return{clearReset:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t=!1}</span>,reset:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t=!0}</span>,isReset:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t}</span>}</span>const R=<span class="cstat-no" title="statement not covered" >p.createContext(y());</span>var v=<span class="cstat-no" title="statement not covered" >r(70165);</span>const m=<span class="cstat-no" title="statement not covered" >p.createContext(!1);<span class="cstat-no" title="statement not covered" ></span>m.Provider;v</span>ar S=<span class="cstat-no" title="statement not covered" >r(57798);</span>function <span class="fstat-no" title="function not covered" >b(</span>t,e){const r=<span class="cstat-no" title="statement not covered" >(0,v.NL)({context:t.context}),</span>s=<span class="cstat-no" title="statement not covered" >p.useContext(m),</span>i=<span class="cstat-no" title="statement not covered" >p.useContext(R),</span>u=<span class="cstat-no" title="statement not covered" >r.defaultQueryOptions(t);<span class="cstat-no" title="statement not covered" ></span>u._optimisticResults=s?"isRestoring":"optimistic",u.onError&amp;&amp;(u.onError=n.V.batchCalls(u.onError)),u.onSuccess&amp;&amp;(u.onSuccess=n.V.batchCalls(u.onSuccess)),u.onSettled&amp;&amp;(u.onSettled=n.V.batchCalls(u.onSettled)),(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.suspense&amp;&amp;("number"!==typeof t.staleTime&amp;&amp;(t.staleTime=1e3),"number"===typeof t.cacheTime&amp;&amp;(t.cacheTime=Math.max(t.cacheTime,1e3)))}</span>)(u),(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >(t.suspense||t.useErrorBoundary)&amp;&amp;(e.isReset()||(t.retryOnMount=!1))}</span>)(u,i),(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >p.useEffect((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.clearReset()}</span>),[t])}</span>)(i);c</span>onst[o]=<span class="cstat-no" title="statement not covered" >p.useState((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >new e(r,u))</span>),</span>c=<span class="cstat-no" title="statement not covered" >o.getOptimisticResult(u);<span class="cstat-no" title="statement not covered" ></span>if((0,f.$)(p.useCallback((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >s?<span class="fstat-no" title="function not covered" >()</span>=&gt;{}:o.subscribe(n.V.batchCalls(t));<span class="cstat-no" title="statement not covered" ></span>return o.updateResult(),e}</span>),[o,s]),(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >o.getCurrentResult())</span>,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >o.getCurrentResult())</span>),p.useEffect((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >o.setOptions(u,{listeners:!1})}</span>),[u,o]),(<span class="fstat-no" title="function not covered" >(t</span>,e,r)=&gt;<span class="cstat-no" title="statement not covered" >(null==t?void 0:t.suspense)&amp;&amp;(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t.isLoading&amp;&amp;t.isFetching&amp;&amp;!e)</span>(e,r))</span>(u,c,s))<span class="cstat-no" title="statement not covered" >throw(<span class="fstat-no" title="function not covered" >(t</span>,e,r)=&gt;<span class="cstat-no" title="statement not covered" >e.fetchOptimistic(t).then((<span class="fstat-no" title="function not covered" >({</span>data:e})=&gt;{<span class="cstat-no" title="statement not covered" >null==t.onSuccess||t.onSuccess(e),null==t.onSettled||t.onSettled(e,null)}</span>)).catch((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >r.clearReset(),null==t.onError||t.onError(e),null==t.onSettled||t.onSettled(void 0,e)}</span>)))</span>(u,o,i);<span class="cstat-no" title="statement not covered" >i</span></span>f((<span class="fstat-no" title="function not covered" >({</span>result:t,errorResetBoundary:e,useErrorBoundary:r,query:s})=&gt;<span class="cstat-no" title="statement not covered" >t.isError&amp;&amp;!e.isReset()&amp;&amp;!t.isFetching&amp;&amp;(0,S.L)(r,[t.error,s]))</span>({result:c,errorResetBoundary:i,useErrorBoundary:u.useErrorBoundary,query:o.getCurrentQuery()}))<span class="cstat-no" title="statement not covered" >throw c.error;<span class="cstat-no" title="statement not covered" >r</span></span>eturn u.notifyOnChangeProps?c:o.trackResult(c)}</span>function <span class="fstat-no" title="function not covered" >E(</span>t,e,r){<span class="cstat-no" title="statement not covered" >return b((0,s._v)(t,e,r),c)}</span>},45321:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,r){<span class="cstat-no" title="statement not covered" >r.d(e,{$:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s}</span>});c</span>onst s=<span class="cstat-no" title="statement not covered" >r(26272).useSyncExternalStore}</span>,57798:<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,r){function <span class="fstat-no" title="function not covered" >s(</span>t,e){<span class="cstat-no" title="statement not covered" >return"function"===typeof t?t(...e):!!t}<span class="cstat-no" title="statement not covered" ></span>r.d(e,{L:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return s}</span>})}</span>}]);</span></pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2025-11-10T08:05:28.828Z
            </div>
        <script src="../../../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../../../sorter.js"></script>
        <script src="../../../../../block-navigation.js"></script>
    </body>
</html>
    