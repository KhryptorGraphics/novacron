
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for novacron/frontend/.next/server/chunks/1719.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../../../index.html">All files</a> / <a href="index.html">novacron/frontend/.next/server/chunks</a> 1719.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/2311</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/2763</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/801</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/1</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">"use strict";<span class="cstat-no" title="statement not covered" >exports.id=1719,exports.ids=[1719],exports.modules={22388:<span class="fstat-no" title="function not covered" >(t</span>,e,n)=&gt;{<span class="cstat-no" title="statement not covered" >n.d(e,{Z:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >i}</span>);c</span>onst i=<span class="cstat-no" title="statement not covered" >(0,n(3528).Z)("Eye",[["path",{d:"M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z",key:"rwhkz3"}],["circle",{cx:"12",cy:"12",r:"3",key:"1v7zrd"}]])}</span>,37284:<span class="fstat-no" title="function not covered" >(t</span>,e,n)=&gt;{const{createProxy:i}=<span class="cstat-no" title="statement not covered" >n(95153);<span class="cstat-no" title="statement not covered" ></span>t.exports=i("/home/kp/novacron/frontend/node_modules/next/dist/client/components/error-boundary.js")}</span>,78549:<span class="fstat-no" title="function not covered" >(t</span>,e,n)=&gt;{<span class="cstat-no" title="statement not covered" >n.d(e,{p:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >i}</span>);c</span>onst i=<span class="cstat-no" title="statement not covered" >(0,n(9885).createContext)({})}</span>,19386:<span class="fstat-no" title="function not covered" >(t</span>,e,n)=&gt;{<span class="cstat-no" title="statement not covered" >n.d(e,{O:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >i}</span>);c</span>onst i=<span class="cstat-no" title="statement not covered" >(0,n(9885).createContext)(null)}</span>,89195:<span class="fstat-no" title="function not covered" >(t</span>,e,n)=&gt;{<span class="cstat-no" title="statement not covered" >n.d(e,{Pn:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >a,</span>Wi:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >r,</span>frameData:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >l,</span>S6:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >u}</span>);v</span>ar i=<span class="cstat-no" title="statement not covered" >n(41279);</span>class s{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.order=[],this.scheduled=new Set}<span class="fstat-no" title="function not covered" ></span>ad</span>d(t){<span class="cstat-no" title="statement not covered" >if(!this.scheduled.has(t))<span class="cstat-no" title="statement not covered" >return this.scheduled.add(t),this.order.push(t),!0}<span class="fstat-no" title="function not covered" ></span></span>re</span>move(t){const e=<span class="cstat-no" title="statement not covered" >this.order.indexOf(t);<span class="cstat-no" title="statement not covered" ></span>-1!==e&amp;&amp;(this.order.splice(e,1),this.scheduled.delete(t))}<span class="fstat-no" title="function not covered" ></span>cl</span>ear(){<span class="cstat-no" title="statement not covered" >this.order.length=0,this.scheduled.clear()}</span>}const o=<span class="cstat-no" title="statement not covered" >["prepare","read","update","preRender","render","postRender"];</span>const{schedule:r,cancel:a,state:l,steps:u}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){let n=<span class="cstat-no" title="statement not covered" >!1,</span>i=<span class="cstat-no" title="statement not covered" >!0;</span>const r=<span class="cstat-no" title="statement not covered" >{delta:0,timestamp:0,isProcessing:!1},</span>a=<span class="cstat-no" title="statement not covered" >o.reduce((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;(<span class="cstat-no" title="statement not covered" >t[e]=<span class="fstat-no" title="function not covered" >fu</span>nction(t){let e=<span class="cstat-no" title="statement not covered" >new s,</span>n=<span class="cstat-no" title="statement not covered" >new s,</span>i=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >!1,</span>r=<span class="cstat-no" title="statement not covered" >!1;</span>const a=<span class="cstat-no" title="statement not covered" >new WeakSet,</span>l=<span class="cstat-no" title="statement not covered" >{schedule:<span class="fstat-no" title="function not covered" >(t</span>,s=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>r=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>=&gt;{const l=<span class="cstat-no" title="statement not covered" >r&amp;&amp;o,</span>u=<span class="cstat-no" title="statement not covered" >l?e:n;<span class="cstat-no" title="statement not covered" ></span>return s&amp;&amp;a.add(t),u.add(t)&amp;&amp;l&amp;&amp;o&amp;&amp;(i=e.order.length),t}</span>,cancel:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >n.remove(t),a.delete(t)}</span>,process:<span class="fstat-no" title="function not covered" >s=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(o)<span class="cstat-no" title="statement not covered" >r=!0;e</span>lse{<span class="cstat-no" title="statement not covered" >if(o=!0,[e,n]=[n,e],n.clear(),i=e.order.length,i)<span class="cstat-no" title="statement not covered" >for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;i;n++){const i=<span class="cstat-no" title="statement not covered" >e.order[n];<span class="cstat-no" title="statement not covered" ></span>i(s),a.has(i)&amp;&amp;(l.schedule(i),t())}<span class="cstat-no" title="statement not covered" ></span>o</span></span>=!1,r&amp;&amp;(r=!1,l.process(s))}</span>}</span>};<span class="cstat-no" title="statement not covered" ></span>return l}</span>((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >n=!0)</span>),t)</span>),{}),</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >a[t].process(r),</span></span>u=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{const s=<span class="cstat-no" title="statement not covered" >performance.now();<span class="cstat-no" title="statement not covered" ></span>n=!1,r.delta=i?1e3/60:Math.max(Math.min(s-r.timestamp,40),1),r.timestamp=s,r.isProcessing=!0,o.forEach(l),r.isProcessing=!1,n&amp;&amp;e&amp;&amp;(i=!1,t(u))}</span>;<span class="cstat-no" title="statement not covered" ></span>return{schedule:o.reduce((<span class="fstat-no" title="function not covered" >(e</span>,s)=&gt;{const o=<span class="cstat-no" title="statement not covered" >a[s];<span class="cstat-no" title="statement not covered" ></span>return e[s]=<span class="fstat-no" title="function not covered" >(e</span>,s=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>a=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>=&gt;(<span class="cstat-no" title="statement not covered" >n||(n=!0,i=!0,r.isProcessing||t(u)),o.schedule(e,s,a))</span>,e}</span>),{}),cancel:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >o.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >a[e].cancel(t))</span>),</span>state:r,steps:a}}</span>("undefined"!==typeof requestAnimationFrame?requestAnimationFrame:i.Z,!0)}</span>,94571:<span class="fstat-no" title="function not covered" >(t</span>,e,n)=&gt;{<span class="cstat-no" title="statement not covered" >n.d(e,{E:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >No}</span>);v</span>ar i=<span class="cstat-no" title="statement not covered" >n(9885);</span>const s=<span class="cstat-no" title="statement not covered" >(0,i.createContext)({transformPagePoint:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t,</span>isStatic:!1,reducedMotion:"never"}),</span>o=<span class="cstat-no" title="statement not covered" >(0,i.createContext)({});</span>var r=<span class="cstat-no" title="statement not covered" >n(19386),</span>a=<span class="cstat-no" title="statement not covered" >n(60381);</span>const l=<span class="cstat-no" title="statement not covered" >(0,i.createContext)({strict:!1}),</span>u=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.replace(/([a-z])([A-Z])/g,"$1-$2").toLowerCase(),</span></span>c=<span class="cstat-no" title="statement not covered" >"data-"+u("framerAppearId");</span>function <span class="fstat-no" title="function not covered" >h(</span>t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;"object"===typeof t&amp;&amp;Object.prototype.hasOwnProperty.call(t,"current")}</span>function <span class="fstat-no" title="function not covered" >d(</span>t){<span class="cstat-no" title="statement not covered" >return"string"===typeof t||Array.isArray(t)}</span>function <span class="fstat-no" title="function not covered" >p(</span>t){<span class="cstat-no" title="statement not covered" >return null!==t&amp;&amp;"object"===typeof t&amp;&amp;"function"===typeof t.start}</span>const m=<span class="cstat-no" title="statement not covered" >["animate","whileInView","whileFocus","whileHover","whileTap","whileDrag","exit"],</span>f=<span class="cstat-no" title="statement not covered" >["initial",...m];</span>function <span class="fstat-no" title="function not covered" >g(</span>t){<span class="cstat-no" title="statement not covered" >return p(t.animate)||f.some((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >d(t[e]))</span>)}</span>function <span class="fstat-no" title="function not covered" >y(</span>t){<span class="cstat-no" title="statement not covered" >return Boolean(g(t)||t.variants)}</span>function <span class="fstat-no" title="function not covered" >v(</span>t){const{initial:e,animate:n}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(g(t)){const{initial:e,animate:n}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return{initial:!1===e||d(e)?e:void 0,animate:d(n)?n:void 0}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1!==t.inherit?e:{}}</span>(t,(0,i.useContext)(o));<span class="cstat-no" title="statement not covered" ></span>return(0,i.useMemo)((<span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >{initial:e,animate:n})</span>),[x(e),x(n)])}</span>function <span class="fstat-no" title="function not covered" >x(</span>t){<span class="cstat-no" title="statement not covered" >return Array.isArray(t)?t.join(" "):t}</span>const P=<span class="cstat-no" title="statement not covered" >{animation:["animate","variants","whileHover","whileTap","exit","whileInView","whileFocus","whileDrag"],exit:["exit"],drag:["drag","dragControls"],focus:["whileFocus"],hover:["whileHover","onHoverStart","onHoverEnd"],tap:["whileTap","onTap","onTapStart","onTapCancel"],pan:["onPan","onPanStart","onPanSessionStart","onPanEnd"],inView:["whileInView","onViewportEnter","onViewportLeave"],layout:["layout","layoutId"]},</span>b=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(const Zo in P)<span class="cstat-no" title="statement not covered" >b[Zo]={isEnabled:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >P[Zo].some((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >!!t[e])</span>)}</span>;v</span></span>ar T=<span class="cstat-no" title="statement not covered" >n(58066),</span>S=<span class="cstat-no" title="statement not covered" >n(78549);</span>const w=<span class="cstat-no" title="statement not covered" >(0,i.createContext)({}),</span>A=<span class="cstat-no" title="statement not covered" >Symbol.for("motionComponentSymbol");</span>function <span class="fstat-no" title="function not covered" >V(</span>{preloadedFeatures:t,createVisualElement:e,useRender:n,useVisualState:u,Component:d}){<span class="cstat-no" title="statement not covered" >t&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t){<span class="cstat-no" title="statement not covered" >for(const e in t)<span class="cstat-no" title="statement not covered" >b[e]={...b[e],...t[e]}}</span></span>(t);c</span>onst p=<span class="cstat-no" title="statement not covered" >(0,i.forwardRef)((<span class="fstat-no" title="function not covered" >fu</span>nction(p,m){let f;const g=<span class="cstat-no" title="statement not covered" >{...(0,i.useContext)(s),...p,layoutId:E(p)},</span>{isStatic:y}=<span class="cstat-no" title="statement not covered" >g,</span>x=<span class="cstat-no" title="statement not covered" >v(p),</span>P=<span class="cstat-no" title="statement not covered" >u(p,y);<span class="cstat-no" title="statement not covered" ></span>if(!y&amp;&amp;T.j){<span class="cstat-no" title="statement not covered" >x.visualElement=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,u){const{visualElement:h}=<span class="cstat-no" title="statement not covered" >(0,i.useContext)(o),</span>d=<span class="cstat-no" title="statement not covered" >(0,i.useContext)(l),</span>p=<span class="cstat-no" title="statement not covered" >(0,i.useContext)(r.O),</span>m=<span class="cstat-no" title="statement not covered" >(0,i.useContext)(s).reducedMotion,</span>f=<span class="cstat-no" title="statement not covered" >(0,i.useRef)();<span class="cstat-no" title="statement not covered" ></span>u=u||d.renderer,!f.current&amp;&amp;u&amp;&amp;(f.current=u(t,{visualState:e,parent:h,props:n,presenceContext:p,blockInitialAnimation:!!p&amp;&amp;!1===p.initial,reducedMotionConfig:m}));c</span>onst g=<span class="cstat-no" title="statement not covered" >f.current;<span class="cstat-no" title="statement not covered" ></span>(0,i.useInsertionEffect)((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >g&amp;&amp;g.update(n,p)}</span>));c</span>onst y=<span class="cstat-no" title="statement not covered" >(0,i.useRef)(Boolean(n[c]&amp;&amp;!window.HandoffComplete));<span class="cstat-no" title="statement not covered" ></span>return(0,a.L)((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >g&amp;&amp;(g.render(),y.current&amp;&amp;g.animationState&amp;&amp;g.animationState.animateChanges())}</span>)),(0,i.useEffect)((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >g&amp;&amp;(g.updateFeatures(),!y.current&amp;&amp;g.animationState&amp;&amp;g.animationState.animateChanges(),y.current&amp;&amp;(y.current=!1,window.HandoffComplete=!0))}</span>)),g}</span>(d,P,g,e);c</span>onst n=<span class="cstat-no" title="statement not covered" >(0,i.useContext)(w),</span>u=<span class="cstat-no" title="statement not covered" >(0,i.useContext)(l).strict;<span class="cstat-no" title="statement not covered" ></span>x.visualElement&amp;&amp;(f=x.visualElement.loadFeatures(g,u,t,n))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i.createElement(o.Provider,{value:x},f&amp;&amp;x.visualElement?i.createElement(f,{visualElement:x.visualElement,...g}):null,n(d,p,<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >return(0,i.useCallback)((<span class="fstat-no" title="function not covered" >i=</span>&gt;{<span class="cstat-no" title="statement not covered" >i&amp;&amp;t.mount&amp;&amp;t.mount(i),e&amp;&amp;(i?e.mount(i):e.unmount()),n&amp;&amp;("function"===typeof n?n(i):h(n)&amp;&amp;(n.current=i))}</span>),[e])}</span>(P,x.visualElement,m),P,y,x.visualElement))}</span>));<span class="cstat-no" title="statement not covered" ></span>return p[A]=d,p}</span>function <span class="fstat-no" title="function not covered" >E(</span>{layoutId:t}){const e=<span class="cstat-no" title="statement not covered" >(0,i.useContext)(S.p).id;<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;void 0!==t?e+"-"+t:t}</span>function <span class="fstat-no" title="function not covered" >C(</span>t){function <span class="fstat-no" title="function not covered" >e(</span>e,n=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return V(t(e,n))}<span class="cstat-no" title="statement not covered" ></span>if("undefined"===typeof Proxy)<span class="cstat-no" title="statement not covered" >return e;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >new Map;<span class="cstat-no" title="statement not covered" ></span>return new Proxy(e,{get:<span class="fstat-no" title="function not covered" >(t</span>,i)=&gt;(<span class="cstat-no" title="statement not covered" >n.has(i)||n.set(i,e(i)),n.get(i))</span>})}</span>const D=<span class="cstat-no" title="statement not covered" >["animate","circle","defs","desc","ellipse","g","image","line","filter","marker","mask","metadata","path","pattern","polygon","polyline","rect","stop","switch","symbol","svg","text","tspan","use","view"];</span>function <span class="fstat-no" title="function not covered" >M(</span>t){<span class="cstat-no" title="statement not covered" >return"string"===typeof t&amp;&amp;!t.includes("-")&amp;&amp;!!(D.indexOf(t)&gt;-1||/[A-Z]/.test(t))}</span>const k=<span class="cstat-no" title="statement not covered" >{};</span>const R=<span class="cstat-no" title="statement not covered" >["transformPerspective","x","y","z","translateX","translateY","translateZ","scale","scaleX","scaleY","rotate","rotateX","rotateY","rotateZ","skew","skewX","skewY"],</span>L=<span class="cstat-no" title="statement not covered" >new Set(R);</span>function <span class="fstat-no" title="function not covered" >j(</span>t,{layout:e,layoutId:n}){<span class="cstat-no" title="statement not covered" >return L.has(t)||t.startsWith("origin")||(e||void 0!==n)&amp;&amp;(!!k[t]||"opacity"===t)}</span>const B=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Boolean(t&amp;&amp;t.getVelocity),</span></span>F=<span class="cstat-no" title="statement not covered" >{x:"translateX",y:"translateY",z:"translateZ",transformPerspective:"perspective"},</span>O=<span class="cstat-no" title="statement not covered" >R.length;</span>const I=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >"string"===typeof e&amp;&amp;e.startsWith(t),</span></span></span>U=<span class="cstat-no" title="statement not covered" >I("--"),</span>W=<span class="cstat-no" title="statement not covered" >I("var(--"),</span>N=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >e&amp;&amp;"number"===typeof t?e.transform(t):t,</span></span>$=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,n)=&gt;<span class="cstat-no" title="statement not covered" >Math.min(Math.max(n,t),e),</span></span>Z=<span class="cstat-no" title="statement not covered" >{test:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"number"===typeof t,</span>parse:parseFloat,transform:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t}</span>,</span>H=<span class="cstat-no" title="statement not covered" >{...Z,transform:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >$(0,1,t)}</span>,</span>z=<span class="cstat-no" title="statement not covered" >{...Z,default:1},</span>Y=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Math.round(1e5*t)/1e5,</span></span>X=<span class="cstat-no" title="statement not covered" >/(-)?([\d]*\.?[\d])+/g,</span>G=<span class="cstat-no" title="statement not covered" >/(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))/gi,</span>q=<span class="cstat-no" title="statement not covered" >/^(#[0-9a-f]{3,8}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2}(-?[\d\.]+%?)\s*[\,\/]?\s*[\d\.]*%?\))$/i;</span>function <span class="fstat-no" title="function not covered" >K(</span>t){<span class="cstat-no" title="statement not covered" >return"string"===typeof t}</span>const _=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >{test:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >K(e)&amp;&amp;e.endsWith(t)&amp;&amp;1===e.split(" ").length,</span>parse:parseFloat,transform:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >`${e}${t}`}</span>)</span>,</span>J=<span class="cstat-no" title="statement not covered" >_("deg"),</span>Q=<span class="cstat-no" title="statement not covered" >_("%"),</span>tt=<span class="cstat-no" title="statement not covered" >_("px"),</span>et=<span class="cstat-no" title="statement not covered" >_("vh"),</span>nt=<span class="cstat-no" title="statement not covered" >_("vw"),</span>it=<span class="cstat-no" title="statement not covered" >{...Q,parse:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Q.parse(t)/100,</span>transform:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Q.transform(100*t)}</span>,</span>st=<span class="cstat-no" title="statement not covered" >{...Z,transform:Math.round},</span>ot=<span class="cstat-no" title="statement not covered" >{borderWidth:tt,borderTopWidth:tt,borderRightWidth:tt,borderBottomWidth:tt,borderLeftWidth:tt,borderRadius:tt,radius:tt,borderTopLeftRadius:tt,borderTopRightRadius:tt,borderBottomRightRadius:tt,borderBottomLeftRadius:tt,width:tt,maxWidth:tt,height:tt,maxHeight:tt,size:tt,top:tt,right:tt,bottom:tt,left:tt,padding:tt,paddingTop:tt,paddingRight:tt,paddingBottom:tt,paddingLeft:tt,margin:tt,marginTop:tt,marginRight:tt,marginBottom:tt,marginLeft:tt,rotate:J,rotateX:J,rotateY:J,rotateZ:J,scale:z,scaleX:z,scaleY:z,scaleZ:z,skew:J,skewX:J,skewY:J,distance:tt,translateX:tt,translateY:tt,translateZ:tt,x:tt,y:tt,z:tt,perspective:tt,transformPerspective:tt,opacity:H,originX:it,originY:it,originZ:tt,zIndex:st,fillOpacity:H,strokeOpacity:H,numOctaves:st};</span>function <span class="fstat-no" title="function not covered" >rt(</span>t,e,n,i){const{style:s,vars:o,transform:r,transformOrigin:a}=<span class="cstat-no" title="statement not covered" >t;</span>let l=<span class="cstat-no" title="statement not covered" >!1,</span>u=<span class="cstat-no" title="statement not covered" >!1,</span>c=<span class="cstat-no" title="statement not covered" >!0;<span class="cstat-no" title="statement not covered" ></span>for(const h in e){const t=<span class="cstat-no" title="statement not covered" >e[h];<span class="cstat-no" title="statement not covered" ></span>if(U(h)){<span class="cstat-no" title="statement not covered" >o[h]=t;<span class="cstat-no" title="statement not covered" >c</span>ontinue}</span>c</span>onst n=<span class="cstat-no" title="statement not covered" >ot[h],</span>i=<span class="cstat-no" title="statement not covered" >N(t,n);<span class="cstat-no" title="statement not covered" ></span>if(L.has(h)){<span class="cstat-no" title="statement not covered" >if(l=!0,r[h]=i,!c)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >t</span></span>!==(n.default||0)&amp;&amp;(c=!1)}</span>else <span class="cstat-no" title="statement not covered" >h.startsWith("origin")?(u=!0,a[h]=i):s[h]=i}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(e.transform||(l||i?s.transform=<span class="fstat-no" title="function not covered" >fu</span>nction(t,{enableHardwareAcceleration:e=<span class="branch-0 cbranch-no" title="branch not covered" >!0,</span>allowTransformNone:n=<span class="branch-0 cbranch-no" title="branch not covered" >!0}</span>,i,s){let o=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>for(let r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;O;r++){const e=<span class="cstat-no" title="statement not covered" >R[r];<span class="cstat-no" title="statement not covered" ></span>void 0!==t[e]&amp;&amp;(o+=`${F[e]||e}(${t[e]}) `)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e&amp;&amp;!t.z&amp;&amp;(o+="translateZ(0)"),o=o.trim(),s?o=s(t,i?"":o):n&amp;&amp;i&amp;&amp;(o="none"),o}</span>(t.transform,n,c,i):s.transform&amp;&amp;(s.transform="none")),u){const{originX:t=<span class="branch-0 cbranch-no" title="branch not covered" >"50%",</span>originY:e=<span class="branch-0 cbranch-no" title="branch not covered" >"50%",</span>originZ:n=<span class="branch-0 cbranch-no" title="branch not covered" >0}</span>=<span class="cstat-no" title="statement not covered" >a;<span class="cstat-no" title="statement not covered" ></span>s.transformOrigin=`${t} ${e} ${n}`}</span>}</span>const at=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >{style:{},transform:{},transformOrigin:{},vars:{}})</span>;</span>function <span class="fstat-no" title="function not covered" >lt(</span>t,e,n){<span class="cstat-no" title="statement not covered" >for(const i in e)<span class="cstat-no" title="statement not covered" >B(e[i])||j(i,n)||(t[i]=e[i])}</span></span>function <span class="fstat-no" title="function not covered" >ut(</span>t,e,n){const s=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>return lt(s,t.style||{},t),Object.assign(s,<span class="fstat-no" title="function not covered" >fu</span>nction({transformTemplate:t},e,n){<span class="cstat-no" title="statement not covered" >return(0,i.useMemo)((<span class="fstat-no" title="function not covered" >()</span>=&gt;{const i=<span class="cstat-no" title="statement not covered" >{style:{},transform:{},transformOrigin:{},vars:{}};<span class="cstat-no" title="statement not covered" ></span>return rt(i,e,{enableHardwareAcceleration:!n},t),Object.assign({},i.vars,i.style)}</span>),[e])}</span>(t,e,n)),t.transformValues?t.transformValues(s):s}</span>function <span class="fstat-no" title="function not covered" >ct(</span>t,e,n){const i=<span class="cstat-no" title="statement not covered" >{},</span>s=<span class="cstat-no" title="statement not covered" >ut(t,e,n);<span class="cstat-no" title="statement not covered" ></span>return t.drag&amp;&amp;!1!==t.dragListener&amp;&amp;(i.draggable=!1,s.userSelect=s.WebkitUserSelect=s.WebkitTouchCallout="none",s.touchAction=!0===t.drag?"none":"pan-"+("x"===t.drag?"y":"x")),void 0===t.tabIndex&amp;&amp;(t.onTap||t.onTapStart||t.whileTap)&amp;&amp;(i.tabIndex=0),i.style=s,i}</span>const ht=<span class="cstat-no" title="statement not covered" >new Set(["animate","exit","variants","initial","style","values","variants","transition","transformTemplate","transformValues","custom","inherit","onBeforeLayoutMeasure","onAnimationStart","onAnimationComplete","onUpdate","onDragStart","onDrag","onDragEnd","onMeasureDragConstraints","onDirectionLock","onDragTransitionEnd","_dragX","_dragY","onHoverStart","onHoverEnd","onViewportEnter","onViewportLeave","globalTapTarget","ignoreStrict","viewport"]);</span>function <span class="fstat-no" title="function not covered" >dt(</span>t){<span class="cstat-no" title="statement not covered" >return t.startsWith("while")||t.startsWith("drag")&amp;&amp;"draggable"!==t||t.startsWith("layout")||t.startsWith("onTap")||t.startsWith("onPan")||t.startsWith("onLayout")||ht.has(t)}</span>let pt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!dt(t);<span class="cstat-no" title="statement not covered" ></span></span>try{<span class="cstat-no" title="statement not covered" >(mt=require("@emotion/is-prop-valid").default)&amp;&amp;(pt=<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.startsWith("on")?!dt(t):mt(t))</span>}</span>catch($o){}v</span>ar mt;function <span class="fstat-no" title="function not covered" >ft(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return"string"===typeof t?t:tt.transform(e+n*t)}</span>const gt=<span class="cstat-no" title="statement not covered" >{offset:"stroke-dashoffset",array:"stroke-dasharray"},</span>yt=<span class="cstat-no" title="statement not covered" >{offset:"strokeDashoffset",array:"strokeDasharray"};</span>function <span class="fstat-no" title="function not covered" >vt(</span>t,{attrX:e,attrY:n,attrScale:i,originX:s,originY:o,pathLength:r,pathSpacing:a=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>pathOffset:l=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>...u},c,h,d){<span class="cstat-no" title="statement not covered" >if(rt(t,u,c,d),h)<span class="cstat-no" title="statement not covered" >return void(t.style.viewBox&amp;&amp;(t.attrs.viewBox=t.style.viewBox));<span class="cstat-no" title="statement not covered" >t</span></span>.attrs=t.style,t.style={};c</span>onst{attrs:p,style:m,dimensions:f}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>p.transform&amp;&amp;(f&amp;&amp;(m.transform=p.transform),delete p.transform),f&amp;&amp;(void 0!==s||void 0!==o||m.transform)&amp;&amp;(m.transformOrigin=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){<span class="cstat-no" title="statement not covered" >return`${ft(e,t.x,t.width)} ${ft(n,t.y,t.height)}`}</span>(f,void 0!==s?s:.5,void 0!==o?o:.5)),void 0!==e&amp;&amp;(p.x=e),void 0!==n&amp;&amp;(p.y=n),void 0!==i&amp;&amp;(p.scale=i),void 0!==r&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>i=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>{<span class="cstat-no" title="statement not covered" >t.pathLength=1;c</span>onst o=<span class="cstat-no" title="statement not covered" >s?gt:yt;<span class="cstat-no" title="statement not covered" ></span>t[o.offset]=tt.transform(-i);c</span>onst r=<span class="cstat-no" title="statement not covered" >tt.transform(e),</span>a=<span class="cstat-no" title="statement not covered" >tt.transform(n);<span class="cstat-no" title="statement not covered" ></span>t[o.array]=`${r} ${a}`}</span>(p,r,a,l,!1)}</span>const xt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >{style:{},transform:{},transformOrigin:{},vars:{},attrs:{}})</span>,</span>Pt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"string"===typeof t&amp;&amp;"svg"===t.toLowerCase();</span></span>function <span class="fstat-no" title="function not covered" >bt(</span>t,e,n,s){const o=<span class="cstat-no" title="statement not covered" >(0,i.useMemo)((<span class="fstat-no" title="function not covered" >()</span>=&gt;{const n=<span class="cstat-no" title="statement not covered" >{style:{},transform:{},transformOrigin:{},vars:{},attrs:{}};<span class="cstat-no" title="statement not covered" ></span>return vt(n,e,{enableHardwareAcceleration:!1},Pt(s),t.transformTemplate),{...n.attrs,style:{...n.style}}}</span>),[e]);<span class="cstat-no" title="statement not covered" ></span>if(t.style){const e=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>lt(e,t.style,t),o.style={...e,...o.style}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o}</span>function <span class="fstat-no" title="function not covered" >Tt(</span>t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >return<span class="fstat-no" title="function not covered" >(e</span>,n,s,{latestValues:o},r)=&gt;{const a=<span class="cstat-no" title="statement not covered" >(M(e)?bt:ct)(n,o,r,e),</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){const i=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(const s in t)<span class="cstat-no" title="statement not covered" >"values"===s&amp;&amp;"object"===typeof t.values||(pt(s)||!0===n&amp;&amp;dt(s)||!e&amp;&amp;!dt(s)||t.draggable&amp;&amp;s.startsWith("onDrag"))&amp;&amp;(i[s]=t[s]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>(n,"string"===typeof e,t),</span>u=<span class="cstat-no" title="statement not covered" >{...l,...a,ref:s},</span>{children:c}=<span class="cstat-no" title="statement not covered" >n,</span>h=<span class="cstat-no" title="statement not covered" >(0,i.useMemo)((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >B(c)?c.get():c)</span>,[c]);<span class="cstat-no" title="statement not covered" ></span>return(0,i.createElement)(e,{...u,children:h})}</span>}</span>function <span class="fstat-no" title="function not covered" >St(</span>t,{style:e,vars:n},i,s){<span class="cstat-no" title="statement not covered" >Object.assign(t.style,e,s&amp;&amp;s.getProjectionStyles(i));<span class="cstat-no" title="statement not covered" >f</span>or(const o in n)<span class="cstat-no" title="statement not covered" >t.style.setProperty(o,n[o])}</span></span>const wt=<span class="cstat-no" title="statement not covered" >new Set(["baseFrequency","diffuseConstant","kernelMatrix","kernelUnitLength","keySplines","keyTimes","limitingConeAngle","markerHeight","markerWidth","numOctaves","targetX","targetY","surfaceScale","specularConstant","specularExponent","stdDeviation","tableValues","viewBox","gradientTransform","pathLength","startOffset","textLength","lengthAdjust"]);</span>function <span class="fstat-no" title="function not covered" >At(</span>t,e,n,i){<span class="cstat-no" title="statement not covered" >St(t,e,void 0,i);<span class="cstat-no" title="statement not covered" >f</span>or(const s in e.attrs)<span class="cstat-no" title="statement not covered" >t.setAttribute(wt.has(s)?s:u(s),e.attrs[s])}</span></span>function <span class="fstat-no" title="function not covered" >Vt(</span>t,e){const{style:n}=<span class="cstat-no" title="statement not covered" >t,</span>i=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(const s in n)<span class="cstat-no" title="statement not covered" >(B(n[s])||e.style&amp;&amp;B(e.style[s])||j(s,t))&amp;&amp;(i[s]=n[s]);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>function <span class="fstat-no" title="function not covered" >Et(</span>t,e){const n=<span class="cstat-no" title="statement not covered" >Vt(t,e);<span class="cstat-no" title="statement not covered" ></span>for(const i in t)<span class="cstat-no" title="statement not covered" >if(B(t[i])||B(e[i])){<span class="cstat-no" title="statement not covered" >n[-1!==R.indexOf(i)?"attr"+i.charAt(0).toUpperCase()+i.substring(1):i]=t[i]}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn n}</span>function <span class="fstat-no" title="function not covered" >Ct(</span>t,e,n,i=<span class="branch-0 cbranch-no" title="branch not covered" >{},</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return"function"===typeof e&amp;&amp;(e=e(void 0!==n?n:t.custom,i,s)),"string"===typeof e&amp;&amp;(e=t.variants&amp;&amp;t.variants[e]),"function"===typeof e&amp;&amp;(e=e(void 0!==n?n:t.custom,i,s)),e}</span>var Dt=<span class="cstat-no" title="statement not covered" >n(34349);</span>const Mt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Array.isArray(t);</span></span>function <span class="fstat-no" title="function not covered" >kt(</span>t){const e=<span class="cstat-no" title="statement not covered" >B(t)?t.get():t;<span class="cstat-no" title="statement not covered" ></span>return n=e,Boolean(n&amp;&amp;"object"===typeof n&amp;&amp;n.mix&amp;&amp;n.toValue)?e.toValue():e;v</span>ar n}const Rt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,n)=&gt;{const s=<span class="cstat-no" title="statement not covered" >(0,i.useContext)(o),</span>a=<span class="cstat-no" title="statement not covered" >(0,i.useContext)(r.O),</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction({scrapeMotionValuesFromProps:t,createRenderState:e,onMount:n},i,s,o){const r=<span class="cstat-no" title="statement not covered" >{latestValues:Lt(i,s,o,t),renderState:e()};<span class="cstat-no" title="statement not covered" ></span>return n&amp;&amp;(r.mount=<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >n(i,t,r))</span>,r}</span>(t,e,s,a);<span class="cstat-no" title="statement not covered" ></span></span>return n?l():(0,Dt.h)(l)}</span>;</span></span>function <span class="fstat-no" title="function not covered" >Lt(</span>t,e,n,i){const s=<span class="cstat-no" title="statement not covered" >{},</span>o=<span class="cstat-no" title="statement not covered" >i(t,{});<span class="cstat-no" title="statement not covered" ></span>for(const d in o)<span class="cstat-no" title="statement not covered" >s[d]=kt(o[d]);l</span></span>et{initial:r,animate:a}=<span class="cstat-no" title="statement not covered" >t;</span>const l=<span class="cstat-no" title="statement not covered" >g(t),</span>u=<span class="cstat-no" title="statement not covered" >y(t);<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;u&amp;&amp;!l&amp;&amp;!1!==t.inherit&amp;&amp;(void 0===r&amp;&amp;(r=e.initial),void 0===a&amp;&amp;(a=e.animate));l</span>et c=<span class="cstat-no" title="statement not covered" >!!n&amp;&amp;!1===n.initial;<span class="cstat-no" title="statement not covered" ></span>c=c||!1===r;c</span>onst h=<span class="cstat-no" title="statement not covered" >c?a:r;<span class="cstat-no" title="statement not covered" ></span>if(h&amp;&amp;"boolean"!==typeof h&amp;&amp;!p(h)){<span class="cstat-no" title="statement not covered" >(Array.isArray(h)?h:[h]).forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >Ct(t,e);<span class="cstat-no" title="statement not covered" ></span>if(!n)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{transitionEnd:i,transition:o,...r}=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>for(const t in r){let e=<span class="cstat-no" title="statement not covered" >r[t];<span class="cstat-no" title="statement not covered" ></span>if(Array.isArray(e)){<span class="cstat-no" title="statement not covered" >e=e[c?e.length-1:0]}<span class="cstat-no" title="statement not covered" ></span>n</span>ull!==e&amp;&amp;(s[t]=e)}<span class="cstat-no" title="statement not covered" ></span>f</span>or(const t in i)<span class="cstat-no" title="statement not covered" >s[t]=i[t]}</span></span>))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn s}</span>var jt=<span class="cstat-no" title="statement not covered" >n(89195);</span>const Bt=<span class="cstat-no" title="statement not covered" >{useVisualState:Rt({scrapeMotionValuesFromProps:Et,createRenderState:xt,onMount:<span class="fstat-no" title="function not covered" >(t</span>,e,{renderState:n,latestValues:i})=&gt;{<span class="cstat-no" title="statement not covered" >jt.Wi.read((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >n.dimensions="function"===typeof e.getBBox?e.getBBox():e.getBoundingClientRect()}</span>catch(t){<span class="cstat-no" title="statement not covered" >n.dimensions={x:0,y:0,width:0,height:0}}</span>}</span>)),jt.Wi.render((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >vt(n,i,{enableHardwareAcceleration:!1},Pt(e.tagName),t.transformTemplate),At(e,n)}</span>))}</span>})},</span>Ft=<span class="cstat-no" title="statement not covered" >{useVisualState:Rt({scrapeMotionValuesFromProps:Vt,createRenderState:at})};</span>function <span class="fstat-no" title="function not covered" >Ot(</span>t,e,n,i=<span class="branch-0 cbranch-no" title="branch not covered" >{passive:!0})</span>{<span class="cstat-no" title="statement not covered" >return t.addEventListener(e,n,i),<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.removeEventListener(e,n)}</span></span>const It=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"mouse"===t.pointerType?"number"!==typeof t.button||t.button&lt;=0:!1!==t.isPrimary;</span></span>function <span class="fstat-no" title="function not covered" >Ut(</span>t,e=<span class="branch-0 cbranch-no" title="branch not covered" >"page")</span>{<span class="cstat-no" title="statement not covered" >return{point:{x:t[e+"X"],y:t[e+"Y"]}}}</span>function <span class="fstat-no" title="function not covered" >Wt(</span>t,e,n,i){<span class="cstat-no" title="statement not covered" >return Ot(t,e,(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >It(e)&amp;&amp;t(e,Ut(e)))</span></span>(n),i)}</span>const Nt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >e(t(n)),</span></span></span>$t=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(.</span>..t)=&gt;<span class="cstat-no" title="statement not covered" >t.reduce(Nt);</span></span>function <span class="fstat-no" title="function not covered" >Zt(</span>t){let e=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>return<span class="fstat-no" title="function not covered" >()</span>=&gt;{const n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >e=null}</span>;<span class="cstat-no" title="statement not covered" ></span>return null===e&amp;&amp;(e=t,n)}</span>}</span>const Ht=<span class="cstat-no" title="statement not covered" >Zt("dragHorizontal"),</span>zt=<span class="cstat-no" title="statement not covered" >Zt("dragVertical");</span>function <span class="fstat-no" title="function not covered" >Yt(</span>t){let e=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if("y"===t)<span class="cstat-no" title="statement not covered" >e=zt();e</span>lse <span class="cstat-no" title="statement not covered" >if("x"===t)<span class="cstat-no" title="statement not covered" >e=Ht();e</span>lse{const t=<span class="cstat-no" title="statement not covered" >Ht(),</span>n=<span class="cstat-no" title="statement not covered" >zt();<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;n?e=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t(),n()}</span>:(t&amp;&amp;t(),n&amp;&amp;n())}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn e}</span>function <span class="fstat-no" title="function not covered" >Xt(</span>){const t=<span class="cstat-no" title="statement not covered" >Yt(!0);<span class="cstat-no" title="statement not covered" ></span>return!t||(t(),!1)}</span>class Gt{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.isMounted=!1,this.node=t}<span class="fstat-no" title="function not covered" ></span>up</span>date(){}}function <span class="fstat-no" title="function not covered" >qt(</span>t,e){const n=<span class="cstat-no" title="statement not covered" >"pointer"+(e?"enter":"leave"),</span>i=<span class="cstat-no" title="statement not covered" >"onHover"+(e?"Start":"End");<span class="cstat-no" title="statement not covered" ></span>return Wt(t.current,n,(<span class="fstat-no" title="function not covered" >(n</span>,s)=&gt;{<span class="cstat-no" title="statement not covered" >if("touch"===n.pointerType||Xt())<span class="cstat-no" title="statement not covered" >return;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >t.getProps();<span class="cstat-no" title="statement not covered" ></span>t.animationState&amp;&amp;o.whileHover&amp;&amp;t.animationState.setActive("whileHover",e),o[i]&amp;&amp;jt.Wi.update((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >o[i](n,s))</span>)}</span>),{passive:!t.getProps()[i]})}</span>const Kt=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >!!e&amp;&amp;(t===e||Kt(t,e.parentElement));</span></span>var _t=<span class="cstat-no" title="statement not covered" >n(41279);</span>function <span class="fstat-no" title="function not covered" >Jt(</span>t,e){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >new PointerEvent("pointer"+t);<span class="cstat-no" title="statement not covered" ></span>e(n,Ut(n))}</span>const Qt=<span class="cstat-no" title="statement not covered" >new WeakMap,</span>te=<span class="cstat-no" title="statement not covered" >new WeakMap,</span>ee=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >Qt.get(t.target);<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;e(t)}</span>,</span>ne=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.forEach(ee)}</span>;</span>function <span class="fstat-no" title="function not covered" >ie(</span>t,e,n){const i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction({root:t,...e}){const n=<span class="cstat-no" title="statement not covered" >t||document;<span class="cstat-no" title="statement not covered" ></span>te.has(n)||te.set(n,{});c</span>onst i=<span class="cstat-no" title="statement not covered" >te.get(n),</span>s=<span class="cstat-no" title="statement not covered" >JSON.stringify(e);<span class="cstat-no" title="statement not covered" ></span>return i[s]||(i[s]=new IntersectionObserver(ne,{root:t,...e})),i[s]}</span>(e);<span class="cstat-no" title="statement not covered" ></span>return Qt.set(t,n),i.observe(t),<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >Qt.delete(t),i.unobserve(t)}</span>}</span>const se=<span class="cstat-no" title="statement not covered" >{some:0,all:1};</span>const oe=<span class="cstat-no" title="statement not covered" >{inView:{Feature:class extends Gt{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(...arguments),this.hasEnteredView=!1,this.isInView=!1}<span class="fstat-no" title="function not covered" ></span>st</span>artObserver(){<span class="cstat-no" title="statement not covered" >this.unmount();c</span>onst{viewport:t=<span class="branch-0 cbranch-no" title="branch not covered" >{}}</span>=<span class="cstat-no" title="statement not covered" >this.node.getProps(),</span>{root:e,margin:n,amount:i=<span class="branch-0 cbranch-no" title="branch not covered" >"some",</span>once:s}=<span class="cstat-no" title="statement not covered" >t,</span>o=<span class="cstat-no" title="statement not covered" >{root:e?e.current:void 0,rootMargin:n,threshold:"number"===typeof i?i:se[i]};<span class="cstat-no" title="statement not covered" ></span>return ie(this.node.current,o,(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const{isIntersecting:e}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if(this.isInView===e)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(this.isInView=e,s&amp;&amp;!e&amp;&amp;this.hasEnteredView)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >e</span></span>&amp;&amp;(this.hasEnteredView=!0),this.node.animationState&amp;&amp;this.node.animationState.setActive("whileInView",e);c</span>onst{onViewportEnter:n,onViewportLeave:i}=<span class="cstat-no" title="statement not covered" >this.node.getProps(),</span>o=<span class="cstat-no" title="statement not covered" >e?n:i;<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;o(t)}</span>))}<span class="fstat-no" title="function not covered" ></span>mo</span>unt(){<span class="cstat-no" title="statement not covered" >this.startObserver()}<span class="fstat-no" title="function not covered" ></span>up</span>date(){<span class="cstat-no" title="statement not covered" >if("undefined"===typeof IntersectionObserver)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{props:t,prevProps:e}=<span class="cstat-no" title="statement not covered" >this.node;<span class="cstat-no" title="statement not covered" ></span>["amount","margin","root"].some(<span class="fstat-no" title="function not covered" >fu</span>nction({viewport:t=<span class="branch-0 cbranch-no" title="branch not covered" >{}}</span>,{viewport:e=<span class="branch-0 cbranch-no" title="branch not covered" >{}}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >t[n]!==e[n]}</span></span>(t,e))&amp;&amp;this.startObserver()}<span class="fstat-no" title="function not covered" ></span>un</span>mount(){}}},tap:{Feature:class extends Gt{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(...arguments),this.removeStartListeners=_t.Z,this.removeEndListeners=_t.Z,this.removeAccessibleListeners=_t.Z,this.startPointerPress=<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >if(this.isPressing)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.removeEndListeners();c</span>onst n=<span class="cstat-no" title="statement not covered" >this.node.getProps(),</span>i=<span class="cstat-no" title="statement not covered" >Wt(window,"pointerup",(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >if(!this.checkPressEnd())<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{onTap:n,onTapCancel:i,globalTapTarget:s}=<span class="cstat-no" title="statement not covered" >this.node.getProps();<span class="cstat-no" title="statement not covered" ></span>jt.Wi.update((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >s||Kt(this.node.current,t.target)?n&amp;&amp;n(t,e):i&amp;&amp;i(t,e)}</span>))}</span>),{passive:!(n.onTap||n.onPointerUp)}),</span>s=<span class="cstat-no" title="statement not covered" >Wt(window,"pointercancel",(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >this.cancelPress(t,e))</span>,{passive:!(n.onTapCancel||n.onPointerCancel)});<span class="cstat-no" title="statement not covered" ></span>this.removeEndListeners=$t(i,s),this.startPress(t,e)}</span>,this.startAccessiblePress=<span class="fstat-no" title="function not covered" >()</span>=&gt;{const t=<span class="cstat-no" title="statement not covered" >Ot(this.node.current,"keydown",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >if("Enter"!==t.key||this.isPressing)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.removeEndListeners(),this.removeEndListeners=Ot(this.node.current,"keyup",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >"Enter"===t.key&amp;&amp;this.checkPressEnd()&amp;&amp;Jt("up",(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{const{onTap:n}=<span class="cstat-no" title="statement not covered" >this.node.getProps();<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;jt.Wi.update((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >n(t,e))</span>)}</span>))}</span>)),Jt("down",(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >this.startPress(t,e)}</span>))}</span>)),</span>e=<span class="cstat-no" title="statement not covered" >Ot(this.node.current,"blur",(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.isPressing&amp;&amp;Jt("cancel",(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >this.cancelPress(t,e))</span>)}</span>));<span class="cstat-no" title="statement not covered" ></span>this.removeAccessibleListeners=$t(t,e)}</span>}<span class="fstat-no" title="function not covered" ></span>st</span>artPress(t,e){<span class="cstat-no" title="statement not covered" >this.isPressing=!0;c</span>onst{onTapStart:n,whileTap:i}=<span class="cstat-no" title="statement not covered" >this.node.getProps();<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;this.node.animationState&amp;&amp;this.node.animationState.setActive("whileTap",!0),n&amp;&amp;jt.Wi.update((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >n(t,e))</span>)}<span class="fstat-no" title="function not covered" ></span>ch</span>eckPressEnd(){<span class="cstat-no" title="statement not covered" >this.removeEndListeners(),this.isPressing=!1;<span class="cstat-no" title="statement not covered" >r</span>eturn this.node.getProps().whileTap&amp;&amp;this.node.animationState&amp;&amp;this.node.animationState.setActive("whileTap",!1),!Xt()}<span class="fstat-no" title="function not covered" ></span>ca</span>ncelPress(t,e){<span class="cstat-no" title="statement not covered" >if(!this.checkPressEnd())<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{onTapCancel:n}=<span class="cstat-no" title="statement not covered" >this.node.getProps();<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;jt.Wi.update((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >n(t,e))</span>)}<span class="fstat-no" title="function not covered" ></span>mo</span>unt(){const t=<span class="cstat-no" title="statement not covered" >this.node.getProps(),</span>e=<span class="cstat-no" title="statement not covered" >Wt(t.globalTapTarget?window:this.node.current,"pointerdown",this.startPointerPress,{passive:!(t.onTapStart||t.onPointerStart)}),</span>n=<span class="cstat-no" title="statement not covered" >Ot(this.node.current,"focus",this.startAccessiblePress);<span class="cstat-no" title="statement not covered" ></span>this.removeStartListeners=$t(e,n)}<span class="fstat-no" title="function not covered" ></span>un</span>mount(){<span class="cstat-no" title="statement not covered" >this.removeStartListeners(),this.removeEndListeners(),this.removeAccessibleListeners()}</span>}},focus:{Feature:class extends Gt{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(...arguments),this.isActive=!1}<span class="fstat-no" title="function not covered" ></span>on</span>Focus(){let t=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>try{<span class="cstat-no" title="statement not covered" >t=this.node.current.matches(":focus-visible")}</span>catch(e){<span class="cstat-no" title="statement not covered" >t=!0}<span class="cstat-no" title="statement not covered" ></span>t</span>&amp;&amp;this.node.animationState&amp;&amp;(this.node.animationState.setActive("whileFocus",!0),this.isActive=!0)}<span class="fstat-no" title="function not covered" ></span>on</span>Blur(){<span class="cstat-no" title="statement not covered" >this.isActive&amp;&amp;this.node.animationState&amp;&amp;(this.node.animationState.setActive("whileFocus",!1),this.isActive=!1)}<span class="fstat-no" title="function not covered" ></span>mo</span>unt(){<span class="cstat-no" title="statement not covered" >this.unmount=$t(Ot(this.node.current,"focus",(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.onFocus())</span>),Ot(this.node.current,"blur",(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.onBlur())</span>))}<span class="fstat-no" title="function not covered" ></span>un</span>mount(){}}},hover:{Feature:class extends Gt{<span class="fstat-no" title="function not covered" >mo</span>unt(){<span class="cstat-no" title="statement not covered" >this.unmount=$t(qt(this.node,!0),qt(this.node,!1))}<span class="fstat-no" title="function not covered" ></span>un</span>mount(){}}}};</span>function <span class="fstat-no" title="function not covered" >re(</span>t,e){<span class="cstat-no" title="statement not covered" >if(!Array.isArray(e))<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >e.length;<span class="cstat-no" title="statement not covered" ></span>if(n!==t.length)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >f</span></span>or(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;n;i++)<span class="cstat-no" title="statement not covered" >if(e[i]!==t[i])<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!0}</span>function <span class="fstat-no" title="function not covered" >ae(</span>t,e,n){const i=<span class="cstat-no" title="statement not covered" >t.getProps();<span class="cstat-no" title="statement not covered" ></span>return Ct(i,e,void 0!==n?n:i.custom,<span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>return t.values.forEach((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >e[n]=t.get())</span>),e}</span>(t),<span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>return t.values.forEach((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >e[n]=t.getVelocity())</span>),e}</span>(t))}</span>var le=<span class="cstat-no" title="statement not covered" >n(47279);</span>const ue=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >1e3*t,</span></span>ce=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t/1e3,</span></span>he=<span class="cstat-no" title="statement not covered" >!1,</span>de=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Array.isArray(t)&amp;&amp;"number"===typeof t[0];</span></span>function <span class="fstat-no" title="function not covered" >pe(</span>t){<span class="cstat-no" title="statement not covered" >return Boolean(!t||"string"===typeof t&amp;&amp;fe[t]||de(t)||Array.isArray(t)&amp;&amp;t.every(pe))}</span>const me=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >([</span>t,e,n,i])=&gt;<span class="cstat-no" title="statement not covered" >`cubic-bezier(${t}, ${e}, ${n}, ${i})`,</span></span>fe=<span class="cstat-no" title="statement not covered" >{linear:"linear",ease:"ease",easeIn:"ease-in",easeOut:"ease-out",easeInOut:"ease-in-out",circIn:me([0,.65,.55,1]),circOut:me([.55,0,1,.45]),backIn:me([.31,.01,.66,-.59]),backOut:me([.33,1.53,.69,.99])};</span>function <span class="fstat-no" title="function not covered" >ge(</span>t){<span class="cstat-no" title="statement not covered" >if(t)<span class="cstat-no" title="statement not covered" >return de(t)?me(t):Array.isArray(t)?t.map(ge):fe[t]}</span></span>const ye=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,n)=&gt;<span class="cstat-no" title="statement not covered" >(((1-3*n+3*e)*t+(3*n-6*e))*t+3*e)*t;</span></span>function <span class="fstat-no" title="function not covered" >ve(</span>t,e,n,i){<span class="cstat-no" title="statement not covered" >if(t===e&amp;&amp;n===i)<span class="cstat-no" title="statement not covered" >return _t.Z;c</span></span>onst s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,i,s){let o,r,a=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>do{<span class="cstat-no" title="statement not covered" >r=e+(n-e)/2,o=ye(r,i,s)-t,o&gt;0?n=r:e=r}</span>while(Math.abs(o)&gt;1e-7&amp;&amp;++a&lt;12);<span class="cstat-no" title="statement not covered" >r</span>eturn r}</span>(e,0,1,t,n);<span class="cstat-no" title="statement not covered" ></span></span>return <span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >0===t||1===t?t:ye(s(t),e,i)}</span></span>const xe=<span class="cstat-no" title="statement not covered" >ve(.42,0,1,1),</span>Pe=<span class="cstat-no" title="statement not covered" >ve(0,0,.58,1),</span>be=<span class="cstat-no" title="statement not covered" >ve(.42,0,.58,1),</span>Te=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e&lt;=.5?t(2*e)/2:(2-t(2*(1-e)))/2,</span></span></span>Se=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >1-t(1-e),</span></span></span>we=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >1-Math.sin(Math.acos(t)),</span></span>Ae=<span class="cstat-no" title="statement not covered" >Se(we),</span>Ve=<span class="cstat-no" title="statement not covered" >Te(we),</span>Ee=<span class="cstat-no" title="statement not covered" >ve(.33,1.53,.69,.99),</span>Ce=<span class="cstat-no" title="statement not covered" >Se(Ee),</span>De=<span class="cstat-no" title="statement not covered" >Te(Ce),</span>Me=<span class="cstat-no" title="statement not covered" >{linear:_t.Z,easeIn:xe,easeInOut:be,easeOut:Pe,circIn:we,circInOut:Ve,circOut:Ae,backIn:Ce,backInOut:De,backOut:Ee,anticipate:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >(t*=2)&lt;1?.5*Ce(t):.5*(2-Math.pow(2,-10*(t-1)))}</span>,</span>ke=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(Array.isArray(t)){<span class="cstat-no" title="statement not covered" >(0,le.k)(4===t.length,"Cubic bezier arrays must contain four numerical values.");c</span>onst[e,n,i,s]=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return ve(e,n,i,s)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn"string"===typeof t?((0,le.k)(void 0!==Me[t],`Invalid easing type '${t}'`),Me[t]):t}</span>,</span>Re=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >Boolean(K(n)&amp;&amp;q.test(n)&amp;&amp;n.startsWith(t)||e&amp;&amp;Object.prototype.hasOwnProperty.call(n,e)),</span></span></span>Le=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,n)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >i=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!K(i))<span class="cstat-no" title="statement not covered" >return i;c</span></span>onst[s,o,r,a]=<span class="cstat-no" title="statement not covered" >i.match(X);<span class="cstat-no" title="statement not covered" ></span>return{[t]:parseFloat(s),[e]:parseFloat(o),[n]:parseFloat(r),alpha:void 0!==a?parseFloat(a):1}}</span>,</span></span>je=<span class="cstat-no" title="statement not covered" >{...Z,transform:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Math.round((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >$(0,255,t))</span>(t))}</span>,</span>Be=<span class="cstat-no" title="statement not covered" >{test:Re("rgb","red"),parse:Le("red","green","blue"),transform:<span class="fstat-no" title="function not covered" >({</span>red:t,green:e,blue:n,alpha:i=<span class="branch-0 cbranch-no" title="branch not covered" >1}</span>)=&gt;<span class="cstat-no" title="statement not covered" >"rgba("+je.transform(t)+", "+je.transform(e)+", "+je.transform(n)+", "+Y(H.transform(i))+")"}</span>;</span>const Fe=<span class="cstat-no" title="statement not covered" >{test:Re("#"),parse:<span class="fstat-no" title="function not covered" >fu</span>nction(t){let e=<span class="cstat-no" title="statement not covered" >"",</span>n=<span class="cstat-no" title="statement not covered" >"",</span>i=<span class="cstat-no" title="statement not covered" >"",</span>s=<span class="cstat-no" title="statement not covered" >"";<span class="cstat-no" title="statement not covered" ></span>return t.length&gt;5?(e=t.substring(1,3),n=t.substring(3,5),i=t.substring(5,7),s=t.substring(7,9)):(e=t.substring(1,2),n=t.substring(2,3),i=t.substring(3,4),s=t.substring(4,5),e+=e,n+=n,i+=i,s+=s),{red:parseInt(e,16),green:parseInt(n,16),blue:parseInt(i,16),alpha:s?parseInt(s,16)/255:1}}</span>,transform:Be.transform},</span>Oe=<span class="cstat-no" title="statement not covered" >{test:Re("hsl","hue"),parse:Le("hue","saturation","lightness"),transform:<span class="fstat-no" title="function not covered" >({</span>hue:t,saturation:e,lightness:n,alpha:i=<span class="branch-0 cbranch-no" title="branch not covered" >1}</span>)=&gt;<span class="cstat-no" title="statement not covered" >"hsla("+Math.round(t)+", "+Q.transform(Y(e))+", "+Q.transform(Y(n))+", "+Y(H.transform(i))+")"}</span>,</span>Ie=<span class="cstat-no" title="statement not covered" >{test:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Be.test(t)||Fe.test(t)||Oe.test(t),</span>parse:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Be.test(t)?Be.parse(t):Oe.test(t)?Oe.parse(t):Fe.parse(t),</span>transform:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >K(t)?t:t.hasOwnProperty("red")?Be.transform(t):Oe.transform(t)}</span>,</span>Ue=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,n)=&gt;<span class="cstat-no" title="statement not covered" >-n*t+n*e+t;</span></span>function <span class="fstat-no" title="function not covered" >We(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return n&lt;0&amp;&amp;(n+=1),n&gt;1&amp;&amp;(n-=1),n&lt;1/6?t+6*(e-t)*n:n&lt;.5?e:n&lt;2/3?t+(e-t)*(2/3-n)*6:t}</span>const Ne=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,n)=&gt;{const i=<span class="cstat-no" title="statement not covered" >t*t;<span class="cstat-no" title="statement not covered" ></span>return Math.sqrt(Math.max(0,n*(e*e-i)+i))}</span>,</span>$e=<span class="cstat-no" title="statement not covered" >[Fe,Be,Oe];</span>function <span class="fstat-no" title="function not covered" >Ze(</span>t){const e=(<span class="cstat-no" title="statement not covered" >n=t,$e.find((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.test(n))</span>))</span>;var n;<span class="cstat-no" title="statement not covered" >(0,le.k)(Boolean(e),`'${t}' is not an animatable color. Use the equivalent color code instead.`);l</span>et i=<span class="cstat-no" title="statement not covered" >e.parse(t);<span class="cstat-no" title="statement not covered" ></span>return e===Oe&amp;&amp;(i=<span class="fstat-no" title="function not covered" >fu</span>nction({hue:t,saturation:e,lightness:n,alpha:i}){<span class="cstat-no" title="statement not covered" >t/=360,n/=100;l</span>et s=<span class="cstat-no" title="statement not covered" >0,</span>o=<span class="cstat-no" title="statement not covered" >0,</span>r=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(e/=100){const i=<span class="cstat-no" title="statement not covered" >n&lt;.5?n*(1+e):n+e-n*e,</span>a=<span class="cstat-no" title="statement not covered" >2*n-i;<span class="cstat-no" title="statement not covered" ></span>s=We(a,i,t+1/3),o=We(a,i,t),r=We(a,i,t-1/3)}</span>else <span class="cstat-no" title="statement not covered" >s=o=r=n;<span class="cstat-no" title="statement not covered" >r</span></span>eturn{red:Math.round(255*s),green:Math.round(255*o),blue:Math.round(255*r),alpha:i}}</span>(i)),i}</span>const He=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{const n=<span class="cstat-no" title="statement not covered" >Ze(t),</span>i=<span class="cstat-no" title="statement not covered" >Ze(e),</span>s=<span class="cstat-no" title="statement not covered" >{...n};<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >s.red=Ne(n.red,i.red,t),s.green=Ne(n.green,i.green,t),s.blue=Ne(n.blue,i.blue,t),s.alpha=Ue(n.alpha,i.alpha,t),Be.transform(s))</span>}</span>;</span>const ze=<span class="cstat-no" title="statement not covered" >{regex:/var\s*\(\s*--[\w-]+(\s*,\s*(?:(?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)+)?\s*\)/g,countKey:"Vars",token:"${v}",parse:_t.Z},</span>Ye=<span class="cstat-no" title="statement not covered" >{regex:G,countKey:"Colors",token:"${c}",parse:Ie.parse},</span>Xe=<span class="cstat-no" title="statement not covered" >{regex:X,countKey:"Numbers",token:"${n}",parse:Z.parse};</span>function <span class="fstat-no" title="function not covered" >Ge(</span>t,{regex:e,countKey:n,token:i,parse:s}){const o=<span class="cstat-no" title="statement not covered" >t.tokenised.match(e);<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;(t["num"+n]=o.length,t.tokenised=t.tokenised.replace(e,i),t.values.push(...o.map(s)))}</span>function <span class="fstat-no" title="function not covered" >qe(</span>t){const e=<span class="cstat-no" title="statement not covered" >t.toString(),</span>n=<span class="cstat-no" title="statement not covered" >{value:e,tokenised:e,values:[],numVars:0,numColors:0,numNumbers:0};<span class="cstat-no" title="statement not covered" ></span>return n.value.includes("var(--")&amp;&amp;Ge(n,ze),Ge(n,Ye),Ge(n,Xe),n}</span>function <span class="fstat-no" title="function not covered" >Ke(</span>t){<span class="cstat-no" title="statement not covered" >return qe(t).values}</span>function <span class="fstat-no" title="function not covered" >_e(</span>t){const{values:e,numColors:n,numVars:i,tokenised:s}=<span class="cstat-no" title="statement not covered" >qe(t),</span>o=<span class="cstat-no" title="statement not covered" >e.length;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >t=</span>&gt;{let e=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;o;s++)<span class="cstat-no" title="statement not covered" >e=s&lt;i?e.replace(ze.token,t[s]):s&lt;i+n?e.replace(Ye.token,Ie.transform(t[s])):e.replace(Xe.token,Y(t[s]));<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>}</span>const Je=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"number"===typeof t?0:t;</span></span>const Qe=<span class="cstat-no" title="statement not covered" >{test:<span class="fstat-no" title="function not covered" >fu</span>nction(t){var e,n;<span class="cstat-no" title="statement not covered" >return isNaN(t)&amp;&amp;K(t)&amp;&amp;((null===(e=t.match(X))||void 0===e?void 0:e.length)||0)+((null===(n=t.match(G))||void 0===n?void 0:n.length)||0)&gt;0}</span>,parse:Ke,createTransformer:_e,getAnimatableNone:<span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >Ke(t);<span class="cstat-no" title="statement not covered" ></span>return _e(t)(e.map(Je))}</span>},</span>tn=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >`${n&gt;0?e:t}`;</span></span></span>function <span class="fstat-no" title="function not covered" >en(</span>t,e){<span class="cstat-no" title="statement not covered" >return"number"===typeof t?<span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >Ue(t,e,n):</span>Ie.test(t)?He(t,e):t.startsWith("var(")?tn(t,e):on(t,e)}</span>const nn=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{const n=<span class="cstat-no" title="statement not covered" >[...t],</span>i=<span class="cstat-no" title="statement not covered" >n.length,</span>s=<span class="cstat-no" title="statement not covered" >t.map((<span class="fstat-no" title="function not covered" >(t</span>,n)=&gt;<span class="cstat-no" title="statement not covered" >en(t,e[n]))</span>);<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;i;e++)<span class="cstat-no" title="statement not covered" >n[e]=s[e](t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>}</span>,</span>sn=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{const n=<span class="cstat-no" title="statement not covered" >{...t,...e},</span>i=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(const s in n)<span class="cstat-no" title="statement not covered" >void 0!==t[s]&amp;&amp;void 0!==e[s]&amp;&amp;(i[s]=en(t[s],e[s]));<span class="cstat-no" title="statement not covered" >r</span></span>eturn <span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >for(const e in i)<span class="cstat-no" title="statement not covered" >n[e]=i[e](t);<span class="cstat-no" title="statement not covered" >r</span></span>eturn n}</span>}</span>,</span>on=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{const n=<span class="cstat-no" title="statement not covered" >Qe.createTransformer(e),</span>i=<span class="cstat-no" title="statement not covered" >qe(t),</span>s=<span class="cstat-no" title="statement not covered" >qe(e);<span class="cstat-no" title="statement not covered" ></span>return i.numVars===s.numVars&amp;&amp;i.numColors===s.numColors&amp;&amp;i.numNumbers&gt;=s.numNumbers?$t(nn(i.values,s.values),n):((0,le.K)(!0,`Complex values '${t}' and '${e}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`),tn(t,e))}</span>,</span>rn=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,n)=&gt;{const i=<span class="cstat-no" title="statement not covered" >e-t;<span class="cstat-no" title="statement not covered" ></span>return 0===i?1:(n-t)/i}</span>,</span>an=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >n=</span>&gt;<span class="cstat-no" title="statement not covered" >Ue(t,e,n);</span></span></span>function <span class="fstat-no" title="function not covered" >ln(</span>t,e,n){const i=<span class="cstat-no" title="statement not covered" >[],</span>s=<span class="cstat-no" title="statement not covered" >n||("number"===typeof(o=t[0])?an:"string"===typeof o?Ie.test(o)?He:on:Array.isArray(o)?nn:"object"===typeof o?sn:an);</span>var o;const r=<span class="cstat-no" title="statement not covered" >t.length-1;<span class="cstat-no" title="statement not covered" ></span>for(let a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;r;a++){let n=<span class="cstat-no" title="statement not covered" >s(t[a],t[a+1]);<span class="cstat-no" title="statement not covered" ></span>if(e){const t=<span class="cstat-no" title="statement not covered" >Array.isArray(e)?e[a]||_t.Z:e;<span class="cstat-no" title="statement not covered" ></span>n=$t(t,n)}<span class="cstat-no" title="statement not covered" ></span>i</span>.push(n)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>function <span class="fstat-no" title="function not covered" >un(</span>t,e,{clamp:n=<span class="branch-0 cbranch-no" title="branch not covered" >!0,</span>ease:i,mixer:s}=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const o=<span class="cstat-no" title="statement not covered" >t.length;<span class="cstat-no" title="statement not covered" ></span>if((0,le.k)(o===e.length,"Both input and output ranges must be the same length"),1===o)<span class="cstat-no" title="statement not covered" >return<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e[0];<span class="cstat-no" title="statement not covered" ></span>t</span></span>[0]&gt;t[o-1]&amp;&amp;(t=[...t].reverse(),e=[...e].reverse());c</span>onst r=<span class="cstat-no" title="statement not covered" >ln(e,i,s),</span>a=<span class="cstat-no" title="statement not covered" >r.length,</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{let n=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>if(a&gt;1)<span class="cstat-no" title="statement not covered" >for(;n&lt;t.length-2&amp;&amp;!(e&lt;t[n+1]);n++);c</span></span>onst i=<span class="cstat-no" title="statement not covered" >rn(t[n],t[n+1],e);<span class="cstat-no" title="statement not covered" ></span>return r[n](i)}</span>;<span class="cstat-no" title="statement not covered" ></span>return n?<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >l($(t[0],t[o-1],e)):</span>l}</span>function <span class="fstat-no" title="function not covered" >cn(</span>t){const e=<span class="cstat-no" title="statement not covered" >[0];<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const n=<span class="cstat-no" title="statement not covered" >t[t.length-1];<span class="cstat-no" title="statement not covered" ></span>for(let i=<span class="cstat-no" title="statement not covered" >1;</span>i&lt;=e;i++){const s=<span class="cstat-no" title="statement not covered" >rn(0,e,i);<span class="cstat-no" title="statement not covered" ></span>t.push(Ue(n,1,s))}</span>}</span>(e,t.length-1),e}</span>function <span class="fstat-no" title="function not covered" >hn(</span>{duration:t=<span class="branch-0 cbranch-no" title="branch not covered" >300,</span>keyframes:e,times:n,ease:i=<span class="branch-0 cbranch-no" title="branch not covered" >"easeInOut"}</span>){const s=<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Array.isArray(t)&amp;&amp;"number"!==typeof t[0])</span>(i)?i.map(ke):ke(i),</span>o=<span class="cstat-no" title="statement not covered" >{done:!1,value:e[0]},</span>r=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return t.map((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t*e)</span>)}</span>(n&amp;&amp;n.length===e.length?n:cn(e),t),</span>a=<span class="cstat-no" title="statement not covered" >un(r,e,{ease:Array.isArray(s)?s:(l=e,u=s,l.map((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >u||be)</span>).splice(0,l.length-1))});</span>var l,u;<span class="cstat-no" title="statement not covered" >return{calculatedDuration:t,next:<span class="fstat-no" title="function not covered" >e=</span>&gt;(<span class="cstat-no" title="statement not covered" >o.value=a(e),o.done=e&gt;=t,o)</span>}}</span>function <span class="fstat-no" title="function not covered" >dn(</span>t,e){<span class="cstat-no" title="statement not covered" >return e?t*(1e3/e):0}</span>function <span class="fstat-no" title="function not covered" >pn(</span>t,e,n){const i=<span class="cstat-no" title="statement not covered" >Math.max(e-5,0);<span class="cstat-no" title="statement not covered" ></span>return dn(n-t(i),e-i)}</span>const mn=<span class="cstat-no" title="statement not covered" >.001;</span>function <span class="fstat-no" title="function not covered" >fn(</span>{duration:t=<span class="branch-0 cbranch-no" title="branch not covered" >800,</span>bounce:e=<span class="branch-0 cbranch-no" title="branch not covered" >.25,</span>velocity:n=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>mass:i=<span class="branch-0 cbranch-no" title="branch not covered" >1}</span>){let s,o;<span class="cstat-no" title="statement not covered" >(0,le.K)(t&lt;=ue(10),"Spring duration must be 10 seconds or less");l</span>et r=<span class="cstat-no" title="statement not covered" >1-e;<span class="cstat-no" title="statement not covered" ></span>r=$(.05,1,r),t=$(.01,10,ce(t)),r&lt;1?(s=<span class="fstat-no" title="function not covered" >e=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >e*r,</span>s=<span class="cstat-no" title="statement not covered" >i*t,</span>o=<span class="cstat-no" title="statement not covered" >i-n,</span>a=<span class="cstat-no" title="statement not covered" >gn(e,r),</span>l=<span class="cstat-no" title="statement not covered" >Math.exp(-s);<span class="cstat-no" title="statement not covered" ></span>return mn-o/a*l}</span>,o=<span class="fstat-no" title="function not covered" >e=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >e*r*t,</span>o=<span class="cstat-no" title="statement not covered" >i*n+n,</span>a=<span class="cstat-no" title="statement not covered" >Math.pow(r,2)*Math.pow(e,2)*t,</span>l=<span class="cstat-no" title="statement not covered" >Math.exp(-i),</span>u=<span class="cstat-no" title="statement not covered" >gn(Math.pow(e,2),r);<span class="cstat-no" title="statement not covered" ></span>return(-s(e)+mn&gt;0?-1:1)*((o-a)*l)/u}</span>):(s=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >Math.exp(-e*t)*((e-n)*t+1)-.001,</span>o=<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >Math.exp(-e*t)*(t*t*(n-e)))</span>;c</span>onst a=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){let i=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >1;</span>s&lt;12;s++)<span class="cstat-no" title="statement not covered" >i-=t(i)/e(i);<span class="cstat-no" title="statement not covered" >r</span></span>eturn i}</span>(s,o,5/t);<span class="cstat-no" title="statement not covered" ></span>if(t=ue(t),isNaN(a))<span class="cstat-no" title="statement not covered" >return{stiffness:100,damping:10,duration:t};{</span></span>const e=<span class="cstat-no" title="statement not covered" >Math.pow(a,2)*i;<span class="cstat-no" title="statement not covered" ></span>return{stiffness:e,damping:2*r*Math.sqrt(i*e),duration:t}}</span>}function <span class="fstat-no" title="function not covered" >gn(</span>t,e){<span class="cstat-no" title="statement not covered" >return t*Math.sqrt(1-e*e)}</span>const yn=<span class="cstat-no" title="statement not covered" >["duration","bounce"],</span>vn=<span class="cstat-no" title="statement not covered" >["stiffness","damping","mass"];</span>function <span class="fstat-no" title="function not covered" >xn(</span>t,e){<span class="cstat-no" title="statement not covered" >return e.some((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >void 0!==t[e])</span>)}</span>function <span class="fstat-no" title="function not covered" >Pn(</span>{keyframes:t,restDelta:e,restSpeed:n,...i}){const s=<span class="cstat-no" title="statement not covered" >t[0],</span>o=<span class="cstat-no" title="statement not covered" >t[t.length-1],</span>r=<span class="cstat-no" title="statement not covered" >{done:!1,value:s},</span>{stiffness:a,damping:l,mass:u,duration:c,velocity:h,isResolvedFromDuration:d}=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){let e=<span class="cstat-no" title="statement not covered" >{velocity:0,stiffness:100,damping:10,mass:1,isResolvedFromDuration:!1,...t};<span class="cstat-no" title="statement not covered" ></span>if(!xn(t,vn)&amp;&amp;xn(t,yn)){const n=<span class="cstat-no" title="statement not covered" >fn(t);<span class="cstat-no" title="statement not covered" ></span>e={...e,...n,mass:1},e.isResolvedFromDuration=!0}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>({...i,velocity:-ce(i.velocity||0)}),</span>p=<span class="cstat-no" title="statement not covered" >h||0,</span>m=<span class="cstat-no" title="statement not covered" >l/(2*Math.sqrt(a*u)),</span>f=<span class="cstat-no" title="statement not covered" >o-s,</span>g=<span class="cstat-no" title="statement not covered" >ce(Math.sqrt(a/u)),</span>y=<span class="cstat-no" title="statement not covered" >Math.abs(f)&lt;5;</span>let v;<span class="cstat-no" title="statement not covered" >if(n||(n=y?.01:2),e||(e=y?.005:.5),m&lt;1){const t=<span class="cstat-no" title="statement not covered" >gn(g,m);<span class="cstat-no" title="statement not covered" ></span>v=<span class="fstat-no" title="function not covered" >e=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >Math.exp(-m*g*e);<span class="cstat-no" title="statement not covered" ></span>return o-n*((p+m*g*f)/t*Math.sin(t*e)+f*Math.cos(t*e))}</span>}</span>else <span class="cstat-no" title="statement not covered" >if(1===m)<span class="cstat-no" title="statement not covered" >v=<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >o-Math.exp(-g*t)*(f+(p+g*f)*t);</span>e</span>lse{const t=<span class="cstat-no" title="statement not covered" >g*Math.sqrt(m*m-1);<span class="cstat-no" title="statement not covered" ></span>v=<span class="fstat-no" title="function not covered" >e=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >Math.exp(-m*g*e),</span>i=<span class="cstat-no" title="statement not covered" >Math.min(t*e,300);<span class="cstat-no" title="statement not covered" ></span>return o-n*((p+m*g*f)*Math.sinh(i)+t*f*Math.cosh(i))/t}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn{calculatedDuration:d&amp;&amp;c||null,next:<span class="fstat-no" title="function not covered" >t=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >v(t);<span class="cstat-no" title="statement not covered" ></span>if(d)<span class="cstat-no" title="statement not covered" >r.done=t&gt;=c;e</span>lse{let s=<span class="cstat-no" title="statement not covered" >p;<span class="cstat-no" title="statement not covered" ></span>0!==t&amp;&amp;(s=m&lt;1?pn(v,t,i):0);c</span>onst a=<span class="cstat-no" title="statement not covered" >Math.abs(s)&lt;=n,</span>l=<span class="cstat-no" title="statement not covered" >Math.abs(o-i)&lt;=e;<span class="cstat-no" title="statement not covered" ></span>r.done=a&amp;&amp;l}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r.value=r.done?o:i,r}</span>}}</span>function <span class="fstat-no" title="function not covered" >bn(</span>{keyframes:t,velocity:e=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>power:n=<span class="branch-0 cbranch-no" title="branch not covered" >.8,</span>timeConstant:i=<span class="branch-0 cbranch-no" title="branch not covered" >325,</span>bounceDamping:s=<span class="branch-0 cbranch-no" title="branch not covered" >10,</span>bounceStiffness:o=<span class="branch-0 cbranch-no" title="branch not covered" >500,</span>modifyTarget:r,min:a,max:l,restDelta:u=<span class="branch-0 cbranch-no" title="branch not covered" >.5,</span>restSpeed:c}){const h=<span class="cstat-no" title="statement not covered" >t[0],</span>d=<span class="cstat-no" title="statement not covered" >{done:!1,value:h},</span>p=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >void 0===a?l:void 0===l||Math.abs(a-t)&lt;Math.abs(l-t)?a:l;</span></span>let m=<span class="cstat-no" title="statement not covered" >n*e;</span>const f=<span class="cstat-no" title="statement not covered" >h+m,</span>g=<span class="cstat-no" title="statement not covered" >void 0===r?f:r(f);<span class="cstat-no" title="statement not covered" ></span>g!==f&amp;&amp;(m=g-h);c</span>onst y=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >-m*Math.exp(-t/i),</span></span>v=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >g+y(t),</span></span>x=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >y(t),</span>n=<span class="cstat-no" title="statement not covered" >v(t);<span class="cstat-no" title="statement not covered" ></span>d.done=Math.abs(e)&lt;=u,d.value=d.done?g:n}</span>;</span>let P,b;const T=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{var e;<span class="cstat-no" title="statement not covered" >(e=d.value,void 0!==a&amp;&amp;e&lt;a||void 0!==l&amp;&amp;e&gt;l)&amp;&amp;(P=t,b=Pn({keyframes:[d.value,p(d.value)],velocity:pn(v,t,d.value),damping:s,stiffness:o,restDelta:u,restSpeed:c}))}</span>;<span class="cstat-no" title="statement not covered" ></span>return T(0),{calculatedDuration:null,next:<span class="fstat-no" title="function not covered" >t=</span>&gt;{let e=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return b||void 0!==P||(e=!0,x(t),T(t)),void 0!==P&amp;&amp;t&gt;P?b.next(t-P):(!e&amp;&amp;x(t),d)}</span>}}</span>const Tn=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>timestamp:e})=&gt;<span class="cstat-no" title="statement not covered" >t(e);<span class="cstat-no" title="statement not covered" ></span></span>return{start:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >jt.Wi.update(e,!0),</span>stop:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >(0,jt.Pn)(e),</span>now:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >jt.frameData.isProcessing?jt.frameData.timestamp:performance.now()}</span>}</span>;</span>function <span class="fstat-no" title="function not covered" >Sn(</span>t){let e=<span class="cstat-no" title="statement not covered" >0;</span>let n=<span class="cstat-no" title="statement not covered" >t.next(e);<span class="cstat-no" title="statement not covered" ></span>for(;!n.done&amp;&amp;e&lt;2e4;)<span class="cstat-no" title="statement not covered" >e+=50,n=t.next(e);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e&gt;=2e4?1/0:e}</span>const wn=<span class="cstat-no" title="statement not covered" >{decay:bn,inertia:bn,tween:hn,keyframes:hn,spring:Pn};</span>function <span class="fstat-no" title="function not covered" >An(</span>{autoplay:t=<span class="branch-0 cbranch-no" title="branch not covered" >!0,</span>delay:e=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>driver:n=<span class="branch-0 cbranch-no" title="branch not covered" >Tn,</span>keyframes:i,type:s=<span class="branch-0 cbranch-no" title="branch not covered" >"keyframes",</span>repeat:o=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>repeatDelay:r=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>repeatType:a=<span class="branch-0 cbranch-no" title="branch not covered" >"loop",</span>onPlay:l,onStop:u,onComplete:c,onUpdate:h,...d}){let p,m,f=<span class="cstat-no" title="statement not covered" >1,</span>g=<span class="cstat-no" title="statement not covered" >!1;</span>const y=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >m=new Promise((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >p=t}</span>))}</span>;</span>let v;<span class="cstat-no" title="statement not covered" >y();c</span>onst x=<span class="cstat-no" title="statement not covered" >wn[s]||hn;</span>let P;<span class="cstat-no" title="statement not covered" >x!==hn&amp;&amp;"number"!==typeof i[0]&amp;&amp;(P=un([0,100],i,{clamp:!1}),i=[0,100]);c</span>onst b=<span class="cstat-no" title="statement not covered" >x({...d,keyframes:i});</span>let T;<span class="cstat-no" title="statement not covered" >"mirror"===a&amp;&amp;(T=x({...d,keyframes:[...i].reverse(),velocity:-(d.velocity||0)}));l</span>et S=<span class="cstat-no" title="statement not covered" >"idle",</span>w=<span class="cstat-no" title="statement not covered" >null,</span>A=<span class="cstat-no" title="statement not covered" >null,</span>V=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>null===b.calculatedDuration&amp;&amp;o&amp;&amp;(b.calculatedDuration=Sn(b));c</span>onst{calculatedDuration:E}=<span class="cstat-no" title="statement not covered" >b;</span>let C=<span class="cstat-no" title="statement not covered" >1/0,</span>D=<span class="cstat-no" title="statement not covered" >1/0;<span class="cstat-no" title="statement not covered" ></span>null!==E&amp;&amp;(C=E+r,D=C*(o+1)-r);l</span>et M=<span class="cstat-no" title="statement not covered" >0;</span>const k=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(null===A)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >f</span></span>&gt;0&amp;&amp;(A=Math.min(A,t)),f&lt;0&amp;&amp;(A=Math.min(t-D/f,A)),M=null!==w?w:Math.round(t-A)*f;c</span>onst n=<span class="cstat-no" title="statement not covered" >M-e*(f&gt;=0?1:-1),</span>s=<span class="cstat-no" title="statement not covered" >f&gt;=0?n&lt;0:n&gt;D;<span class="cstat-no" title="statement not covered" ></span>M=Math.max(n,0),"finished"===S&amp;&amp;null===w&amp;&amp;(M=D);l</span>et l=<span class="cstat-no" title="statement not covered" >M,</span>u=<span class="cstat-no" title="statement not covered" >b;<span class="cstat-no" title="statement not covered" ></span>if(o){const t=<span class="cstat-no" title="statement not covered" >Math.min(M,D)/C;</span>let e=<span class="cstat-no" title="statement not covered" >Math.floor(t),</span>n=<span class="cstat-no" title="statement not covered" >t%1;<span class="cstat-no" title="statement not covered" ></span>!n&amp;&amp;t&gt;=1&amp;&amp;(n=1),1===n&amp;&amp;e--,e=Math.min(e,o+1);<span class="cstat-no" title="statement not covered" >B</span>oolean(e%2)&amp;&amp;("reverse"===a?(n=1-n,r&amp;&amp;(n-=r/C)):"mirror"===a&amp;&amp;(u=T)),l=$(0,1,n)*C}</span>c</span>onst c=<span class="cstat-no" title="statement not covered" >s?{done:!1,value:i[0]}:u.next(l);<span class="cstat-no" title="statement not covered" ></span>P&amp;&amp;(c.value=P(c.value));l</span>et{done:d}=<span class="cstat-no" title="statement not covered" >c;<span class="cstat-no" title="statement not covered" ></span>s||null===E||(d=f&gt;=0?M&gt;=D:M&lt;=0);c</span>onst p=<span class="cstat-no" title="statement not covered" >null===w&amp;&amp;("finished"===S||"running"===S&amp;&amp;d);<span class="cstat-no" title="statement not covered" ></span>return h&amp;&amp;h(c.value),p&amp;&amp;j(),c}</span>,</span>R=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >v&amp;&amp;v.stop(),v=void 0}</span>,</span>L=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >S="idle",R(),p(),y(),A=V=null}</span>,</span>j=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >S="finished",c&amp;&amp;c(),R(),p()}</span>,</span>B=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(g)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >v</span></span>||(v=n(k));c</span>onst t=<span class="cstat-no" title="statement not covered" >v.now();<span class="cstat-no" title="statement not covered" ></span>l&amp;&amp;l(),null!==w?A=t-w:A&amp;&amp;"finished"!==S||(A=t),"finished"===S&amp;&amp;y(),V=A,w=null,S="running",v.start()}</span>;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;B();c</span>onst F=<span class="cstat-no" title="statement not covered" >{then:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >m.then(t,e),<span class="fstat-no" title="function not covered" ></span>ge</span>t time(){<span class="cstat-no" title="statement not covered" >return ce(M)}</span>,<span class="fstat-no" title="function not covered" >se</span>t time(t){<span class="cstat-no" title="statement not covered" >t=ue(t),M=t,null===w&amp;&amp;v&amp;&amp;0!==f?A=v.now()-t/f:w=t}</span>,<span class="fstat-no" title="function not covered" >ge</span>t duration(){const t=<span class="cstat-no" title="statement not covered" >null===b.calculatedDuration?Sn(b):b.calculatedDuration;<span class="cstat-no" title="statement not covered" ></span>return ce(t)}</span>,<span class="fstat-no" title="function not covered" >ge</span>t speed(){<span class="cstat-no" title="statement not covered" >return f}</span>,<span class="fstat-no" title="function not covered" >se</span>t speed(t){<span class="cstat-no" title="statement not covered" >t!==f&amp;&amp;v&amp;&amp;(f=t,F.time=ce(M))}</span>,<span class="fstat-no" title="function not covered" >ge</span>t state(){<span class="cstat-no" title="statement not covered" >return S}</span>,play:B,pause:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >S="paused",w=M}</span>,stop:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >g=!0,"idle"!==S&amp;&amp;(S="idle",u&amp;&amp;u(),L())}</span>,cancel:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >null!==V&amp;&amp;k(V),L()}</span>,complete:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >S="finished"}</span>,sample:<span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >A=0,k(t))</span>};<span class="cstat-no" title="statement not covered" ></span>return F}</span>const Vn=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){let e;<span class="cstat-no" title="statement not covered" >return<span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >void 0===e&amp;&amp;(e=t()),e)</span>}</span>((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Object.hasOwnProperty.call(Element.prototype,"animate"))</span>),</span>En=<span class="cstat-no" title="statement not covered" >new Set(["opacity","clipPath","filter","transform","backgroundColor"]);</span>function <span class="fstat-no" title="function not covered" >Cn(</span>t,e,{onUpdate:n,onComplete:i,...s}){<span class="cstat-no" title="statement not covered" >if(!(Vn()&amp;&amp;En.has(e)&amp;&amp;!s.repeatDelay&amp;&amp;"mirror"!==s.repeatType&amp;&amp;0!==s.damping&amp;&amp;"inertia"!==s.type))<span class="cstat-no" title="statement not covered" >return!1;l</span></span>et o,r,a=<span class="cstat-no" title="statement not covered" >!1,</span>l=<span class="cstat-no" title="statement not covered" >!1;</span>const u=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >r=new Promise((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >o=t}</span>))}</span>;<span class="cstat-no" title="statement not covered" ></span>u();l</span>et{keyframes:c,duration:h=<span class="branch-0 cbranch-no" title="branch not covered" >300,</span>ease:d,times:p}=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>if((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >"spring"===e.type||"backgroundColor"===t||!pe(e.ease))</span>(e,s)){const t=<span class="cstat-no" title="statement not covered" >An({...s,repeat:0,delay:0});</span>let e=<span class="cstat-no" title="statement not covered" >{done:!1,value:c[0]};</span>const n=<span class="cstat-no" title="statement not covered" >[];</span>let i=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(;!e.done&amp;&amp;i&lt;2e4;)<span class="cstat-no" title="statement not covered" >e=t.sample(i),n.push(e.value),i+=10;<span class="cstat-no" title="statement not covered" >p</span></span>=void 0,c=n,h=i-10,d="linear"}</span>c</span>onst m=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,{delay:i=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>duration:s,repeat:o=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>repeatType:r=<span class="branch-0 cbranch-no" title="branch not covered" >"loop",</span>ease:a,times:l}=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const u=<span class="cstat-no" title="statement not covered" >{[e]:n};<span class="cstat-no" title="statement not covered" ></span>l&amp;&amp;(u.offset=l);c</span>onst c=<span class="cstat-no" title="statement not covered" >ge(a);<span class="cstat-no" title="statement not covered" ></span>return Array.isArray(c)&amp;&amp;(u.easing=c),t.animate(u,{delay:i,duration:s,easing:Array.isArray(c)?"linear":c,fill:"both",iterations:o+1,direction:"reverse"===r?"alternate":"normal"})}</span>(t.owner.current,e,c,{...s,duration:h,ease:d,times:p}),</span>f=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >l=!1,m.cancel()}</span>,</span>g=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >l=!0,jt.Wi.update(f),o(),u()}</span>;<span class="cstat-no" title="statement not covered" ></span>m.onfinish=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >l||(t.set(<span class="fstat-no" title="function not covered" >fu</span>nction(t,{repeat:e,repeatType:n=<span class="branch-0 cbranch-no" title="branch not covered" >"loop"}</span>){<span class="cstat-no" title="statement not covered" >return t[e&amp;&amp;"loop"!==n&amp;&amp;e%2===1?0:t.length-1]}</span>(c,s)),i&amp;&amp;i(),g())}</span>;<span class="cstat-no" title="statement not covered" >r</span>eturn{then:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >r.then(t,e),</span>attachTimeline:<span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >m.timeline=t,m.onfinish=null,_t.Z)</span>,<span class="fstat-no" title="function not covered" >ge</span>t time(){<span class="cstat-no" title="statement not covered" >return ce(m.currentTime||0)}</span>,<span class="fstat-no" title="function not covered" >se</span>t time(t){<span class="cstat-no" title="statement not covered" >m.currentTime=ue(t)}</span>,<span class="fstat-no" title="function not covered" >ge</span>t speed(){<span class="cstat-no" title="statement not covered" >return m.playbackRate}</span>,<span class="fstat-no" title="function not covered" >se</span>t speed(t){<span class="cstat-no" title="statement not covered" >m.playbackRate=t}</span>,<span class="fstat-no" title="function not covered" >ge</span>t duration(){<span class="cstat-no" title="statement not covered" >return ce(h)}</span>,play:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >a||(m.play(),(0,jt.Pn)(f))}</span>,pause:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >m.pause(),</span>stop:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(a=!0,"idle"===m.playState)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{currentTime:e}=<span class="cstat-no" title="statement not covered" >m;<span class="cstat-no" title="statement not covered" ></span>if(e){const n=<span class="cstat-no" title="statement not covered" >An({...s,autoplay:!1});<span class="cstat-no" title="statement not covered" ></span>t.setWithVelocity(n.sample(e-10).value,n.sample(e).value,10)}<span class="cstat-no" title="statement not covered" ></span>g</span>()}</span>,complete:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >l||m.finish()}</span>,cancel:g}}</span>const Dn=<span class="cstat-no" title="statement not covered" >{type:"spring",stiffness:500,damping:25,restSpeed:10},</span>Mn=<span class="cstat-no" title="statement not covered" >{type:"keyframes",duration:.8},</span>kn=<span class="cstat-no" title="statement not covered" >{type:"keyframes",ease:[.25,.1,.35,1],duration:.3},</span>Rn=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,{keyframes:e})=&gt;<span class="cstat-no" title="statement not covered" >e.length&gt;2?Mn:L.has(t)?t.startsWith("scale")?{type:"spring",stiffness:550,damping:0===e[1]?2*Math.sqrt(550):30,restSpeed:10}:Dn:kn,</span></span>Ln=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >"zIndex"!==t&amp;&amp;(!("number"!==typeof e&amp;&amp;!Array.isArray(e))||!("string"!==typeof e||!Qe.test(e)&amp;&amp;"0"!==e||e.startsWith("url("))),</span></span>jn=<span class="cstat-no" title="statement not covered" >new Set(["brightness","contrast","saturate","opacity"]);</span>function <span class="fstat-no" title="function not covered" >Bn(</span>t){const[e,n]=<span class="cstat-no" title="statement not covered" >t.slice(0,-1).split("(");<span class="cstat-no" title="statement not covered" ></span>if("drop-shadow"===e)<span class="cstat-no" title="statement not covered" >return t;c</span></span>onst[i]=<span class="cstat-no" title="statement not covered" >n.match(X)||[];<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return t;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >n.replace(i,"");</span>let o=<span class="cstat-no" title="statement not covered" >jn.has(e)?1:0;<span class="cstat-no" title="statement not covered" ></span>return i!==n&amp;&amp;(o*=100),e+"("+o+s+")"}</span>const Fn=<span class="cstat-no" title="statement not covered" >/([a-z-]*)\(.*?\)/g,</span>On=<span class="cstat-no" title="statement not covered" >{...Qe,getAnimatableNone:<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >t.match(Fn);<span class="cstat-no" title="statement not covered" ></span>return e?e.map(Bn).join(" "):t}</span>},</span>In=<span class="cstat-no" title="statement not covered" >{...ot,color:Ie,backgroundColor:Ie,outlineColor:Ie,fill:Ie,stroke:Ie,borderColor:Ie,borderTopColor:Ie,borderRightColor:Ie,borderBottomColor:Ie,borderLeftColor:Ie,filter:On,WebkitFilter:On},</span>Un=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >In[t];</span></span>function <span class="fstat-no" title="function not covered" >Wn(</span>t,e){let n=<span class="cstat-no" title="statement not covered" >Un(t);<span class="cstat-no" title="statement not covered" ></span>return n!==On&amp;&amp;(n=Qe),n.getAnimatableNone?n.getAnimatableNone(e):void 0}</span>const Nn=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >/^0[^.\s]+$/.test(t);</span></span>function <span class="fstat-no" title="function not covered" >$n(</span>t){<span class="cstat-no" title="statement not covered" >return"number"===typeof t?0===t:null!==t?"none"===t||"0"===t||Nn(t):void 0}</span>function <span class="fstat-no" title="function not covered" >Zn(</span>t,e){<span class="cstat-no" title="statement not covered" >return t[e]||t.default||t}</span>const Hn=<span class="cstat-no" title="statement not covered" >!1,</span>zn=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,n,i=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >s=</span>&gt;{const o=<span class="cstat-no" title="statement not covered" >Zn(i,t)||{},</span>r=<span class="cstat-no" title="statement not covered" >o.delay||i.delay||0;</span>let{elapsed:a=<span class="branch-0 cbranch-no" title="branch not covered" >0}</span>=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>a-=ue(r);c</span>onst l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,i){const s=<span class="cstat-no" title="statement not covered" >Ln(e,n);</span>let o;<span class="cstat-no" title="statement not covered" >o=Array.isArray(n)?[...n]:[null,n];c</span>onst r=<span class="cstat-no" title="statement not covered" >void 0!==i.from?i.from:t.get();</span>let a;const l=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>for(let u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;o.length;u++)<span class="cstat-no" title="statement not covered" >null===o[u]&amp;&amp;(o[u]=0===u?r:o[u-1]),$n(o[u])&amp;&amp;l.push(u),"string"===typeof o[u]&amp;&amp;"none"!==o[u]&amp;&amp;"0"!==o[u]&amp;&amp;(a=o[u]);<span class="cstat-no" title="statement not covered" >i</span></span>f(s&amp;&amp;l.length&amp;&amp;a)<span class="cstat-no" title="statement not covered" >for(let u=<span class="cstat-no" title="statement not covered" >0;</span>u&lt;l.length;u++)<span class="cstat-no" title="statement not covered" >o[l[u]]=Wn(e,a);<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn o}</span>(e,t,n,o),</span>u=<span class="cstat-no" title="statement not covered" >l[0],</span>c=<span class="cstat-no" title="statement not covered" >l[l.length-1],</span>h=<span class="cstat-no" title="statement not covered" >Ln(t,u),</span>d=<span class="cstat-no" title="statement not covered" >Ln(t,c);<span class="cstat-no" title="statement not covered" ></span>(0,le.K)(h===d,`You are trying to animate ${t} from "${u}" to "${c}". ${u} is not an animatable value - to enable this animation set ${u} to a value animatable to ${c} via the \`style\` property.`);l</span>et p=<span class="cstat-no" title="statement not covered" >{keyframes:l,velocity:e.getVelocity(),ease:"easeOut",...o,delay:-a,onUpdate:<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >e.set(t),o.onUpdate&amp;&amp;o.onUpdate(t)}</span>,onComplete:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >s(),o.onComplete&amp;&amp;o.onComplete()}</span>};<span class="cstat-no" title="statement not covered" ></span>if(<span class="fstat-no" title="function not covered" >fu</span>nction({when:t,delay:e,delayChildren:n,staggerChildren:i,staggerDirection:s,repeat:o,repeatType:r,repeatDelay:a,from:l,elapsed:u,...c}){<span class="cstat-no" title="statement not covered" >return!!Object.keys(c).length}</span>(o)||(p={...p,...Rn(t,p)}),p.duration&amp;&amp;(p.duration=ue(p.duration)),p.repeatDelay&amp;&amp;(p.repeatDelay=ue(p.repeatDelay)),!h||!d||he||!1===o.type||Hn)<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction({keyframes:t,delay:e,onUpdate:n,onComplete:i}){const s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >n&amp;&amp;n(t[t.length-1]),i&amp;&amp;i(),{time:0,speed:1,duration:0,play:_t.Z,pause:_t.Z,stop:_t.Z,then:<span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >t(),Promise.resolve())</span>,cancel:_t.Z,complete:_t.Z})</span>;<span class="cstat-no" title="statement not covered" ></span>return e?An({keyframes:[0,1],duration:0,delay:e,onComplete:s}):s()}</span>(he?{...p,delay:0}:p);<span class="cstat-no" title="statement not covered" >i</span></span>f(!i.isHandoff&amp;&amp;e.owner&amp;&amp;e.owner.current instanceof HTMLElement&amp;&amp;!e.owner.getProps().onUpdate){const n=<span class="cstat-no" title="statement not covered" >Cn(e,t,p);<span class="cstat-no" title="statement not covered" ></span>if(n)<span class="cstat-no" title="statement not covered" >return n}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn An(p)}</span>;</span></span>function <span class="fstat-no" title="function not covered" >Yn(</span>t){<span class="cstat-no" title="statement not covered" >return Boolean(B(t)&amp;&amp;t.add)}</span>const Xn=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >/^\-?\d*\.?\d+$/.test(t);</span></span>function <span class="fstat-no" title="function not covered" >Gn(</span>t,e){<span class="cstat-no" title="statement not covered" >-1===t.indexOf(e)&amp;&amp;t.push(e)}</span>function <span class="fstat-no" title="function not covered" >qn(</span>t,e){const n=<span class="cstat-no" title="statement not covered" >t.indexOf(e);<span class="cstat-no" title="statement not covered" ></span>n&gt;-1&amp;&amp;t.splice(n,1)}</span>class Kn{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.subscriptions=[]}<span class="fstat-no" title="function not covered" ></span>ad</span>d(t){<span class="cstat-no" title="statement not covered" >return Gn(this.subscriptions,t),<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >qn(this.subscriptions,t)}<span class="fstat-no" title="function not covered" ></span></span>no</span>tify(t,e,n){const i=<span class="cstat-no" title="statement not covered" >this.subscriptions.length;<span class="cstat-no" title="statement not covered" ></span>if(i)<span class="cstat-no" title="statement not covered" >if(1===i)<span class="cstat-no" title="statement not covered" >this.subscriptions[0](t,e,n);e</span>lse <span class="cstat-no" title="statement not covered" >for(let s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;i;s++){const i=<span class="cstat-no" title="statement not covered" >this.subscriptions[s];<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;i(t,e,n)}</span>}<span class="fstat-no" title="function not covered" ></span></span></span>ge</span>tSize(){<span class="cstat-no" title="statement not covered" >return this.subscriptions.length}<span class="fstat-no" title="function not covered" ></span>cl</span>ear(){<span class="cstat-no" title="statement not covered" >this.subscriptions.length=0}</span>}const _n=<span class="cstat-no" title="statement not covered" >{current:void 0};</span>class Jn{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{var n;<span class="cstat-no" title="statement not covered" >this.version="10.18.0",this.timeDelta=0,this.lastUpdated=0,this.canTrackVelocity=!1,this.events={},this.updateAndNotify=<span class="fstat-no" title="function not covered" >(t</span>,e=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.prev=this.current,this.current=t;c</span>onst{delta:n,timestamp:i}=<span class="cstat-no" title="statement not covered" >jt.frameData;<span class="cstat-no" title="statement not covered" ></span>this.lastUpdated!==i&amp;&amp;(this.timeDelta=n,this.lastUpdated=i,jt.Wi.postRender(this.scheduleVelocityCheck)),this.prev!==this.current&amp;&amp;this.events.change&amp;&amp;this.events.change.notify(this.current),this.events.velocityChange&amp;&amp;this.events.velocityChange.notify(this.getVelocity()),e&amp;&amp;this.events.renderRequest&amp;&amp;this.events.renderRequest.notify(this.current)}</span>,this.scheduleVelocityCheck=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >jt.Wi.postRender(this.velocityCheck),</span>this.velocityCheck=<span class="fstat-no" title="function not covered" >({</span>timestamp:t})=&gt;{<span class="cstat-no" title="statement not covered" >t!==this.lastUpdated&amp;&amp;(this.prev=this.current,this.events.velocityChange&amp;&amp;this.events.velocityChange.notify(this.getVelocity()))}</span>,this.hasAnimated=!1,this.prev=this.current=t,this.canTrackVelocity=(n=this.current,!isNaN(parseFloat(n))),this.owner=e.owner}<span class="fstat-no" title="function not covered" ></span>on</span>Change(t){<span class="cstat-no" title="statement not covered" >return this.on("change",t)}<span class="fstat-no" title="function not covered" ></span>on</span>(t,e){<span class="cstat-no" title="statement not covered" >this.events[t]||(this.events[t]=new Kn);c</span>onst n=<span class="cstat-no" title="statement not covered" >this.events[t].add(e);<span class="cstat-no" title="statement not covered" ></span>return"change"===t?<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >n(),jt.Wi.read((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.events.change.getSize()||this.stop()}</span>))}</span>:n}<span class="fstat-no" title="function not covered" ></span>cl</span>earListeners(){<span class="cstat-no" title="statement not covered" >for(const t in this.events)<span class="cstat-no" title="statement not covered" >this.events[t].clear()}<span class="fstat-no" title="function not covered" ></span></span>at</span>tach(t,e){<span class="cstat-no" title="statement not covered" >this.passiveEffect=t,this.stopPassiveEffect=e}<span class="fstat-no" title="function not covered" ></span>se</span>t(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>{<span class="cstat-no" title="statement not covered" >e&amp;&amp;this.passiveEffect?this.passiveEffect(t,this.updateAndNotify):this.updateAndNotify(t,e)}<span class="fstat-no" title="function not covered" ></span>se</span>tWithVelocity(t,e,n){<span class="cstat-no" title="statement not covered" >this.set(e),this.prev=t,this.timeDelta=n}<span class="fstat-no" title="function not covered" ></span>ju</span>mp(t){<span class="cstat-no" title="statement not covered" >this.updateAndNotify(t),this.prev=t,this.stop(),this.stopPassiveEffect&amp;&amp;this.stopPassiveEffect()}<span class="fstat-no" title="function not covered" ></span>ge</span>t(){<span class="cstat-no" title="statement not covered" >return _n.current&amp;&amp;_n.current.push(this),this.current}<span class="fstat-no" title="function not covered" ></span>ge</span>tPrevious(){<span class="cstat-no" title="statement not covered" >return this.prev}<span class="fstat-no" title="function not covered" ></span>ge</span>tVelocity(){<span class="cstat-no" title="statement not covered" >return this.canTrackVelocity?dn(parseFloat(this.current)-parseFloat(this.prev),this.timeDelta):0}<span class="fstat-no" title="function not covered" ></span>st</span>art(t){<span class="cstat-no" title="statement not covered" >return this.stop(),new Promise((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.hasAnimated=!0,this.animation=t(e),this.events.animationStart&amp;&amp;this.events.animationStart.notify()}</span>)).then((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.events.animationComplete&amp;&amp;this.events.animationComplete.notify(),this.clearAnimation()}</span>))}<span class="fstat-no" title="function not covered" ></span>st</span>op(){<span class="cstat-no" title="statement not covered" >this.animation&amp;&amp;(this.animation.stop(),this.events.animationCancel&amp;&amp;this.events.animationCancel.notify()),this.clearAnimation()}<span class="fstat-no" title="function not covered" ></span>is</span>Animating(){<span class="cstat-no" title="statement not covered" >return!!this.animation}<span class="fstat-no" title="function not covered" ></span>cl</span>earAnimation(){<span class="cstat-no" title="statement not covered" >delete this.animation}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(){<span class="cstat-no" title="statement not covered" >this.clearListeners(),this.stop(),this.stopPassiveEffect&amp;&amp;this.stopPassiveEffect()}</span>}function <span class="fstat-no" title="function not covered" >Qn(</span>t,e){<span class="cstat-no" title="statement not covered" >return new Jn(t,e)}</span>const ti=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.test(t),</span></span></span>ei=<span class="cstat-no" title="statement not covered" >[Z,tt,Q,J,nt,et,{test:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"auto"===t,</span>parse:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t}</span>],</span>ni=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >ei.find(ti(t)),</span></span>ii=<span class="cstat-no" title="statement not covered" >[...ei,Ie,Qe];</span>function <span class="fstat-no" title="function not covered" >si(</span>t,e,n){<span class="cstat-no" title="statement not covered" >t.hasValue(e)?t.getValue(e).set(n):t.addValue(e,Qn(n))}</span>function <span class="fstat-no" title="function not covered" >oi(</span>t,e){const n=<span class="cstat-no" title="statement not covered" >ae(t,e);</span>let{transitionEnd:i=<span class="branch-0 cbranch-no" title="branch not covered" >{},</span>transition:s=<span class="branch-0 cbranch-no" title="branch not covered" >{},</span>...o}=<span class="cstat-no" title="statement not covered" >n?t.makeTargetAnimatable(n,!1):{};<span class="cstat-no" title="statement not covered" ></span>o={...o,...i};<span class="cstat-no" title="statement not covered" >f</span>or(const a in o){<span class="cstat-no" title="statement not covered" >si(t,a,(r=o[a],Mt(r)?r[r.length-1]||0:r))}</span>v</span>ar r}function <span class="fstat-no" title="function not covered" >ri(</span>t,e){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >r</span></span>eturn(e[t]||e.default||e).from}</span>function <span class="fstat-no" title="function not covered" >ai(</span>{protectedKeys:t,needsAnimating:e},n){const i=<span class="cstat-no" title="statement not covered" >t.hasOwnProperty(n)&amp;&amp;!0!==e[n];<span class="cstat-no" title="statement not covered" ></span>return e[n]=!1,i}</span>function <span class="fstat-no" title="function not covered" >li(</span>t,e){const n=<span class="cstat-no" title="statement not covered" >t.get();<span class="cstat-no" title="statement not covered" ></span>if(!Array.isArray(e))<span class="cstat-no" title="statement not covered" >return n!==e;<span class="cstat-no" title="statement not covered" >f</span></span>or(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;e.length;i++)<span class="cstat-no" title="statement not covered" >if(e[i]!==n)<span class="cstat-no" title="statement not covered" >return!0}</span></span></span>function <span class="fstat-no" title="function not covered" >ui(</span>t,e,{delay:n=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>transitionOverride:i,type:s}=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{let{transition:o=<span class="branch-0 cbranch-no" title="branch not covered" >t.getDefaultTransition(),</span>transitionEnd:r,...a}=<span class="cstat-no" title="statement not covered" >t.makeTargetAnimatable(e);</span>const l=<span class="cstat-no" title="statement not covered" >t.getValue("willChange");<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;(o=i);c</span>onst u=<span class="cstat-no" title="statement not covered" >[],</span>h=<span class="cstat-no" title="statement not covered" >s&amp;&amp;t.animationState&amp;&amp;t.animationState.getState()[s];<span class="cstat-no" title="statement not covered" ></span>for(const d in a){const e=<span class="cstat-no" title="statement not covered" >t.getValue(d),</span>i=<span class="cstat-no" title="statement not covered" >a[d];<span class="cstat-no" title="statement not covered" ></span>if(!e||void 0===i||h&amp;&amp;ai(h,d))<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >{delay:n,elapsed:0,...Zn(o||{},d)};<span class="cstat-no" title="statement not covered" ></span>if(window.HandoffAppearAnimations){const n=<span class="cstat-no" title="statement not covered" >t.getProps()[c];<span class="cstat-no" title="statement not covered" ></span>if(n){const t=<span class="cstat-no" title="statement not covered" >window.HandoffAppearAnimations(n,d,e,jt.Wi);<span class="cstat-no" title="statement not covered" ></span>null!==t&amp;&amp;(s.elapsed=t,s.isHandoff=!0)}</span>}</span>l</span>et r=<span class="cstat-no" title="statement not covered" >!s.isHandoff&amp;&amp;!li(e,i);<span class="cstat-no" title="statement not covered" ></span>if("spring"===s.type&amp;&amp;(e.getVelocity()||s.velocity)&amp;&amp;(r=!1),e.animation&amp;&amp;(r=!1),r)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >e</span></span>.start(zn(d,e,i,t.shouldReduceMotion&amp;&amp;L.has(d)?{type:!1}:s));c</span>onst p=<span class="cstat-no" title="statement not covered" >e.animation;<span class="cstat-no" title="statement not covered" ></span>Yn(l)&amp;&amp;(l.add(d),p.then((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >l.remove(d))</span>)),u.push(p)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r&amp;&amp;Promise.all(u).then((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >r&amp;&amp;oi(t,r)}</span>)),u}</span>function <span class="fstat-no" title="function not covered" >ci(</span>t,e,n=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const i=<span class="cstat-no" title="statement not covered" >ae(t,e,n.custom);</span>let{transition:s=<span class="branch-0 cbranch-no" title="branch not covered" >t.getDefaultTransition()||{}}</span>=<span class="cstat-no" title="statement not covered" >i||{};<span class="cstat-no" title="statement not covered" ></span>n.transitionOverride&amp;&amp;(s=n.transitionOverride);c</span>onst o=<span class="cstat-no" title="statement not covered" >i?<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Promise.all(ui(t,i,n)):<span class="fstat-no" title="function not covered" ></span>()</span>=&gt;<span class="cstat-no" title="statement not covered" >Promise.resolve(),</span></span>r=<span class="cstat-no" title="statement not covered" >t.variantChildren&amp;&amp;t.variantChildren.size?<span class="fstat-no" title="function not covered" >(i</span>=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>=&gt;{const{delayChildren:o=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>staggerChildren:r,staggerDirection:a}=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>i=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>s=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>o){const r=<span class="cstat-no" title="statement not covered" >[],</span>a=<span class="cstat-no" title="statement not covered" >(t.variantChildren.size-1)*i,</span>l=<span class="cstat-no" title="statement not covered" >1===s?<span class="fstat-no" title="function not covered" >(t</span>=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>=&gt;<span class="cstat-no" title="statement not covered" >t*i:<span class="fstat-no" title="function not covered" ></span>(t</span>=<span class="branch-0 cbranch-no" title="branch not covered" >0)</span>=&gt;<span class="cstat-no" title="statement not covered" >a-t*i;<span class="cstat-no" title="statement not covered" ></span></span>return Array.from(t.variantChildren).sort(hi).forEach((<span class="fstat-no" title="function not covered" >(t</span>,i)=&gt;{<span class="cstat-no" title="statement not covered" >t.notify("AnimationStart",e),r.push(ci(t,e,{...o,delay:n+l(i)}).then((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.notify("AnimationComplete",e))</span>))}</span>)),Promise.all(r)}</span>(t,e,o+i,r,a,n)}</span>:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Promise.resolve(),</span></span>{when:a}=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>if(a){const[t,e]=<span class="cstat-no" title="statement not covered" >"beforeChildren"===a?[o,r]:[r,o];<span class="cstat-no" title="statement not covered" ></span>return t().then((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e())</span>)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Promise.all([o(),r(n.delay)])}</span>function <span class="fstat-no" title="function not covered" >hi(</span>t,e){<span class="cstat-no" title="statement not covered" >return t.sortNodePosition(e)}</span>const di=<span class="cstat-no" title="statement not covered" >[...m].reverse(),</span>pi=<span class="cstat-no" title="statement not covered" >m.length;</span>function <span class="fstat-no" title="function not covered" >mi(</span>t){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >Promise.all(e.map((<span class="fstat-no" title="function not covered" >({</span>animation:e,options:n})=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{let i;<span class="cstat-no" title="statement not covered" >if(t.notify("AnimationStart",e),Array.isArray(e)){const s=<span class="cstat-no" title="statement not covered" >e.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >ci(t,e,n))</span>);<span class="cstat-no" title="statement not covered" ></span>i=Promise.all(s)}</span>else <span class="cstat-no" title="statement not covered" >if("string"===typeof e)<span class="cstat-no" title="statement not covered" >i=ci(t,e,n);e</span>lse{const s=<span class="cstat-no" title="statement not covered" >"function"===typeof e?ae(t,e,n.custom):e;<span class="cstat-no" title="statement not covered" ></span>i=Promise.all(ui(t,s,n))}<span class="cstat-no" title="statement not covered" ></span>r</span></span>eturn i.then((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t.notify("AnimationComplete",e))</span>)}</span>(t,e,n))</span>))}</span></span>function <span class="fstat-no" title="function not covered" >fi(</span>t){let e=<span class="cstat-no" title="statement not covered" >mi(t);</span>const n=<span class="cstat-no" title="statement not covered" >{animate:yi(!0),whileInView:yi(),whileHover:yi(),whileTap:yi(),whileDrag:yi(),whileFocus:yi(),exit:yi()};</span>let i=<span class="cstat-no" title="statement not covered" >!0;</span>const s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,n)=&gt;{const i=<span class="cstat-no" title="statement not covered" >ae(t,n);<span class="cstat-no" title="statement not covered" ></span>if(i){const{transition:t,transitionEnd:n,...s}=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>e={...e,...s,...n}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}</span>;</span>function <span class="fstat-no" title="function not covered" >o(</span>o,r){const a=<span class="cstat-no" title="statement not covered" >t.getProps(),</span>l=<span class="cstat-no" title="statement not covered" >t.getVariantContext(!0)||{},</span>u=<span class="cstat-no" title="statement not covered" >[],</span>c=<span class="cstat-no" title="statement not covered" >new Set;</span>let h=<span class="cstat-no" title="statement not covered" >{},</span>m=<span class="cstat-no" title="statement not covered" >1/0;<span class="cstat-no" title="statement not covered" ></span>for(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;pi;e++){const f=<span class="cstat-no" title="statement not covered" >di[e],</span>g=<span class="cstat-no" title="statement not covered" >n[f],</span>y=<span class="cstat-no" title="statement not covered" >void 0!==a[f]?a[f]:l[f],</span>v=<span class="cstat-no" title="statement not covered" >d(y),</span>x=<span class="cstat-no" title="statement not covered" >f===r?g.isActive:null;<span class="cstat-no" title="statement not covered" ></span>!1===x&amp;&amp;(m=e);l</span>et P=<span class="cstat-no" title="statement not covered" >y===l[f]&amp;&amp;y!==a[f]&amp;&amp;v;<span class="cstat-no" title="statement not covered" ></span>if(P&amp;&amp;i&amp;&amp;t.manuallyAnimateOnMount&amp;&amp;(P=!1),g.protectedKeys={...h},!g.isActive&amp;&amp;null===x||!y&amp;&amp;!g.prevProp||p(y)||"boolean"===typeof y)<span class="cstat-no" title="statement not covered" >continue;l</span></span>et b=<span class="cstat-no" title="statement not covered" >gi(g.prevProp,y)||f===r&amp;&amp;g.isActive&amp;&amp;!P&amp;&amp;v||e&gt;m&amp;&amp;v,</span>T=<span class="cstat-no" title="statement not covered" >!1;</span>const S=<span class="cstat-no" title="statement not covered" >Array.isArray(y)?y:[y];</span>let w=<span class="cstat-no" title="statement not covered" >S.reduce(s,{});<span class="cstat-no" title="statement not covered" ></span>!1===x&amp;&amp;(w={});c</span>onst{prevResolvedValues:A=<span class="branch-0 cbranch-no" title="branch not covered" >{}}</span>=<span class="cstat-no" title="statement not covered" >g,</span>V=<span class="cstat-no" title="statement not covered" >{...A,...w},</span>E=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >b=!0,c.has(t)&amp;&amp;(T=!0,c.delete(t)),g.needsAnimating[t]=!0}</span>;<span class="cstat-no" title="statement not covered" ></span>for(const t in V){const e=<span class="cstat-no" title="statement not covered" >w[t],</span>n=<span class="cstat-no" title="statement not covered" >A[t];<span class="cstat-no" title="statement not covered" ></span>if(h.hasOwnProperty(t))<span class="cstat-no" title="statement not covered" >continue;l</span></span>et i=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>i=Mt(e)&amp;&amp;Mt(n)?!re(e,n):e!==n,i?void 0!==e?E(t):c.add(t):void 0!==e&amp;&amp;c.has(t)?E(t):g.protectedKeys[t]=!0}<span class="cstat-no" title="statement not covered" ></span>g</span>.prevProp=y,g.prevResolvedValues=w,g.isActive&amp;&amp;(h={...h,...w}),i&amp;&amp;t.blockInitialAnimation&amp;&amp;(b=!1),!b||P&amp;&amp;!T||u.push(...S.map((<span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >{animation:t,options:{type:f,...o}})</span>)))}<span class="cstat-no" title="statement not covered" ></span>i</span>f(c.size){const e=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>c.forEach((<span class="fstat-no" title="function not covered" >n=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >t.getBaseTarget(n);<span class="cstat-no" title="statement not covered" ></span>void 0!==i&amp;&amp;(e[n]=i)}</span>)),u.push({animation:e})}</span>l</span>et f=<span class="cstat-no" title="statement not covered" >Boolean(u.length);<span class="cstat-no" title="statement not covered" ></span>return!i||!1!==a.initial&amp;&amp;a.initial!==a.animate||t.manuallyAnimateOnMount||(f=!1),i=!1,f?e(u):Promise.resolve()}<span class="cstat-no" title="statement not covered" ></span>return{animateChanges:o,setActive:<span class="fstat-no" title="function not covered" >fu</span>nction(e,i,s){var r;<span class="cstat-no" title="statement not covered" >if(n[e].isActive===i)<span class="cstat-no" title="statement not covered" >return Promise.resolve();<span class="cstat-no" title="statement not covered" >n</span></span>ull===(r=t.variantChildren)||void 0===r||r.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{var n;<span class="cstat-no" title="statement not covered" >return null===(n=t.animationState)||void 0===n?void 0:n.setActive(e,i)}</span>)),n[e].isActive=i;c</span>onst a=<span class="cstat-no" title="statement not covered" >o(s,e);<span class="cstat-no" title="statement not covered" ></span>for(const t in n)<span class="cstat-no" title="statement not covered" >n[t].protectedKeys={};<span class="cstat-no" title="statement not covered" >r</span></span>eturn a}</span>,setAnimateFunction:<span class="fstat-no" title="function not covered" >fu</span>nction(n){<span class="cstat-no" title="statement not covered" >e=n(t)}</span>,getState:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >n}</span>}</span>function <span class="fstat-no" title="function not covered" >gi(</span>t,e){<span class="cstat-no" title="statement not covered" >return"string"===typeof e?e!==t:!!Array.isArray(e)&amp;&amp;!re(e,t)}</span>function <span class="fstat-no" title="function not covered" >yi(</span>t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >return{isActive:t,protectedKeys:{},needsAnimating:{},prevResolvedValues:{}}}</span>let vi=<span class="cstat-no" title="statement not covered" >0;</span>const xi=<span class="cstat-no" title="statement not covered" >{animation:{Feature:class extends Gt{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t),t.animationState||(t.animationState=fi(t))}<span class="fstat-no" title="function not covered" ></span>up</span>dateAnimationControlsSubscription(){const{animate:t}=<span class="cstat-no" title="statement not covered" >this.node.getProps();<span class="cstat-no" title="statement not covered" ></span>this.unmount(),p(t)&amp;&amp;(this.unmount=t.subscribe(this.node))}<span class="fstat-no" title="function not covered" ></span>mo</span>unt(){<span class="cstat-no" title="statement not covered" >this.updateAnimationControlsSubscription()}<span class="fstat-no" title="function not covered" ></span>up</span>date(){const{animate:t}=<span class="cstat-no" title="statement not covered" >this.node.getProps(),</span>{animate:e}=<span class="cstat-no" title="statement not covered" >this.node.prevProps||{};<span class="cstat-no" title="statement not covered" ></span>t!==e&amp;&amp;this.updateAnimationControlsSubscription()}<span class="fstat-no" title="function not covered" ></span>un</span>mount(){}}},exit:{Feature:class extends Gt{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(...arguments),this.id=vi++}<span class="fstat-no" title="function not covered" ></span>up</span>date(){<span class="cstat-no" title="statement not covered" >if(!this.node.presenceContext)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{isPresent:t,onExitComplete:e,custom:n}=<span class="cstat-no" title="statement not covered" >this.node.presenceContext,</span>{isPresent:i}=<span class="cstat-no" title="statement not covered" >this.node.prevPresenceContext||{};<span class="cstat-no" title="statement not covered" ></span>if(!this.node.animationState||t===i)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this.node.animationState.setActive("exit",!t,{custom:null!==n&amp;&amp;void 0!==n?n:this.node.getProps().custom});<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;!t&amp;&amp;s.then((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e(this.id))</span>)}<span class="fstat-no" title="function not covered" ></span>mo</span>unt(){const{register:t}=<span class="cstat-no" title="statement not covered" >this.node.presenceContext||{};<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(this.unmount=t(this.id))}<span class="fstat-no" title="function not covered" ></span>un</span>mount(){}}}},</span>Pi=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >Math.abs(t-e);</span></span>class bi{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e,{transformPagePoint:n,contextWindow:i,dragSnapToOrigin:s=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >if(this.startEvent=null,this.lastMoveEvent=null,this.lastMoveEventInfo=null,this.handlers={},this.contextWindow=window,this.updatePoint=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(!this.lastMoveEvent||!this.lastMoveEventInfo)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >wi(this.lastMoveEventInfo,this.history),</span>e=<span class="cstat-no" title="statement not covered" >null!==this.startEvent,</span>n=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const n=<span class="cstat-no" title="statement not covered" >Pi(t.x,e.x),</span>i=<span class="cstat-no" title="statement not covered" >Pi(t.y,e.y);<span class="cstat-no" title="statement not covered" ></span>return Math.sqrt(n**2+i**2)}</span>(t.offset,{x:0,y:0})&gt;=3;<span class="cstat-no" title="statement not covered" ></span>if(!e&amp;&amp;!n)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{point:i}=<span class="cstat-no" title="statement not covered" >t,</span>{timestamp:s}=<span class="cstat-no" title="statement not covered" >jt.frameData;<span class="cstat-no" title="statement not covered" ></span>this.history.push({...i,timestamp:s});c</span>onst{onStart:o,onMove:r}=<span class="cstat-no" title="statement not covered" >this.handlers;<span class="cstat-no" title="statement not covered" ></span>e||(o&amp;&amp;o(this.lastMoveEvent,t),this.startEvent=this.lastMoveEvent),r&amp;&amp;r(this.lastMoveEvent,t)}</span>,this.handlePointerMove=<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >this.lastMoveEvent=t,this.lastMoveEventInfo=Ti(e,this.transformPagePoint),jt.Wi.update(this.updatePoint,!0)}</span>,this.handlePointerUp=<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >this.end();c</span>onst{onEnd:n,onSessionEnd:i,resumeAnimation:s}=<span class="cstat-no" title="statement not covered" >this.handlers;<span class="cstat-no" title="statement not covered" ></span>if(this.dragSnapToOrigin&amp;&amp;s&amp;&amp;s(),!this.lastMoveEvent||!this.lastMoveEventInfo)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >wi("pointercancel"===t.type?this.lastMoveEventInfo:Ti(e,this.transformPagePoint),this.history);<span class="cstat-no" title="statement not covered" ></span>this.startEvent&amp;&amp;n&amp;&amp;n(t,o),i&amp;&amp;i(t,o)}</span>,!It(t))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.dragSnapToOrigin=s,this.handlers=e,this.transformPagePoint=n,this.contextWindow=i||window;c</span>onst o=<span class="cstat-no" title="statement not covered" >Ti(Ut(t),this.transformPagePoint),</span>{point:r}=<span class="cstat-no" title="statement not covered" >o,</span>{timestamp:a}=<span class="cstat-no" title="statement not covered" >jt.frameData;<span class="cstat-no" title="statement not covered" ></span>this.history=[{...r,timestamp:a}];c</span>onst{onSessionStart:l}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>l&amp;&amp;l(t,wi(o,this.history)),this.removeListeners=$t(Wt(this.contextWindow,"pointermove",this.handlePointerMove),Wt(this.contextWindow,"pointerup",this.handlePointerUp),Wt(this.contextWindow,"pointercancel",this.handlePointerUp))}<span class="fstat-no" title="function not covered" ></span>up</span>dateHandlers(t){<span class="cstat-no" title="statement not covered" >this.handlers=t}<span class="fstat-no" title="function not covered" ></span>en</span>d(){<span class="cstat-no" title="statement not covered" >this.removeListeners&amp;&amp;this.removeListeners(),(0,jt.Pn)(this.updatePoint)}</span>}function <span class="fstat-no" title="function not covered" >Ti(</span>t,e){<span class="cstat-no" title="statement not covered" >return e?{point:e(t.point)}:t}</span>function <span class="fstat-no" title="function not covered" >Si(</span>t,e){<span class="cstat-no" title="statement not covered" >return{x:t.x-e.x,y:t.y-e.y}}</span>function <span class="fstat-no" title="function not covered" >wi(</span>{point:t},e){<span class="cstat-no" title="statement not covered" >return{point:t,delta:Si(t,Vi(e)),offset:Si(t,Ai(e)),velocity:Ei(e,.1)}}</span>function <span class="fstat-no" title="function not covered" >Ai(</span>t){<span class="cstat-no" title="statement not covered" >return t[0]}</span>function <span class="fstat-no" title="function not covered" >Vi(</span>t){<span class="cstat-no" title="statement not covered" >return t[t.length-1]}</span>function <span class="fstat-no" title="function not covered" >Ei(</span>t,e){<span class="cstat-no" title="statement not covered" >if(t.length&lt;2)<span class="cstat-no" title="statement not covered" >return{x:0,y:0};l</span></span>et n=<span class="cstat-no" title="statement not covered" >t.length-1,</span>i=<span class="cstat-no" title="statement not covered" >null;</span>const s=<span class="cstat-no" title="statement not covered" >Vi(t);<span class="cstat-no" title="statement not covered" ></span>for(;n&gt;=0&amp;&amp;(i=t[n],!(s.timestamp-i.timestamp&gt;ue(e)));)<span class="cstat-no" title="statement not covered" >n--;<span class="cstat-no" title="statement not covered" >i</span></span>f(!i)<span class="cstat-no" title="statement not covered" >return{x:0,y:0};c</span></span>onst o=<span class="cstat-no" title="statement not covered" >ce(s.timestamp-i.timestamp);<span class="cstat-no" title="statement not covered" ></span>if(0===o)<span class="cstat-no" title="statement not covered" >return{x:0,y:0};c</span></span>onst r=<span class="cstat-no" title="statement not covered" >{x:(s.x-i.x)/o,y:(s.y-i.y)/o};<span class="cstat-no" title="statement not covered" ></span>return r.x===1/0&amp;&amp;(r.x=0),r.y===1/0&amp;&amp;(r.y=0),r}</span>function <span class="fstat-no" title="function not covered" >Ci(</span>t){<span class="cstat-no" title="statement not covered" >return t.max-t.min}</span>function <span class="fstat-no" title="function not covered" >Di(</span>t,e=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >.01)</span>{<span class="cstat-no" title="statement not covered" >return Math.abs(t-e)&lt;=n}</span>function <span class="fstat-no" title="function not covered" >Mi(</span>t,e,n,i=<span class="branch-0 cbranch-no" title="branch not covered" >.5)</span>{<span class="cstat-no" title="statement not covered" >t.origin=i,t.originPoint=Ue(e.min,e.max,t.origin),t.scale=Ci(n)/Ci(e),(Di(t.scale,1,1e-4)||isNaN(t.scale))&amp;&amp;(t.scale=1),t.translate=Ue(n.min,n.max,t.origin)-t.originPoint,(Di(t.translate)||isNaN(t.translate))&amp;&amp;(t.translate=0)}</span>function <span class="fstat-no" title="function not covered" >ki(</span>t,e,n,i){<span class="cstat-no" title="statement not covered" >Mi(t.x,e.x,n.x,i?i.originX:void 0),Mi(t.y,e.y,n.y,i?i.originY:void 0)}</span>function <span class="fstat-no" title="function not covered" >Ri(</span>t,e,n){<span class="cstat-no" title="statement not covered" >t.min=n.min+e.min,t.max=t.min+Ci(e)}</span>function <span class="fstat-no" title="function not covered" >Li(</span>t,e,n){<span class="cstat-no" title="statement not covered" >t.min=e.min-n.min,t.max=t.min+Ci(e)}</span>function <span class="fstat-no" title="function not covered" >ji(</span>t,e,n){<span class="cstat-no" title="statement not covered" >Li(t.x,e.x,n.x),Li(t.y,e.y,n.y)}</span>function <span class="fstat-no" title="function not covered" >Bi(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return{min:void 0!==e?t.min+e:void 0,max:void 0!==n?t.max+n-(t.max-t.min):void 0}}</span>function <span class="fstat-no" title="function not covered" >Fi(</span>t,e){let n=<span class="cstat-no" title="statement not covered" >e.min-t.min,</span>i=<span class="cstat-no" title="statement not covered" >e.max-t.max;<span class="cstat-no" title="statement not covered" ></span>return e.max-e.min&lt;t.max-t.min&amp;&amp;([n,i]=[i,n]),{min:n,max:i}}</span>const Oi=<span class="cstat-no" title="statement not covered" >.35;</span>function <span class="fstat-no" title="function not covered" >Ii(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return{min:Ui(t,e),max:Ui(t,n)}}</span>function <span class="fstat-no" title="function not covered" >Ui(</span>t,e){<span class="cstat-no" title="statement not covered" >return"number"===typeof t?t:t[e]||0}</span>function <span class="fstat-no" title="function not covered" >Wi(</span>t){<span class="cstat-no" title="statement not covered" >return[t("x"),t("y")]}</span>function <span class="fstat-no" title="function not covered" >Ni(</span>{top:t,left:e,right:n,bottom:i}){<span class="cstat-no" title="statement not covered" >return{x:{min:e,max:n},y:{min:t,max:i}}}</span>function <span class="fstat-no" title="function not covered" >$i(</span>t){<span class="cstat-no" title="statement not covered" >return void 0===t||1===t}</span>function <span class="fstat-no" title="function not covered" >Zi(</span>{scale:t,scaleX:e,scaleY:n}){<span class="cstat-no" title="statement not covered" >return!$i(t)||!$i(e)||!$i(n)}</span>function <span class="fstat-no" title="function not covered" >Hi(</span>t){<span class="cstat-no" title="statement not covered" >return Zi(t)||zi(t)||t.z||t.rotate||t.rotateX||t.rotateY}</span>function <span class="fstat-no" title="function not covered" >zi(</span>t){<span class="cstat-no" title="statement not covered" >return Yi(t.x)||Yi(t.y)}</span>function <span class="fstat-no" title="function not covered" >Yi(</span>t){<span class="cstat-no" title="statement not covered" >return t&amp;&amp;"0%"!==t}</span>function <span class="fstat-no" title="function not covered" >Xi(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return n+e*(t-n)}</span>function <span class="fstat-no" title="function not covered" >Gi(</span>t,e,n,i,s){<span class="cstat-no" title="statement not covered" >return void 0!==s&amp;&amp;(t=Xi(t,s,i)),Xi(t,n,i)+e}</span>function <span class="fstat-no" title="function not covered" >qi(</span>t,e=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>i,s){<span class="cstat-no" title="statement not covered" >t.min=Gi(t.min,e,n,i,s),t.max=Gi(t.max,e,n,i,s)}</span>function <span class="fstat-no" title="function not covered" >Ki(</span>t,{x:e,y:n}){<span class="cstat-no" title="statement not covered" >qi(t.x,e.translate,e.scale,e.originPoint),qi(t.y,n.translate,n.scale,n.originPoint)}</span>function <span class="fstat-no" title="function not covered" >_i(</span>t){<span class="cstat-no" title="statement not covered" >return Number.isInteger(t)||t&gt;1.0000000000001||t&lt;.999999999999?t:1}</span>function <span class="fstat-no" title="function not covered" >Ji(</span>t,e){<span class="cstat-no" title="statement not covered" >t.min=t.min+e,t.max=t.max+e}</span>function <span class="fstat-no" title="function not covered" >Qi(</span>t,e,[n,i,s]){const o=<span class="cstat-no" title="statement not covered" >void 0!==e[s]?e[s]:.5,</span>r=<span class="cstat-no" title="statement not covered" >Ue(t.min,t.max,o);<span class="cstat-no" title="statement not covered" ></span>qi(t,e[n],e[i],r,e.scale)}</span>const ts=<span class="cstat-no" title="statement not covered" >["x","scaleX","originX"],</span>es=<span class="cstat-no" title="statement not covered" >["y","scaleY","originY"];</span>function <span class="fstat-no" title="function not covered" >ns(</span>t,e){<span class="cstat-no" title="statement not covered" >Qi(t.x,e,ts),Qi(t.y,e,es)}</span>function <span class="fstat-no" title="function not covered" >is(</span>t,e){<span class="cstat-no" title="statement not covered" >return Ni(<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return t;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >e({x:t.left,y:t.top}),</span>i=<span class="cstat-no" title="statement not covered" >e({x:t.right,y:t.bottom});<span class="cstat-no" title="statement not covered" ></span>return{top:n.y,left:n.x,bottom:i.y,right:i.x}}</span>(t.getBoundingClientRect(),e))}</span>const ss=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>current:t})=&gt;<span class="cstat-no" title="statement not covered" >t?t.ownerDocument.defaultView:null,</span></span>os=<span class="cstat-no" title="statement not covered" >new WeakMap;</span>class rs{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >this.openGlobalLock=null,this.isDragging=!1,this.currentDirection=null,this.originPoint={x:0,y:0},this.constraints=!1,this.hasMutatedConstraints=!1,this.elastic={x:{min:0,max:0},y:{min:0,max:0}},this.visualElement=t}<span class="fstat-no" title="function not covered" ></span>st</span>art(t,{snapToCursor:e=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const{presenceContext:n}=<span class="cstat-no" title="statement not covered" >this.visualElement;<span class="cstat-no" title="statement not covered" ></span>if(n&amp;&amp;!1===n.isPresent)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{dragSnapToOrigin:i}=<span class="cstat-no" title="statement not covered" >this.getProps();<span class="cstat-no" title="statement not covered" ></span>this.panSession=new bi(t,{onSessionStart:<span class="fstat-no" title="function not covered" >t=</span>&gt;{const{dragSnapToOrigin:n}=<span class="cstat-no" title="statement not covered" >this.getProps();<span class="cstat-no" title="statement not covered" ></span>n?this.pauseAnimation():this.stopAnimation(),e&amp;&amp;this.snapToCursor(Ut(t,"page").point)}</span>,onStart:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{const{drag:n,dragPropagation:i,onDragStart:s}=<span class="cstat-no" title="statement not covered" >this.getProps();<span class="cstat-no" title="statement not covered" ></span>if(n&amp;&amp;!i&amp;&amp;(this.openGlobalLock&amp;&amp;this.openGlobalLock(),this.openGlobalLock=Yt(n),!this.openGlobalLock))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.isDragging=!0,this.currentDirection=null,this.resolveConstraints(),this.visualElement.projection&amp;&amp;(this.visualElement.projection.isAnimationBlocked=!0,this.visualElement.projection.target=void 0),Wi((<span class="fstat-no" title="function not covered" >t=</span>&gt;{let e=<span class="cstat-no" title="statement not covered" >this.getAxisMotionValue(t).get()||0;<span class="cstat-no" title="statement not covered" ></span>if(Q.test(e)){const{projection:n}=<span class="cstat-no" title="statement not covered" >this.visualElement;<span class="cstat-no" title="statement not covered" ></span>if(n&amp;&amp;n.layout){const i=<span class="cstat-no" title="statement not covered" >n.layout.layoutBox[t];<span class="cstat-no" title="statement not covered" ></span>if(i){<span class="cstat-no" title="statement not covered" >e=Ci(i)*(parseFloat(e)/100)}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>his.originPoint[t]=e}</span>)),s&amp;&amp;jt.Wi.update((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >s(t,e))</span>,!1,!0);c</span>onst{animationState:o}=<span class="cstat-no" title="statement not covered" >this.visualElement;<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;o.setActive("whileDrag",!0)}</span>,onMove:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{const{dragPropagation:n,dragDirectionLock:i,onDirectionLock:s,onDrag:o}=<span class="cstat-no" title="statement not covered" >this.getProps();<span class="cstat-no" title="statement not covered" ></span>if(!n&amp;&amp;!this.openGlobalLock)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{offset:r}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>if(i&amp;&amp;null===this.currentDirection)<span class="cstat-no" title="statement not covered" >return this.currentDirection=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >10)</span>{let n=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>Math.abs(t.y)&gt;e?n="y":Math.abs(t.x)&gt;e&amp;&amp;(n="x");<span class="cstat-no" title="statement not covered" >r</span>eturn n}</span>(r),void(null!==this.currentDirection&amp;&amp;s&amp;&amp;s(this.currentDirection));<span class="cstat-no" title="statement not covered" >t</span></span>his.updateAxis("x",e.point,r),this.updateAxis("y",e.point,r),this.visualElement.render(),o&amp;&amp;o(t,e)}</span>,onSessionEnd:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >this.stop(t,e),</span>resumeAnimation:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Wi((<span class="fstat-no" title="function not covered" >t=</span>&gt;{var e;<span class="cstat-no" title="statement not covered" >return"paused"===this.getAnimationState(t)&amp;&amp;(null===(e=this.getAxisMotionValue(t).animation)||void 0===e?void 0:e.play())}</span>))}</span>,{transformPagePoint:this.visualElement.getTransformPagePoint(),dragSnapToOrigin:i,contextWindow:ss(this.visualElement)})}<span class="fstat-no" title="function not covered" ></span>st</span>op(t,e){const n=<span class="cstat-no" title="statement not covered" >this.isDragging;<span class="cstat-no" title="statement not covered" ></span>if(this.cancel(),!n)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{velocity:i}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>this.startAnimation(i);c</span>onst{onDragEnd:s}=<span class="cstat-no" title="statement not covered" >this.getProps();<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;jt.Wi.update((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >s(t,e))</span>)}<span class="fstat-no" title="function not covered" ></span>ca</span>ncel(){<span class="cstat-no" title="statement not covered" >this.isDragging=!1;c</span>onst{projection:t,animationState:e}=<span class="cstat-no" title="statement not covered" >this.visualElement;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(t.isAnimationBlocked=!1),this.panSession&amp;&amp;this.panSession.end(),this.panSession=void 0;c</span>onst{dragPropagation:n}=<span class="cstat-no" title="statement not covered" >this.getProps();<span class="cstat-no" title="statement not covered" ></span>!n&amp;&amp;this.openGlobalLock&amp;&amp;(this.openGlobalLock(),this.openGlobalLock=null),e&amp;&amp;e.setActive("whileDrag",!1)}<span class="fstat-no" title="function not covered" ></span>up</span>dateAxis(t,e,n){const{drag:i}=<span class="cstat-no" title="statement not covered" >this.getProps();<span class="cstat-no" title="statement not covered" ></span>if(!n||!as(t,i,this.currentDirection))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this.getAxisMotionValue(t);</span>let o=<span class="cstat-no" title="statement not covered" >this.originPoint[t]+n[t];<span class="cstat-no" title="statement not covered" ></span>this.constraints&amp;&amp;this.constraints[t]&amp;&amp;(o=<span class="fstat-no" title="function not covered" >fu</span>nction(t,{min:e,max:n},i){<span class="cstat-no" title="statement not covered" >return void 0!==e&amp;&amp;t&lt;e?t=i?Ue(e,t,i.min):Math.max(t,e):void 0!==n&amp;&amp;t&gt;n&amp;&amp;(t=i?Ue(n,t,i.max):Math.min(t,n)),t}</span>(o,this.constraints[t],this.elastic[t])),s.set(o)}<span class="fstat-no" title="function not covered" ></span>re</span>solveConstraints(){var t;const{dragConstraints:e,dragElastic:n}=<span class="cstat-no" title="statement not covered" >this.getProps(),</span>i=<span class="cstat-no" title="statement not covered" >this.visualElement.projection&amp;&amp;!this.visualElement.projection.layout?this.visualElement.projection.measure(!1):null===(t=this.visualElement.projection)||void 0===t?void 0:t.layout,</span>s=<span class="cstat-no" title="statement not covered" >this.constraints;<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;h(e)?this.constraints||(this.constraints=this.resolveRefConstraints()):this.constraints=!(!e||!i)&amp;&amp;<span class="fstat-no" title="function not covered" >fu</span>nction(t,{top:e,left:n,bottom:i,right:s}){<span class="cstat-no" title="statement not covered" >return{x:Bi(t.x,n,s),y:Bi(t.y,e,i)}}</span>(i.layoutBox,e),this.elastic=<span class="fstat-no" title="function not covered" >fu</span>nction(t=<span class="branch-0 cbranch-no" title="branch not covered" >Oi)</span>{<span class="cstat-no" title="statement not covered" >return!1===t?t=0:!0===t&amp;&amp;(t=Oi),{x:Ii(t,"left","right"),y:Ii(t,"top","bottom")}}</span>(n),s!==this.constraints&amp;&amp;i&amp;&amp;this.constraints&amp;&amp;!this.hasMutatedConstraints&amp;&amp;Wi((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.getAxisMotionValue(t)&amp;&amp;(this.constraints[t]=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const n=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>return void 0!==e.min&amp;&amp;(n.min=e.min-t.min),void 0!==e.max&amp;&amp;(n.max=e.max-t.min),n}</span>(i.layoutBox[t],this.constraints[t]))}</span>))}<span class="fstat-no" title="function not covered" ></span>re</span>solveRefConstraints(){const{dragConstraints:t,onMeasureDragConstraints:e}=<span class="cstat-no" title="statement not covered" >this.getProps();<span class="cstat-no" title="statement not covered" ></span>if(!t||!h(t))<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >t.current;<span class="cstat-no" title="statement not covered" ></span>(0,le.k)(null!==n,"If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");c</span>onst{projection:i}=<span class="cstat-no" title="statement not covered" >this.visualElement;<span class="cstat-no" title="statement not covered" ></span>if(!i||!i.layout)<span class="cstat-no" title="statement not covered" >return!1;c</span></span>onst s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){const i=<span class="cstat-no" title="statement not covered" >is(t,n),</span>{scroll:s}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return s&amp;&amp;(Ji(i.x,s.offset.x),Ji(i.y,s.offset.y)),i}</span>(n,i.root,this.visualElement.getTransformPagePoint());</span>let o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return{x:Fi(t.x,e.x),y:Fi(t.y,e.y)}}</span>(i.layout.layoutBox,s);<span class="cstat-no" title="statement not covered" ></span>if(e){const t=<span class="cstat-no" title="statement not covered" >e(<span class="fstat-no" title="function not covered" >fu</span>nction({x:t,y:e}){<span class="cstat-no" title="statement not covered" >return{top:e.min,right:t.max,bottom:e.max,left:t.min}}</span>(o));<span class="cstat-no" title="statement not covered" ></span>this.hasMutatedConstraints=!!t,t&amp;&amp;(o=Ni(t))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn o}<span class="fstat-no" title="function not covered" ></span>st</span>artAnimation(t){const{drag:e,dragMomentum:n,dragElastic:i,dragTransition:s,dragSnapToOrigin:o,onDragTransitionEnd:r}=<span class="cstat-no" title="statement not covered" >this.getProps(),</span>a=<span class="cstat-no" title="statement not covered" >this.constraints||{},</span>l=<span class="cstat-no" title="statement not covered" >Wi((<span class="fstat-no" title="function not covered" >r=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!as(r,e,this.currentDirection))<span class="cstat-no" title="statement not covered" >return;l</span></span>et l=<span class="cstat-no" title="statement not covered" >a&amp;&amp;a[r]||{};<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;(l={min:0,max:0});c</span>onst u=<span class="cstat-no" title="statement not covered" >i?200:1e6,</span>c=<span class="cstat-no" title="statement not covered" >i?40:1e7,</span>h=<span class="cstat-no" title="statement not covered" >{type:"inertia",velocity:n?t[r]:0,bounceStiffness:u,bounceDamping:c,timeConstant:750,restDelta:1,restSpeed:10,...s,...l};<span class="cstat-no" title="statement not covered" ></span>return this.startAxisValueAnimation(r,h)}</span>));<span class="cstat-no" title="statement not covered" ></span>return Promise.all(l).then(r)}<span class="fstat-no" title="function not covered" ></span>st</span>artAxisValueAnimation(t,e){const n=<span class="cstat-no" title="statement not covered" >this.getAxisMotionValue(t);<span class="cstat-no" title="statement not covered" ></span>return n.start(zn(t,n,0,e))}<span class="fstat-no" title="function not covered" ></span>st</span>opAnimation(){<span class="cstat-no" title="statement not covered" >Wi((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this.getAxisMotionValue(t).stop())</span>)}<span class="fstat-no" title="function not covered" ></span>pa</span>useAnimation(){<span class="cstat-no" title="statement not covered" >Wi((<span class="fstat-no" title="function not covered" >t=</span>&gt;{var e;<span class="cstat-no" title="statement not covered" >return null===(e=this.getAxisMotionValue(t).animation)||void 0===e?void 0:e.pause()}</span>))}<span class="fstat-no" title="function not covered" ></span>ge</span>tAnimationState(t){var e;<span class="cstat-no" title="statement not covered" >return null===(e=this.getAxisMotionValue(t).animation)||void 0===e?void 0:e.state}<span class="fstat-no" title="function not covered" ></span>ge</span>tAxisMotionValue(t){const e=<span class="cstat-no" title="statement not covered" >"_drag"+t.toUpperCase(),</span>n=<span class="cstat-no" title="statement not covered" >this.visualElement.getProps(),</span>i=<span class="cstat-no" title="statement not covered" >n[e];<span class="cstat-no" title="statement not covered" ></span>return i||this.visualElement.getValue(t,(n.initial?n.initial[t]:void 0)||0)}<span class="fstat-no" title="function not covered" ></span>sn</span>apToCursor(t){<span class="cstat-no" title="statement not covered" >Wi((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const{drag:n}=<span class="cstat-no" title="statement not covered" >this.getProps();<span class="cstat-no" title="statement not covered" ></span>if(!as(e,n,this.currentDirection))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{projection:i}=<span class="cstat-no" title="statement not covered" >this.visualElement,</span>s=<span class="cstat-no" title="statement not covered" >this.getAxisMotionValue(e);<span class="cstat-no" title="statement not covered" ></span>if(i&amp;&amp;i.layout){const{min:n,max:o}=<span class="cstat-no" title="statement not covered" >i.layout.layoutBox[e];<span class="cstat-no" title="statement not covered" ></span>s.set(t[e]-Ue(n,o,.5))}</span>}</span>))}<span class="fstat-no" title="function not covered" ></span>sc</span>alePositionWithinConstraints(){<span class="cstat-no" title="statement not covered" >if(!this.visualElement.current)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{drag:t,dragConstraints:e}=<span class="cstat-no" title="statement not covered" >this.getProps(),</span>{projection:n}=<span class="cstat-no" title="statement not covered" >this.visualElement;<span class="cstat-no" title="statement not covered" ></span>if(!h(e)||!n||!this.constraints)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.stopAnimation();c</span>onst i=<span class="cstat-no" title="statement not covered" >{x:0,y:0};<span class="cstat-no" title="statement not covered" ></span>Wi((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >this.getAxisMotionValue(t);<span class="cstat-no" title="statement not covered" ></span>if(e){const n=<span class="cstat-no" title="statement not covered" >e.get();<span class="cstat-no" title="statement not covered" ></span>i[t]=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){let n=<span class="cstat-no" title="statement not covered" >.5;</span>const i=<span class="cstat-no" title="statement not covered" >Ci(t),</span>s=<span class="cstat-no" title="statement not covered" >Ci(e);<span class="cstat-no" title="statement not covered" ></span>return s&gt;i?n=rn(e.min,e.max-i,t.min):i&gt;s&amp;&amp;(n=rn(t.min,t.max-s,e.min)),$(0,1,n)}</span>({min:n,max:n},this.constraints[t])}</span>}</span>));c</span>onst{transformTemplate:s}=<span class="cstat-no" title="statement not covered" >this.visualElement.getProps();<span class="cstat-no" title="statement not covered" ></span>this.visualElement.current.style.transform=s?s({},""):"none",n.root&amp;&amp;n.root.updateScroll(),n.updateLayout(),this.resolveConstraints(),Wi((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!as(e,t,null))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >this.getAxisMotionValue(e),</span>{min:s,max:o}=<span class="cstat-no" title="statement not covered" >this.constraints[e];<span class="cstat-no" title="statement not covered" ></span>n.set(Ue(s,o,i[e]))}</span>))}<span class="fstat-no" title="function not covered" ></span>ad</span>dListeners(){<span class="cstat-no" title="statement not covered" >if(!this.visualElement.current)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >o</span></span>s.set(this.visualElement,this);c</span>onst t=<span class="cstat-no" title="statement not covered" >Wt(this.visualElement.current,"pointerdown",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{const{drag:e,dragListener:n=<span class="branch-0 cbranch-no" title="branch not covered" >!0}</span>=<span class="cstat-no" title="statement not covered" >this.getProps();<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;n&amp;&amp;this.start(t)}</span>)),</span>e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{const{dragConstraints:t}=<span class="cstat-no" title="statement not covered" >this.getProps();<span class="cstat-no" title="statement not covered" ></span>h(t)&amp;&amp;(this.constraints=this.resolveRefConstraints())}</span>,</span>{projection:n}=<span class="cstat-no" title="statement not covered" >this.visualElement,</span>i=<span class="cstat-no" title="statement not covered" >n.addEventListener("measure",e);<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;!n.layout&amp;&amp;(n.root&amp;&amp;n.root.updateScroll(),n.updateLayout()),e();c</span>onst s=<span class="cstat-no" title="statement not covered" >Ot(window,"resize",(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.scalePositionWithinConstraints())</span>),</span>o=<span class="cstat-no" title="statement not covered" >n.addEventListener("didUpdate",(<span class="fstat-no" title="function not covered" >({</span>delta:t,hasLayoutChanged:e})=&gt;{<span class="cstat-no" title="statement not covered" >this.isDragging&amp;&amp;e&amp;&amp;(Wi((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >this.getAxisMotionValue(e);<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;(this.originPoint[e]+=t[e].translate,n.set(n.get()+t[e].translate))}</span>)),this.visualElement.render())}</span>));<span class="cstat-no" title="statement not covered" ></span>return<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >s(),t(),i(),o&amp;&amp;o()}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>tProps(){const t=<span class="cstat-no" title="statement not covered" >this.visualElement.getProps(),</span>{drag:e=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>dragDirectionLock:n=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>dragPropagation:i=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>dragConstraints:s=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>dragElastic:o=<span class="branch-0 cbranch-no" title="branch not covered" >Oi,</span>dragMomentum:r=<span class="branch-0 cbranch-no" title="branch not covered" >!0}</span>=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return{...t,drag:e,dragDirectionLock:n,dragPropagation:i,dragConstraints:s,dragElastic:o,dragMomentum:r}}</span>}function <span class="fstat-no" title="function not covered" >as(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return(!0===e||e===t)&amp;&amp;(null===n||n===t)}</span>const ls=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,n)=&gt;{<span class="cstat-no" title="statement not covered" >t&amp;&amp;jt.Wi.update((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t(e,n))</span>)}</span>;</span></span>const us=<span class="cstat-no" title="statement not covered" >{hasAnimatedSinceResize:!0,hasEverUpdated:!1};</span>function <span class="fstat-no" title="function not covered" >cs(</span>t,e){<span class="cstat-no" title="statement not covered" >return e.max===e.min?0:t/(e.max-e.min)*100}</span>const hs=<span class="cstat-no" title="statement not covered" >{correct:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >if(!e.target)<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >i</span></span>f("string"===typeof t){<span class="cstat-no" title="statement not covered" >if(!tt.test(t))<span class="cstat-no" title="statement not covered" >return t;<span class="cstat-no" title="statement not covered" >t</span></span>=parseFloat(t)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn`${cs(t,e.target.x)}% ${cs(t,e.target.y)}%`}</span>},</span>ds=<span class="cstat-no" title="statement not covered" >{correct:<span class="fstat-no" title="function not covered" >(t</span>,{treeScale:e,projectionDelta:n})=&gt;{const i=<span class="cstat-no" title="statement not covered" >t,</span>s=<span class="cstat-no" title="statement not covered" >Qe.parse(t);<span class="cstat-no" title="statement not covered" ></span>if(s.length&gt;5)<span class="cstat-no" title="statement not covered" >return i;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >Qe.createTransformer(t),</span>r=<span class="cstat-no" title="statement not covered" >"number"!==typeof s[0]?1:0,</span>a=<span class="cstat-no" title="statement not covered" >n.x.scale*e.x,</span>l=<span class="cstat-no" title="statement not covered" >n.y.scale*e.y;<span class="cstat-no" title="statement not covered" ></span>s[0+r]/=a,s[1+r]/=l;c</span>onst u=<span class="cstat-no" title="statement not covered" >Ue(a,l,.5);<span class="cstat-no" title="statement not covered" ></span>return"number"===typeof s[2+r]&amp;&amp;(s[2+r]/=u),"number"===typeof s[3+r]&amp;&amp;(s[3+r]/=u),o(s)}</span>};</span>class ps extends i.Component{<span class="fstat-no" title="function not covered" >co</span>mponentDidMount(){const{visualElement:t,layoutGroup:e,switchLayoutGroup:n,layoutId:i}=<span class="cstat-no" title="statement not covered" >this.props,</span>{projection:s}=<span class="cstat-no" title="statement not covered" >t;</span>var o;<span class="cstat-no" title="statement not covered" >o=fs,Object.assign(k,o),s&amp;&amp;(e.group&amp;&amp;e.group.add(s),n&amp;&amp;n.register&amp;&amp;i&amp;&amp;n.register(s),s.root.didUpdate(),s.addEventListener("animationComplete",(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.safeToRemove()}</span>)),s.setOptions({...s.options,onExitComplete:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.safeToRemove()}</span>)),us.hasEverUpdated=!0}<span class="fstat-no" title="function not covered" ></span>ge</span>tSnapshotBeforeUpdate(t){const{layoutDependency:e,visualElement:n,drag:i,isPresent:s}=<span class="cstat-no" title="statement not covered" >this.props,</span>o=<span class="cstat-no" title="statement not covered" >n.projection;<span class="cstat-no" title="statement not covered" ></span>return o?(o.isPresent=s,i||t.layoutDependency!==e||void 0===e?o.willUpdate():this.safeToRemove(),t.isPresent!==s&amp;&amp;(s?o.promote():o.relegate()||jt.Wi.postRender((<span class="fstat-no" title="function not covered" >()</span>=&gt;{const t=<span class="cstat-no" title="statement not covered" >o.getStack();<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;t.members.length||this.safeToRemove()}</span>))),null):null}<span class="fstat-no" title="function not covered" ></span>co</span>mponentDidUpdate(){const{projection:t}=<span class="cstat-no" title="statement not covered" >this.props.visualElement;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(t.root.didUpdate(),queueMicrotask((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >!t.currentAnimation&amp;&amp;t.isLead()&amp;&amp;this.safeToRemove()}</span>)))}<span class="fstat-no" title="function not covered" ></span>co</span>mponentWillUnmount(){const{visualElement:t,layoutGroup:e,switchLayoutGroup:n}=<span class="cstat-no" title="statement not covered" >this.props,</span>{projection:i}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;(i.scheduleCheckAfterUnmount(),e&amp;&amp;e.group&amp;&amp;e.group.remove(i),n&amp;&amp;n.deregister&amp;&amp;n.deregister(i))}<span class="fstat-no" title="function not covered" ></span>sa</span>feToRemove(){const{safeToRemove:t}=<span class="cstat-no" title="statement not covered" >this.props;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;t()}<span class="fstat-no" title="function not covered" ></span>re</span>nder(){<span class="cstat-no" title="statement not covered" >return null}</span>}function <span class="fstat-no" title="function not covered" >ms(</span>t){const[e,n]=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(){const t=<span class="cstat-no" title="statement not covered" >(0,i.useContext)(r.O);<span class="cstat-no" title="statement not covered" ></span>if(null===t)<span class="cstat-no" title="statement not covered" >return[!0,null];c</span></span>onst{isPresent:e,onExitComplete:n,register:s}=<span class="cstat-no" title="statement not covered" >t,</span>o=<span class="cstat-no" title="statement not covered" >(0,i.useId)();<span class="cstat-no" title="statement not covered" ></span>return(0,i.useEffect)((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >s(o))</span>,[]),!e&amp;&amp;n?[!1,<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >n&amp;&amp;n(o)]</span>:[!0]}</span>(),</span>s=<span class="cstat-no" title="statement not covered" >(0,i.useContext)(S.p);<span class="cstat-no" title="statement not covered" ></span>return i.createElement(ps,{...t,layoutGroup:s,switchLayoutGroup:(0,i.useContext)(w),isPresent:e,safeToRemove:n})}</span>const fs=<span class="cstat-no" title="statement not covered" >{borderRadius:{...hs,applyTo:["borderTopLeftRadius","borderTopRightRadius","borderBottomLeftRadius","borderBottomRightRadius"]},borderTopLeftRadius:hs,borderTopRightRadius:hs,borderBottomLeftRadius:hs,borderBottomRightRadius:hs,boxShadow:ds},</span>gs=<span class="cstat-no" title="statement not covered" >["TopLeft","TopRight","BottomLeft","BottomRight"],</span>ys=<span class="cstat-no" title="statement not covered" >gs.length,</span>vs=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"string"===typeof t?parseFloat(t):t,</span></span>xs=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"number"===typeof t||tt.test(t);</span></span>function <span class="fstat-no" title="function not covered" >Ps(</span>t,e){<span class="cstat-no" title="statement not covered" >return void 0!==t[e]?t[e]:t.borderRadius}</span>const bs=<span class="cstat-no" title="statement not covered" >Ss(0,.5,Ae),</span>Ts=<span class="cstat-no" title="statement not covered" >Ss(.5,.95,_t.Z);</span>function <span class="fstat-no" title="function not covered" >Ss(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >i=</span>&gt;<span class="cstat-no" title="statement not covered" >i&lt;t?0:i&gt;e?1:n(rn(t,e,i))}</span></span>function <span class="fstat-no" title="function not covered" >ws(</span>t,e){<span class="cstat-no" title="statement not covered" >t.min=e.min,t.max=e.max}</span>function <span class="fstat-no" title="function not covered" >As(</span>t,e){<span class="cstat-no" title="statement not covered" >ws(t.x,e.x),ws(t.y,e.y)}</span>function <span class="fstat-no" title="function not covered" >Vs(</span>t,e,n,i,s){<span class="cstat-no" title="statement not covered" >return t=Xi(t-=e,1/n,i),void 0!==s&amp;&amp;(t=Xi(t,1/s,i)),t}</span>function <span class="fstat-no" title="function not covered" >Es(</span>t,e,[n,i,s],o,r){<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >fu</span>nction(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >0,</span>n=<span class="branch-0 cbranch-no" title="branch not covered" >1,</span>i=<span class="branch-0 cbranch-no" title="branch not covered" >.5,</span>s,o=<span class="branch-0 cbranch-no" title="branch not covered" >t,</span>r=<span class="branch-0 cbranch-no" title="branch not covered" >t)</span>{<span class="cstat-no" title="statement not covered" >Q.test(e)&amp;&amp;(e=parseFloat(e),e=Ue(r.min,r.max,e/100)-r.min);<span class="cstat-no" title="statement not covered" >i</span>f("number"!==typeof e)<span class="cstat-no" title="statement not covered" >return;l</span></span>et a=<span class="cstat-no" title="statement not covered" >Ue(o.min,o.max,i);<span class="cstat-no" title="statement not covered" ></span>t===o&amp;&amp;(a-=e),t.min=Vs(t.min,e,n,a,s),t.max=Vs(t.max,e,n,a,s)}</span>(t,e[n],e[i],e[s],e.scale,o,r)}</span>const Cs=<span class="cstat-no" title="statement not covered" >["x","scaleX","originX"],</span>Ds=<span class="cstat-no" title="statement not covered" >["y","scaleY","originY"];</span>function <span class="fstat-no" title="function not covered" >Ms(</span>t,e,n,i){<span class="cstat-no" title="statement not covered" >Es(t.x,e,Cs,n?n.x:void 0,i?i.x:void 0),Es(t.y,e,Ds,n?n.y:void 0,i?i.y:void 0)}</span>function <span class="fstat-no" title="function not covered" >ks(</span>t){<span class="cstat-no" title="statement not covered" >return 0===t.translate&amp;&amp;1===t.scale}</span>function <span class="fstat-no" title="function not covered" >Rs(</span>t){<span class="cstat-no" title="statement not covered" >return ks(t.x)&amp;&amp;ks(t.y)}</span>function <span class="fstat-no" title="function not covered" >Ls(</span>t,e){<span class="cstat-no" title="statement not covered" >return Math.round(t.x.min)===Math.round(e.x.min)&amp;&amp;Math.round(t.x.max)===Math.round(e.x.max)&amp;&amp;Math.round(t.y.min)===Math.round(e.y.min)&amp;&amp;Math.round(t.y.max)===Math.round(e.y.max)}</span>function <span class="fstat-no" title="function not covered" >js(</span>t){<span class="cstat-no" title="statement not covered" >return Ci(t.x)/Ci(t.y)}</span>class Bs{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.members=[]}<span class="fstat-no" title="function not covered" ></span>ad</span>d(t){<span class="cstat-no" title="statement not covered" >Gn(this.members,t),t.scheduleRender()}<span class="fstat-no" title="function not covered" ></span>re</span>move(t){<span class="cstat-no" title="statement not covered" >if(qn(this.members,t),t===this.prevLead&amp;&amp;(this.prevLead=void 0),t===this.lead){const t=<span class="cstat-no" title="statement not covered" >this.members[this.members.length-1];<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;this.promote(t)}</span>}<span class="fstat-no" title="function not covered" ></span>re</span>legate(t){const e=<span class="cstat-no" title="statement not covered" >this.members.findIndex((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >t===e)</span>);<span class="cstat-no" title="statement not covered" ></span>if(0===e)<span class="cstat-no" title="statement not covered" >return!1;l</span></span>et n;<span class="cstat-no" title="statement not covered" >for(let i=<span class="cstat-no" title="statement not covered" >e;</span>i&gt;=0;i--){const t=<span class="cstat-no" title="statement not covered" >this.members[i];<span class="cstat-no" title="statement not covered" ></span>if(!1!==t.isPresent){<span class="cstat-no" title="statement not covered" >n=t;<span class="cstat-no" title="statement not covered" >b</span>reak}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!!n&amp;&amp;(this.promote(n),!0)}<span class="fstat-no" title="function not covered" ></span>pr</span>omote(t,e){const n=<span class="cstat-no" title="statement not covered" >this.lead;<span class="cstat-no" title="statement not covered" ></span>if(t!==n&amp;&amp;(this.prevLead=n,this.lead=t,t.show(),n)){<span class="cstat-no" title="statement not covered" >n.instance&amp;&amp;n.scheduleRender(),t.scheduleRender(),t.resumeFrom=n,e&amp;&amp;(t.resumeFrom.preserveOpacity=!0),n.snapshot&amp;&amp;(t.snapshot=n.snapshot,t.snapshot.latestValues=n.animationValues||n.latestValues),t.root&amp;&amp;t.root.isUpdating&amp;&amp;(t.isLayoutDirty=!0);c</span>onst{crossfade:i}=<span class="cstat-no" title="statement not covered" >t.options;<span class="cstat-no" title="statement not covered" ></span>!1===i&amp;&amp;n.hide()}</span>}<span class="fstat-no" title="function not covered" ></span>ex</span>itAnimationComplete(){<span class="cstat-no" title="statement not covered" >this.members.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const{options:e,resumingFrom:n}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>e.onExitComplete&amp;&amp;e.onExitComplete(),n&amp;&amp;n.options.onExitComplete&amp;&amp;n.options.onExitComplete()}</span>))}<span class="fstat-no" title="function not covered" ></span>sc</span>heduleRender(){<span class="cstat-no" title="statement not covered" >this.members.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.instance&amp;&amp;t.scheduleRender(!1)}</span>))}<span class="fstat-no" title="function not covered" ></span>re</span>moveLeadSnapshot(){<span class="cstat-no" title="statement not covered" >this.lead&amp;&amp;this.lead.snapshot&amp;&amp;(this.lead.snapshot=void 0)}</span>}function <span class="fstat-no" title="function not covered" >Fs(</span>t,e,n){let i=<span class="cstat-no" title="statement not covered" >"";</span>const s=<span class="cstat-no" title="statement not covered" >t.x.translate/e.x,</span>o=<span class="cstat-no" title="statement not covered" >t.y.translate/e.y;<span class="cstat-no" title="statement not covered" ></span>if((s||o)&amp;&amp;(i=`translate3d(${s}px, ${o}px, 0) `),1===e.x&amp;&amp;1===e.y||(i+=`scale(${1/e.x}, ${1/e.y}) `),n){const{rotate:t,rotateX:e,rotateY:s}=<span class="cstat-no" title="statement not covered" >n;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(i+=`rotate(${t}deg) `),e&amp;&amp;(i+=`rotateX(${e}deg) `),s&amp;&amp;(i+=`rotateY(${s}deg) `)}</span>c</span>onst r=<span class="cstat-no" title="statement not covered" >t.x.scale*e.x,</span>a=<span class="cstat-no" title="statement not covered" >t.y.scale*e.y;<span class="cstat-no" title="statement not covered" ></span>return 1===r&amp;&amp;1===a||(i+=`scale(${r}, ${a})`),i||"none"}</span>const Os=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t.depth-e.depth;</span></span>class Is{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >this.children=[],this.isDirty=!1}<span class="fstat-no" title="function not covered" ></span>ad</span>d(t){<span class="cstat-no" title="statement not covered" >Gn(this.children,t),this.isDirty=!0}<span class="fstat-no" title="function not covered" ></span>re</span>move(t){<span class="cstat-no" title="statement not covered" >qn(this.children,t),this.isDirty=!0}<span class="fstat-no" title="function not covered" ></span>fo</span>rEach(t){<span class="cstat-no" title="statement not covered" >this.isDirty&amp;&amp;this.children.sort(Os),this.isDirty=!1,this.children.forEach(t)}</span>}const Us=<span class="cstat-no" title="statement not covered" >["","X","Y","Z"],</span>Ws=<span class="cstat-no" title="statement not covered" >{visibility:"hidden"};</span>let Ns=<span class="cstat-no" title="statement not covered" >0;</span>const $s=<span class="cstat-no" title="statement not covered" >{type:"projectionFrame",totalNodes:0,resolvedTargetDeltas:0,recalculatedProjection:0};</span>function <span class="fstat-no" title="function not covered" >Zs(</span>{attachResizeListener:t,defaultParent:e,measureScroll:n,checkIsScrollRoot:i,resetTransform:s}){<span class="cstat-no" title="statement not covered" >return class{<span class="fstat-no" title="function not covered" >co</span>nstructor(t=<span class="branch-0 cbranch-no" title="branch not covered" >{},</span>n=(<span class="branch-0 cbranch-no" title="branch not covered" >null===e||void 0===e?void 0:e())</span>){<span class="cstat-no" title="statement not covered" >this.id=Ns++,this.animationId=0,this.children=new Set,this.options={},this.isTreeAnimating=!1,this.isAnimationBlocked=!1,this.isLayoutDirty=!1,this.isProjectionDirty=!1,this.isSharedProjectionDirty=!1,this.isTransformDirty=!1,this.updateManuallyBlocked=!1,this.updateBlockedByResize=!1,this.isUpdating=!1,this.isSVG=!1,this.needsReset=!1,this.shouldResetTransform=!1,this.treeScale={x:1,y:1},this.eventHandlers=new Map,this.hasTreeAnimated=!1,this.updateScheduled=!1,this.projectionUpdateScheduled=!1,this.checkUpdateFailed=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.isUpdating&amp;&amp;(this.isUpdating=!1,this.clearAllSnapshots())}</span>,this.updateProjection=<span class="fstat-no" title="function not covered" >()</span>=&gt;{var t;<span class="cstat-no" title="statement not covered" >this.projectionUpdateScheduled=!1,$s.totalNodes=$s.resolvedTargetDeltas=$s.recalculatedProjection=0,this.nodes.forEach(Ys),this.nodes.forEach(Qs),this.nodes.forEach(to),this.nodes.forEach(Xs),t=$s,window.MotionDebug&amp;&amp;window.MotionDebug.record(t)}</span>,this.hasProjected=!1,this.isVisible=!0,this.animationProgress=0,this.sharedNodes=new Map,this.latestValues=t,this.root=n?n.root||n:this,this.path=n?[...n.path,n]:[],this.parent=n,this.depth=n?n.depth+1:0;<span class="cstat-no" title="statement not covered" >f</span>or(let e=<span class="cstat-no" title="statement not covered" >0;</span>e&lt;this.path.length;e++)<span class="cstat-no" title="statement not covered" >this.path[e].shouldResetTransform=!0;<span class="cstat-no" title="statement not covered" >t</span></span>his.root===this&amp;&amp;(this.nodes=new Is)}<span class="fstat-no" title="function not covered" ></span>ad</span>dEventListener(t,e){<span class="cstat-no" title="statement not covered" >return this.eventHandlers.has(t)||this.eventHandlers.set(t,new Kn),this.eventHandlers.get(t).add(e)}<span class="fstat-no" title="function not covered" ></span>no</span>tifyListeners(t,...e){const n=<span class="cstat-no" title="statement not covered" >this.eventHandlers.get(t);<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;n.notify(...e)}<span class="fstat-no" title="function not covered" ></span>ha</span>sListeners(t){<span class="cstat-no" title="statement not covered" >return this.eventHandlers.has(t)}<span class="fstat-no" title="function not covered" ></span>mo</span>unt(e,n=<span class="branch-0 cbranch-no" title="branch not covered" >this.root.hasTreeAnimated)</span>{<span class="cstat-no" title="statement not covered" >if(this.instance)<span class="cstat-no" title="statement not covered" >return;v</span></span>ar i;<span class="cstat-no" title="statement not covered" >this.isSVG=(i=e)instanceof SVGElement&amp;&amp;"svg"!==i.tagName,this.instance=e;c</span>onst{layoutId:s,layout:o,visualElement:r}=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if(r&amp;&amp;!r.current&amp;&amp;r.mount(e),this.root.nodes.add(this),this.parent&amp;&amp;this.parent.children.add(this),n&amp;&amp;(o||s)&amp;&amp;(this.isLayoutDirty=!0),t){let n;const i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.root.updateBlockedByResize=!1;<span class="cstat-no" title="statement not covered" ></span></span>t(e,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.root.updateBlockedByResize=!0,n&amp;&amp;n(),n=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e){const n=<span class="cstat-no" title="statement not covered" >performance.now(),</span>i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >({</span>timestamp:s})=&gt;{const o=<span class="cstat-no" title="statement not covered" >s-n;<span class="cstat-no" title="statement not covered" ></span>o&gt;=e&amp;&amp;((0,jt.Pn)(i),t(o-e))}</span>;<span class="cstat-no" title="statement not covered" ></span>return jt.Wi.read(i,!0),<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >(0,jt.Pn)(i)}</span></span>(i,250),us.hasAnimatedSinceResize&amp;&amp;(us.hasAnimatedSinceResize=!1,this.nodes.forEach(Js))}</span>))}<span class="cstat-no" title="statement not covered" ></span>s</span>&amp;&amp;this.root.registerSharedNode(s,this),!1!==this.options.animate&amp;&amp;r&amp;&amp;(s||o)&amp;&amp;this.addEventListener("didUpdate",(<span class="fstat-no" title="function not covered" >({</span>delta:t,hasLayoutChanged:e,hasRelativeTargetChanged:n,layout:i})=&gt;{<span class="cstat-no" title="statement not covered" >if(this.isTreeAnimationBlocked())<span class="cstat-no" title="statement not covered" >return this.target=void 0,void(this.relativeTarget=void 0);c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this.options.transition||r.getDefaultTransition()||ro,</span>{onLayoutAnimationStart:o,onLayoutAnimationComplete:a}=<span class="cstat-no" title="statement not covered" >r.getProps(),</span>l=<span class="cstat-no" title="statement not covered" >!this.targetLayout||!Ls(this.targetLayout,i)||n,</span>u=<span class="cstat-no" title="statement not covered" >!e&amp;&amp;n;<span class="cstat-no" title="statement not covered" ></span>if(this.options.layoutRoot||this.resumeFrom&amp;&amp;this.resumeFrom.instance||u||e&amp;&amp;(l||!this.currentAnimation)){<span class="cstat-no" title="statement not covered" >this.resumeFrom&amp;&amp;(this.resumingFrom=this.resumeFrom,this.resumingFrom.resumingFrom=void 0),this.setAnimationOrigin(t,u);c</span>onst e=<span class="cstat-no" title="statement not covered" >{...Zn(s,"layout"),onPlay:o,onComplete:a};<span class="cstat-no" title="statement not covered" ></span>(r.shouldReduceMotion||this.options.layoutRoot)&amp;&amp;(e.delay=0,e.type=!1),this.startAnimation(e)}</span>else <span class="cstat-no" title="statement not covered" >e||Js(this),this.isLead()&amp;&amp;this.options.onExitComplete&amp;&amp;this.options.onExitComplete();<span class="cstat-no" title="statement not covered" >t</span></span>his.targetLayout=i}</span>))}<span class="fstat-no" title="function not covered" ></span>un</span>mount(){<span class="cstat-no" title="statement not covered" >this.options.layoutId&amp;&amp;this.willUpdate(),this.root.nodes.remove(this);c</span>onst t=<span class="cstat-no" title="statement not covered" >this.getStack();<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;t.remove(this),this.parent&amp;&amp;this.parent.children.delete(this),this.instance=void 0,(0,jt.Pn)(this.updateProjection)}<span class="fstat-no" title="function not covered" ></span>bl</span>ockUpdate(){<span class="cstat-no" title="statement not covered" >this.updateManuallyBlocked=!0}<span class="fstat-no" title="function not covered" ></span>un</span>blockUpdate(){<span class="cstat-no" title="statement not covered" >this.updateManuallyBlocked=!1}<span class="fstat-no" title="function not covered" ></span>is</span>UpdateBlocked(){<span class="cstat-no" title="statement not covered" >return this.updateManuallyBlocked||this.updateBlockedByResize}<span class="fstat-no" title="function not covered" ></span>is</span>TreeAnimationBlocked(){<span class="cstat-no" title="statement not covered" >return this.isAnimationBlocked||this.parent&amp;&amp;this.parent.isTreeAnimationBlocked()||!1}<span class="fstat-no" title="function not covered" ></span>st</span>artUpdate(){<span class="cstat-no" title="statement not covered" >this.isUpdateBlocked()||(this.isUpdating=!0,this.nodes&amp;&amp;this.nodes.forEach(eo),this.animationId++)}<span class="fstat-no" title="function not covered" ></span>ge</span>tTransformTemplate(){const{visualElement:t}=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;t.getProps().transformTemplate}<span class="fstat-no" title="function not covered" ></span>wi</span>llUpdate(t=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>{<span class="cstat-no" title="statement not covered" >if(this.root.hasTreeAnimated=!0,this.root.isUpdateBlocked())<span class="cstat-no" title="statement not covered" >return void(this.options.onExitComplete&amp;&amp;this.options.onExitComplete());<span class="cstat-no" title="statement not covered" >i</span></span>f(!this.root.isUpdating&amp;&amp;this.root.startUpdate(),this.isLayoutDirty)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.isLayoutDirty=!0;<span class="cstat-no" title="statement not covered" >f</span>or(let s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;this.path.length;s++){const t=<span class="cstat-no" title="statement not covered" >this.path[s];<span class="cstat-no" title="statement not covered" ></span>t.shouldResetTransform=!0,t.updateScroll("snapshot"),t.options.layoutRoot&amp;&amp;t.willUpdate(!1)}</span>c</span>onst{layoutId:e,layout:n}=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if(void 0===e&amp;&amp;!n)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >this.getTransformTemplate();<span class="cstat-no" title="statement not covered" ></span>this.prevTransformTemplateValue=i?i(this.latestValues,""):void 0,this.updateSnapshot(),t&amp;&amp;this.notifyListeners("willUpdate")}<span class="fstat-no" title="function not covered" ></span>up</span>date(){<span class="cstat-no" title="statement not covered" >this.updateScheduled=!1;<span class="cstat-no" title="statement not covered" >i</span>f(this.isUpdateBlocked())<span class="cstat-no" title="statement not covered" >return this.unblockUpdate(),this.clearAllSnapshots(),void this.nodes.forEach(qs);<span class="cstat-no" title="statement not covered" >t</span></span>his.isUpdating||this.nodes.forEach(Ks),this.isUpdating=!1,this.nodes.forEach(_s),this.nodes.forEach(Hs),this.nodes.forEach(zs),this.clearAllSnapshots();c</span>onst t=<span class="cstat-no" title="statement not covered" >performance.now();<span class="cstat-no" title="statement not covered" ></span>jt.frameData.delta=$(0,1e3/60,t-jt.frameData.timestamp),jt.frameData.timestamp=t,jt.frameData.isProcessing=!0,jt.S6.update.process(jt.frameData),jt.S6.preRender.process(jt.frameData),jt.S6.render.process(jt.frameData),jt.frameData.isProcessing=!1}<span class="fstat-no" title="function not covered" ></span>di</span>dUpdate(){<span class="cstat-no" title="statement not covered" >this.updateScheduled||(this.updateScheduled=!0,queueMicrotask((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.update())</span>))}<span class="fstat-no" title="function not covered" ></span>cl</span>earAllSnapshots(){<span class="cstat-no" title="statement not covered" >this.nodes.forEach(Gs),this.sharedNodes.forEach(no)}<span class="fstat-no" title="function not covered" ></span>sc</span>heduleUpdateProjection(){<span class="cstat-no" title="statement not covered" >this.projectionUpdateScheduled||(this.projectionUpdateScheduled=!0,jt.Wi.preRender(this.updateProjection,!1,!0))}<span class="fstat-no" title="function not covered" ></span>sc</span>heduleCheckAfterUnmount(){<span class="cstat-no" title="statement not covered" >jt.Wi.postRender((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.isLayoutDirty?this.root.didUpdate():this.root.checkUpdateFailed()}</span>))}<span class="fstat-no" title="function not covered" ></span>up</span>dateSnapshot(){<span class="cstat-no" title="statement not covered" >!this.snapshot&amp;&amp;this.instance&amp;&amp;(this.snapshot=this.measure())}<span class="fstat-no" title="function not covered" ></span>up</span>dateLayout(){<span class="cstat-no" title="statement not covered" >if(!this.instance)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(this.updateScroll(),(!this.options.alwaysMeasureLayout||!this.isLead())&amp;&amp;!this.isLayoutDirty)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(this.resumeFrom&amp;&amp;!this.resumeFrom.instance)<span class="cstat-no" title="statement not covered" >for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;this.path.length;n++){<span class="cstat-no" title="statement not covered" >this.path[n].updateScroll()}</span>c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this.layout;<span class="cstat-no" title="statement not covered" ></span>this.layout=this.measure(!1),this.layoutCorrected={x:{min:0,max:0},y:{min:0,max:0}},this.isLayoutDirty=!1,this.projectionDelta=void 0,this.notifyListeners("measure",this.layout.layoutBox);c</span>onst{visualElement:e}=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;e.notify("LayoutMeasure",this.layout.layoutBox,t?t.layoutBox:void 0)}<span class="fstat-no" title="function not covered" ></span>up</span>dateScroll(t=<span class="branch-0 cbranch-no" title="branch not covered" >"measure")</span>{let e=<span class="cstat-no" title="statement not covered" >Boolean(this.options.layoutScroll&amp;&amp;this.instance);<span class="cstat-no" title="statement not covered" ></span>this.scroll&amp;&amp;this.scroll.animationId===this.root.animationId&amp;&amp;this.scroll.phase===t&amp;&amp;(e=!1),e&amp;&amp;(this.scroll={animationId:this.root.animationId,phase:t,isRoot:i(this.instance),offset:n(this.instance)})}<span class="fstat-no" title="function not covered" ></span>re</span>setTransform(){<span class="cstat-no" title="statement not covered" >if(!s)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >this.isLayoutDirty||this.shouldResetTransform,</span>e=<span class="cstat-no" title="statement not covered" >this.projectionDelta&amp;&amp;!Rs(this.projectionDelta),</span>n=<span class="cstat-no" title="statement not covered" >this.getTransformTemplate(),</span>i=<span class="cstat-no" title="statement not covered" >n?n(this.latestValues,""):void 0,</span>o=<span class="cstat-no" title="statement not covered" >i!==this.prevTransformTemplateValue;<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(e||Hi(this.latestValues)||o)&amp;&amp;(s(this.instance,i),this.shouldResetTransform=!1,this.scheduleRender())}<span class="fstat-no" title="function not covered" ></span>me</span>asure(t=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>{const e=<span class="cstat-no" title="statement not covered" >this.measurePageBox();</span>let n=<span class="cstat-no" title="statement not covered" >this.removeElementScroll(e);</span>var i;<span class="cstat-no" title="statement not covered" >return t&amp;&amp;(n=this.removeTransform(n)),uo((i=n).x),uo(i.y),{animationId:this.root.animationId,measuredBox:e,layoutBox:n,latestValues:{},source:this.id}}<span class="fstat-no" title="function not covered" ></span>me</span>asurePageBox(){const{visualElement:t}=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if(!t)<span class="cstat-no" title="statement not covered" >return{x:{min:0,max:0},y:{min:0,max:0}};c</span></span>onst e=<span class="cstat-no" title="statement not covered" >t.measureViewportBox(),</span>{scroll:n}=<span class="cstat-no" title="statement not covered" >this.root;<span class="cstat-no" title="statement not covered" ></span>return n&amp;&amp;(Ji(e.x,n.offset.x),Ji(e.y,n.offset.y)),e}<span class="fstat-no" title="function not covered" ></span>re</span>moveElementScroll(t){const e=<span class="cstat-no" title="statement not covered" >{x:{min:0,max:0},y:{min:0,max:0}};<span class="cstat-no" title="statement not covered" ></span>As(e,t);<span class="cstat-no" title="statement not covered" >f</span>or(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;this.path.length;n++){const i=<span class="cstat-no" title="statement not covered" >this.path[n],</span>{scroll:s,options:o}=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>if(i!==this.root&amp;&amp;s&amp;&amp;o.layoutScroll){<span class="cstat-no" title="statement not covered" >if(s.isRoot){<span class="cstat-no" title="statement not covered" >As(e,t);c</span>onst{scroll:n}=<span class="cstat-no" title="statement not covered" >this.root;<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;(Ji(e.x,-n.offset.x),Ji(e.y,-n.offset.y))}<span class="cstat-no" title="statement not covered" ></span>J</span>i(e.x,s.offset.x),Ji(e.y,s.offset.y)}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}<span class="fstat-no" title="function not covered" ></span>ap</span>plyTransform(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{const n=<span class="cstat-no" title="statement not covered" >{x:{min:0,max:0},y:{min:0,max:0}};<span class="cstat-no" title="statement not covered" ></span>As(n,t);<span class="cstat-no" title="statement not covered" >f</span>or(let i=<span class="cstat-no" title="statement not covered" >0;</span>i&lt;this.path.length;i++){const t=<span class="cstat-no" title="statement not covered" >this.path[i];<span class="cstat-no" title="statement not covered" ></span>!e&amp;&amp;t.options.layoutScroll&amp;&amp;t.scroll&amp;&amp;t!==t.root&amp;&amp;ns(n,{x:-t.scroll.offset.x,y:-t.scroll.offset.y}),Hi(t.latestValues)&amp;&amp;ns(n,t.latestValues)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Hi(this.latestValues)&amp;&amp;ns(n,this.latestValues),n}<span class="fstat-no" title="function not covered" ></span>re</span>moveTransform(t){const e=<span class="cstat-no" title="statement not covered" >{x:{min:0,max:0},y:{min:0,max:0}};<span class="cstat-no" title="statement not covered" ></span>As(e,t);<span class="cstat-no" title="statement not covered" >f</span>or(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;this.path.length;n++){const t=<span class="cstat-no" title="statement not covered" >this.path[n];<span class="cstat-no" title="statement not covered" ></span>if(!t.instance)<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >i</span></span>f(!Hi(t.latestValues))<span class="cstat-no" title="statement not covered" >continue;<span class="cstat-no" title="statement not covered" >Z</span></span>i(t.latestValues)&amp;&amp;t.updateSnapshot();c</span>onst i=<span class="cstat-no" title="statement not covered" >{x:{min:0,max:0},y:{min:0,max:0}};<span class="cstat-no" title="statement not covered" ></span>As(i,t.measurePageBox()),Ms(e,t.latestValues,t.snapshot?t.snapshot.layoutBox:void 0,i)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn Hi(this.latestValues)&amp;&amp;Ms(e,this.latestValues),e}<span class="fstat-no" title="function not covered" ></span>se</span>tTargetDelta(t){<span class="cstat-no" title="statement not covered" >this.targetDelta=t,this.root.scheduleUpdateProjection(),this.isProjectionDirty=!0}<span class="fstat-no" title="function not covered" ></span>se</span>tOptions(t){<span class="cstat-no" title="statement not covered" >this.options={...this.options,...t,crossfade:void 0===t.crossfade||t.crossfade}}<span class="fstat-no" title="function not covered" ></span>cl</span>earMeasurements(){<span class="cstat-no" title="statement not covered" >this.scroll=void 0,this.layout=void 0,this.snapshot=void 0,this.prevTransformTemplateValue=void 0,this.targetDelta=void 0,this.target=void 0,this.isLayoutDirty=!1}<span class="fstat-no" title="function not covered" ></span>fo</span>rceRelativeParentToResolveTarget(){<span class="cstat-no" title="statement not covered" >this.relativeParent&amp;&amp;this.relativeParent.resolvedRelativeTargetAt!==jt.frameData.timestamp&amp;&amp;this.relativeParent.resolveTargetDelta(!0)}<span class="fstat-no" title="function not covered" ></span>re</span>solveTargetDelta(t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{var e;const n=<span class="cstat-no" title="statement not covered" >this.getLead();<span class="cstat-no" title="statement not covered" ></span>this.isProjectionDirty||(this.isProjectionDirty=n.isProjectionDirty),this.isTransformDirty||(this.isTransformDirty=n.isTransformDirty),this.isSharedProjectionDirty||(this.isSharedProjectionDirty=n.isSharedProjectionDirty);c</span>onst i=<span class="cstat-no" title="statement not covered" >Boolean(this.resumingFrom)||this!==n;<span class="cstat-no" title="statement not covered" ></span>if(!(t||i&amp;&amp;this.isSharedProjectionDirty||this.isProjectionDirty||(null===(e=this.parent)||void 0===e?void 0:e.isProjectionDirty)||this.attemptToResolveRelativeTarget))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{layout:s,layoutId:o}=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if(this.layout&amp;&amp;(s||o)){<span class="cstat-no" title="statement not covered" >if(this.resolvedRelativeTargetAt=jt.frameData.timestamp,!this.targetDelta&amp;&amp;!this.relativeTarget){const t=<span class="cstat-no" title="statement not covered" >this.getClosestProjectingParent();<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;t.layout&amp;&amp;1!==this.animationProgress?(this.relativeParent=t,this.forceRelativeParentToResolveTarget(),this.relativeTarget={x:{min:0,max:0},y:{min:0,max:0}},this.relativeTargetOrigin={x:{min:0,max:0},y:{min:0,max:0}},ji(this.relativeTargetOrigin,this.layout.layoutBox,t.layout.layoutBox),As(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}<span class="cstat-no" title="statement not covered" ></span>i</span>f(this.relativeTarget||this.targetDelta){var r,a,l;<span class="cstat-no" title="statement not covered" >if(this.target||(this.target={x:{min:0,max:0},y:{min:0,max:0}},this.targetWithTransforms={x:{min:0,max:0},y:{min:0,max:0}}),this.relativeTarget&amp;&amp;this.relativeTargetOrigin&amp;&amp;this.relativeParent&amp;&amp;this.relativeParent.target?(this.forceRelativeParentToResolveTarget(),r=this.target,a=this.relativeTarget,l=this.relativeParent.target,Ri(r.x,a.x,l.x),Ri(r.y,a.y,l.y)):this.targetDelta?(Boolean(this.resumingFrom)?this.target=this.applyTransform(this.layout.layoutBox):As(this.target,this.layout.layoutBox),Ki(this.target,this.targetDelta)):As(this.target,this.layout.layoutBox),this.attemptToResolveRelativeTarget){<span class="cstat-no" title="statement not covered" >this.attemptToResolveRelativeTarget=!1;c</span>onst t=<span class="cstat-no" title="statement not covered" >this.getClosestProjectingParent();<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;Boolean(t.resumingFrom)===Boolean(this.resumingFrom)&amp;&amp;!t.options.layoutScroll&amp;&amp;t.target&amp;&amp;1!==this.animationProgress?(this.relativeParent=t,this.forceRelativeParentToResolveTarget(),this.relativeTarget={x:{min:0,max:0},y:{min:0,max:0}},this.relativeTargetOrigin={x:{min:0,max:0},y:{min:0,max:0}},ji(this.relativeTargetOrigin,this.target,t.target),As(this.relativeTarget,this.relativeTargetOrigin)):this.relativeParent=this.relativeTarget=void 0}<span class="cstat-no" title="statement not covered" ></span>$</span>s.resolvedTargetDeltas++}</span>}</span>}<span class="fstat-no" title="function not covered" ></span>ge</span>tClosestProjectingParent(){<span class="cstat-no" title="statement not covered" >if(this.parent&amp;&amp;!Zi(this.parent.latestValues)&amp;&amp;!zi(this.parent.latestValues))<span class="cstat-no" title="statement not covered" >return this.parent.isProjecting()?this.parent:this.parent.getClosestProjectingParent()}<span class="fstat-no" title="function not covered" ></span></span>is</span>Projecting(){<span class="cstat-no" title="statement not covered" >return Boolean((this.relativeTarget||this.targetDelta||this.options.layoutRoot)&amp;&amp;this.layout)}<span class="fstat-no" title="function not covered" ></span>ca</span>lcProjection(){var t;const e=<span class="cstat-no" title="statement not covered" >this.getLead(),</span>n=<span class="cstat-no" title="statement not covered" >Boolean(this.resumingFrom)||this!==e;</span>let i=<span class="cstat-no" title="statement not covered" >!0;<span class="cstat-no" title="statement not covered" ></span>if((this.isProjectionDirty||(null===(t=this.parent)||void 0===t?void 0:t.isProjectionDirty))&amp;&amp;(i=!1),n&amp;&amp;(this.isSharedProjectionDirty||this.isTransformDirty)&amp;&amp;(i=!1),this.resolvedRelativeTargetAt===jt.frameData.timestamp&amp;&amp;(i=!1),i)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{layout:s,layoutId:o}=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if(this.isTreeAnimating=Boolean(this.parent&amp;&amp;this.parent.isTreeAnimating||this.currentAnimation||this.pendingAnimation),this.isTreeAnimating||(this.targetDelta=this.relativeTarget=void 0),!this.layout||!s&amp;&amp;!o)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >A</span></span>s(this.layoutCorrected,this.layout.layoutBox);c</span>onst r=<span class="cstat-no" title="statement not covered" >this.treeScale.x,</span>a=<span class="cstat-no" title="statement not covered" >this.treeScale.y;<span class="cstat-no" title="statement not covered" ></span>!<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,i=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{const s=<span class="cstat-no" title="statement not covered" >n.length;<span class="cstat-no" title="statement not covered" ></span>if(!s)<span class="cstat-no" title="statement not covered" >return;l</span></span>et o,r;<span class="cstat-no" title="statement not covered" >e.x=e.y=1;<span class="cstat-no" title="statement not covered" >f</span>or(let a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;s;a++){<span class="cstat-no" title="statement not covered" >o=n[a],r=o.projectionDelta;c</span>onst s=<span class="cstat-no" title="statement not covered" >o.instance;<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;s.style&amp;&amp;"contents"===s.style.display||(i&amp;&amp;o.options.layoutScroll&amp;&amp;o.scroll&amp;&amp;o!==o.root&amp;&amp;ns(t,{x:-o.scroll.offset.x,y:-o.scroll.offset.y}),r&amp;&amp;(e.x*=r.x.scale,e.y*=r.y.scale,Ki(t,r)),i&amp;&amp;Hi(o.latestValues)&amp;&amp;ns(t,o.latestValues))}<span class="cstat-no" title="statement not covered" ></span>e</span>.x=_i(e.x),e.y=_i(e.y)}</span>(this.layoutCorrected,this.treeScale,this.path,n),!e.layout||e.target||1===this.treeScale.x&amp;&amp;1===this.treeScale.y||(e.target=e.layout.layoutBox);c</span>onst{target:l}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>if(!l)<span class="cstat-no" title="statement not covered" >return void(this.projectionTransform&amp;&amp;(this.projectionDelta={x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}},this.projectionTransform="none",this.scheduleRender()));<span class="cstat-no" title="statement not covered" >t</span></span>his.projectionDelta||(this.projectionDelta={x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}},this.projectionDeltaWithTransform={x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}});c</span>onst u=<span class="cstat-no" title="statement not covered" >this.projectionTransform;<span class="cstat-no" title="statement not covered" ></span>ki(this.projectionDelta,this.layoutCorrected,l,this.latestValues),this.projectionTransform=Fs(this.projectionDelta,this.treeScale),this.projectionTransform===u&amp;&amp;this.treeScale.x===r&amp;&amp;this.treeScale.y===a||(this.hasProjected=!0,this.scheduleRender(),this.notifyListeners("projectionUpdate",l)),$s.recalculatedProjection++}<span class="fstat-no" title="function not covered" ></span>hi</span>de(){<span class="cstat-no" title="statement not covered" >this.isVisible=!1}<span class="fstat-no" title="function not covered" ></span>sh</span>ow(){<span class="cstat-no" title="statement not covered" >this.isVisible=!0}<span class="fstat-no" title="function not covered" ></span>sc</span>heduleRender(t=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>{<span class="cstat-no" title="statement not covered" >if(this.options.scheduleRender&amp;&amp;this.options.scheduleRender(),t){const t=<span class="cstat-no" title="statement not covered" >this.getStack();<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;t.scheduleRender()}<span class="cstat-no" title="statement not covered" ></span>t</span>his.resumingFrom&amp;&amp;!this.resumingFrom.instance&amp;&amp;(this.resumingFrom=void 0)}<span class="fstat-no" title="function not covered" ></span>se</span>tAnimationOrigin(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{const n=<span class="cstat-no" title="statement not covered" >this.snapshot,</span>i=<span class="cstat-no" title="statement not covered" >n?n.latestValues:{},</span>s=<span class="cstat-no" title="statement not covered" >{...this.latestValues},</span>o=<span class="cstat-no" title="statement not covered" >{x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}};<span class="cstat-no" title="statement not covered" ></span>this.relativeParent&amp;&amp;this.relativeParent.options.layoutRoot||(this.relativeTarget=this.relativeTargetOrigin=void 0),this.attemptToResolveRelativeTarget=!e;c</span>onst r=<span class="cstat-no" title="statement not covered" >{x:{min:0,max:0},y:{min:0,max:0}},</span>a=<span class="cstat-no" title="statement not covered" >(n?n.source:void 0)!==(this.layout?this.layout.source:void 0),</span>l=<span class="cstat-no" title="statement not covered" >this.getStack(),</span>u=<span class="cstat-no" title="statement not covered" >!l||l.members.length&lt;=1,</span>c=<span class="cstat-no" title="statement not covered" >Boolean(a&amp;&amp;!u&amp;&amp;!0===this.options.crossfade&amp;&amp;!this.path.some(oo));</span>let h;<span class="cstat-no" title="statement not covered" >this.animationProgress=0,this.mixTargetDelta=<span class="fstat-no" title="function not covered" >e=</span>&gt;{const n=<span class="cstat-no" title="statement not covered" >e/1e3;</span>var l,d,p,m,f,g;<span class="cstat-no" title="statement not covered" >io(o.x,t.x,n),io(o.y,t.y,n),this.setTargetDelta(o),this.relativeTarget&amp;&amp;this.relativeTargetOrigin&amp;&amp;this.layout&amp;&amp;this.relativeParent&amp;&amp;this.relativeParent.layout&amp;&amp;(ji(r,this.layout.layoutBox,this.relativeParent.layout.layoutBox),p=this.relativeTarget,m=this.relativeTargetOrigin,f=r,g=n,so(p.x,m.x,f.x,g),so(p.y,m.y,f.y,g),h&amp;&amp;(l=this.relativeTarget,d=h,l.x.min===d.x.min&amp;&amp;l.x.max===d.x.max&amp;&amp;l.y.min===d.y.min&amp;&amp;l.y.max===d.y.max)&amp;&amp;(this.isProjectionDirty=!1),h||(h={x:{min:0,max:0},y:{min:0,max:0}}),As(h,this.relativeTarget)),a&amp;&amp;(this.animationValues=s,<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n,i,s,o){<span class="cstat-no" title="statement not covered" >s?(t.opacity=Ue(0,void 0!==n.opacity?n.opacity:1,bs(i)),t.opacityExit=Ue(void 0!==e.opacity?e.opacity:1,0,Ts(i))):o&amp;&amp;(t.opacity=Ue(void 0!==e.opacity?e.opacity:1,void 0!==n.opacity?n.opacity:1,i));<span class="cstat-no" title="statement not covered" >f</span>or(let r=<span class="cstat-no" title="statement not covered" >0;</span>r&lt;ys;r++){const s=<span class="cstat-no" title="statement not covered" >`border${gs[r]}Radius`;</span>let o=<span class="cstat-no" title="statement not covered" >Ps(e,s),</span>a=<span class="cstat-no" title="statement not covered" >Ps(n,s);<span class="cstat-no" title="statement not covered" ></span>void 0===o&amp;&amp;void 0===a||(o||(o=0),a||(a=0),0===o||0===a||xs(o)===xs(a)?(t[s]=Math.max(Ue(vs(o),vs(a),i),0),(Q.test(a)||Q.test(o))&amp;&amp;(t[s]+="%")):t[s]=a)}<span class="cstat-no" title="statement not covered" ></span>(</span>e.rotate||n.rotate)&amp;&amp;(t.rotate=Ue(e.rotate||0,n.rotate||0,i))}</span>(s,i,this.latestValues,n,c,u)),this.root.scheduleUpdateProjection(),this.scheduleRender(),this.animationProgress=n}</span>,this.mixTargetDelta(this.options.layoutRoot?1e3:0)}<span class="fstat-no" title="function not covered" ></span>st</span>artAnimation(t){<span class="cstat-no" title="statement not covered" >this.notifyListeners("animationStart"),this.currentAnimation&amp;&amp;this.currentAnimation.stop(),this.resumingFrom&amp;&amp;this.resumingFrom.currentAnimation&amp;&amp;this.resumingFrom.currentAnimation.stop(),this.pendingAnimation&amp;&amp;((0,jt.Pn)(this.pendingAnimation),this.pendingAnimation=void 0),this.pendingAnimation=jt.Wi.update((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >us.hasAnimatedSinceResize=!0,this.currentAnimation=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){const i=<span class="cstat-no" title="statement not covered" >B(t)?t:Qn(t);<span class="cstat-no" title="statement not covered" ></span>return i.start(zn("",i,e,n)),i.animation}</span>(0,1e3,{...t,onUpdate:<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.mixTargetDelta(e),t.onUpdate&amp;&amp;t.onUpdate(e)}</span>,onComplete:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.onComplete&amp;&amp;t.onComplete(),this.completeAnimation()}</span>}),this.resumingFrom&amp;&amp;(this.resumingFrom.currentAnimation=this.currentAnimation),this.pendingAnimation=void 0}</span>))}<span class="fstat-no" title="function not covered" ></span>co</span>mpleteAnimation(){<span class="cstat-no" title="statement not covered" >this.resumingFrom&amp;&amp;(this.resumingFrom.currentAnimation=void 0,this.resumingFrom.preserveOpacity=void 0);c</span>onst t=<span class="cstat-no" title="statement not covered" >this.getStack();<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;t.exitAnimationComplete(),this.resumingFrom=this.currentAnimation=this.animationValues=void 0,this.notifyListeners("animationComplete")}<span class="fstat-no" title="function not covered" ></span>fi</span>nishAnimation(){<span class="cstat-no" title="statement not covered" >this.currentAnimation&amp;&amp;(this.mixTargetDelta&amp;&amp;this.mixTargetDelta(1e3),this.currentAnimation.stop()),this.completeAnimation()}<span class="fstat-no" title="function not covered" ></span>ap</span>plyTransformsToTarget(){const t=<span class="cstat-no" title="statement not covered" >this.getLead();</span>let{targetWithTransforms:e,target:n,layout:i,latestValues:s}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if(e&amp;&amp;n&amp;&amp;i){<span class="cstat-no" title="statement not covered" >if(this!==t&amp;&amp;this.layout&amp;&amp;i&amp;&amp;co(this.options.animationType,this.layout.layoutBox,i.layoutBox)){<span class="cstat-no" title="statement not covered" >n=this.target||{x:{min:0,max:0},y:{min:0,max:0}};c</span>onst e=<span class="cstat-no" title="statement not covered" >Ci(this.layout.layoutBox.x);<span class="cstat-no" title="statement not covered" ></span>n.x.min=t.target.x.min,n.x.max=n.x.min+e;c</span>onst i=<span class="cstat-no" title="statement not covered" >Ci(this.layout.layoutBox.y);<span class="cstat-no" title="statement not covered" ></span>n.y.min=t.target.y.min,n.y.max=n.y.min+i}<span class="cstat-no" title="statement not covered" ></span>A</span>s(e,n),ns(e,s),ki(this.projectionDeltaWithTransform,this.layoutCorrected,e,s)}</span>}<span class="fstat-no" title="function not covered" ></span>re</span>gisterSharedNode(t,e){<span class="cstat-no" title="statement not covered" >this.sharedNodes.has(t)||this.sharedNodes.set(t,new Bs);<span class="cstat-no" title="statement not covered" >t</span>his.sharedNodes.get(t).add(e);c</span>onst n=<span class="cstat-no" title="statement not covered" >e.options.initialPromotionConfig;<span class="cstat-no" title="statement not covered" ></span>e.promote({transition:n?n.transition:void 0,preserveFollowOpacity:n&amp;&amp;n.shouldPreserveFollowOpacity?n.shouldPreserveFollowOpacity(e):void 0})}<span class="fstat-no" title="function not covered" ></span>is</span>Lead(){const t=<span class="cstat-no" title="statement not covered" >this.getStack();<span class="cstat-no" title="statement not covered" ></span>return!t||t.lead===this}<span class="fstat-no" title="function not covered" ></span>ge</span>tLead(){var t;const{layoutId:e}=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>return e&amp;&amp;(null===(t=this.getStack())||void 0===t?void 0:t.lead)||this}<span class="fstat-no" title="function not covered" ></span>ge</span>tPrevLead(){var t;const{layoutId:e}=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>return e?null===(t=this.getStack())||void 0===t?void 0:t.prevLead:void 0}<span class="fstat-no" title="function not covered" ></span>ge</span>tStack(){const{layoutId:t}=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if(t)<span class="cstat-no" title="statement not covered" >return this.root.sharedNodes.get(t)}<span class="fstat-no" title="function not covered" ></span></span>pr</span>omote({needsReset:t,transition:e,preserveFollowOpacity:n}=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{const i=<span class="cstat-no" title="statement not covered" >this.getStack();<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;i.promote(this,n),t&amp;&amp;(this.projectionDelta=void 0,this.needsReset=!0),e&amp;&amp;this.setOptions({transition:e})}<span class="fstat-no" title="function not covered" ></span>re</span>legate(){const t=<span class="cstat-no" title="statement not covered" >this.getStack();<span class="cstat-no" title="statement not covered" ></span>return!!t&amp;&amp;t.relegate(this)}<span class="fstat-no" title="function not covered" ></span>re</span>setRotation(){const{visualElement:t}=<span class="cstat-no" title="statement not covered" >this.options;<span class="cstat-no" title="statement not covered" ></span>if(!t)<span class="cstat-no" title="statement not covered" >return;l</span></span>et e=<span class="cstat-no" title="statement not covered" >!1;</span>const{latestValues:n}=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>if((n.rotate||n.rotateX||n.rotateY||n.rotateZ)&amp;&amp;(e=!0),!e)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;Us.length;s++){const e=<span class="cstat-no" title="statement not covered" >"rotate"+Us[s];<span class="cstat-no" title="statement not covered" ></span>n[e]&amp;&amp;(i[e]=n[e],t.setStaticValue(e,0))}<span class="cstat-no" title="statement not covered" ></span>t</span>.render();<span class="cstat-no" title="statement not covered" >f</span>or(const s in i)<span class="cstat-no" title="statement not covered" >t.setStaticValue(s,i[s]);<span class="cstat-no" title="statement not covered" >t</span></span>.scheduleRender()}<span class="fstat-no" title="function not covered" ></span>ge</span>tProjectionStyles(t){var e,n;<span class="cstat-no" title="statement not covered" >if(!this.instance||this.isSVG)<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >i</span></span>f(!this.isVisible)<span class="cstat-no" title="statement not covered" >return Ws;c</span></span>onst i=<span class="cstat-no" title="statement not covered" >{visibility:""},</span>s=<span class="cstat-no" title="statement not covered" >this.getTransformTemplate();<span class="cstat-no" title="statement not covered" ></span>if(this.needsReset)<span class="cstat-no" title="statement not covered" >return this.needsReset=!1,i.opacity="",i.pointerEvents=kt(null===t||void 0===t?void 0:t.pointerEvents)||"",i.transform=s?s(this.latestValues,""):"none",i;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >this.getLead();<span class="cstat-no" title="statement not covered" ></span>if(!this.projectionDelta||!this.layout||!o.target){const e=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>return this.options.layoutId&amp;&amp;(e.opacity=void 0!==this.latestValues.opacity?this.latestValues.opacity:1,e.pointerEvents=kt(null===t||void 0===t?void 0:t.pointerEvents)||""),this.hasProjected&amp;&amp;!Hi(this.latestValues)&amp;&amp;(e.transform=s?s({},""):"none",this.hasProjected=!1),e}</span>c</span>onst r=<span class="cstat-no" title="statement not covered" >o.animationValues||o.latestValues;<span class="cstat-no" title="statement not covered" ></span>this.applyTransformsToTarget(),i.transform=Fs(this.projectionDeltaWithTransform,this.treeScale,r),s&amp;&amp;(i.transform=s(r,i.transform));c</span>onst{x:a,y:l}=<span class="cstat-no" title="statement not covered" >this.projectionDelta;<span class="cstat-no" title="statement not covered" ></span>i.transformOrigin=`${100*a.origin}% ${100*l.origin}% 0`,o.animationValues?i.opacity=o===this?null!==(n=null!==(e=r.opacity)&amp;&amp;void 0!==e?e:this.latestValues.opacity)&amp;&amp;void 0!==n?n:1:this.preserveOpacity?this.latestValues.opacity:r.opacityExit:i.opacity=o===this?void 0!==r.opacity?r.opacity:"":void 0!==r.opacityExit?r.opacityExit:0;<span class="cstat-no" title="statement not covered" >f</span>or(const u in k){<span class="cstat-no" title="statement not covered" >if(void 0===r[u])<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst{correct:t,applyTo:e}=<span class="cstat-no" title="statement not covered" >k[u],</span>n=<span class="cstat-no" title="statement not covered" >"none"===i.transform?r[u]:t(r[u],o);<span class="cstat-no" title="statement not covered" ></span>if(e){const t=<span class="cstat-no" title="statement not covered" >e.length;<span class="cstat-no" title="statement not covered" ></span>for(let s=<span class="cstat-no" title="statement not covered" >0;</span>s&lt;t;s++)<span class="cstat-no" title="statement not covered" >i[e[s]]=n}</span></span>else <span class="cstat-no" title="statement not covered" >i[u]=n}<span class="cstat-no" title="statement not covered" ></span></span>r</span>eturn this.options.layoutId&amp;&amp;(i.pointerEvents=o===this?kt(null===t||void 0===t?void 0:t.pointerEvents)||"":"none"),i}<span class="fstat-no" title="function not covered" ></span>cl</span>earSnapshot(){<span class="cstat-no" title="statement not covered" >this.resumeFrom=this.snapshot=void 0}<span class="fstat-no" title="function not covered" ></span>re</span>setTree(){<span class="cstat-no" title="statement not covered" >this.root.nodes.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{var e;<span class="cstat-no" title="statement not covered" >return null===(e=t.currentAnimation)||void 0===e?void 0:e.stop()}</span>)),this.root.nodes.forEach(qs),this.root.sharedNodes.clear()}</span>}}</span>function <span class="fstat-no" title="function not covered" >Hs(</span>t){<span class="cstat-no" title="statement not covered" >t.updateLayout()}</span>function <span class="fstat-no" title="function not covered" >zs(</span>t){var e;const n=<span class="cstat-no" title="statement not covered" >(null===(e=t.resumeFrom)||void 0===e?void 0:e.snapshot)||t.snapshot;<span class="cstat-no" title="statement not covered" ></span>if(t.isLead()&amp;&amp;t.layout&amp;&amp;n&amp;&amp;t.hasListeners("didUpdate")){const{layoutBox:e,measuredBox:i}=<span class="cstat-no" title="statement not covered" >t.layout,</span>{animationType:s}=<span class="cstat-no" title="statement not covered" >t.options,</span>o=<span class="cstat-no" title="statement not covered" >n.source!==t.layout.source;<span class="cstat-no" title="statement not covered" ></span>"size"===s?Wi((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >o?n.measuredBox[t]:n.layoutBox[t],</span>s=<span class="cstat-no" title="statement not covered" >Ci(i);<span class="cstat-no" title="statement not covered" ></span>i.min=e[t].min,i.max=i.min+s}</span>)):co(s,n.layoutBox,e)&amp;&amp;Wi((<span class="fstat-no" title="function not covered" >i=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >o?n.measuredBox[i]:n.layoutBox[i],</span>r=<span class="cstat-no" title="statement not covered" >Ci(e[i]);<span class="cstat-no" title="statement not covered" ></span>s.max=s.min+r,t.relativeTarget&amp;&amp;!t.currentAnimation&amp;&amp;(t.isProjectionDirty=!0,t.relativeTarget[i].max=t.relativeTarget[i].min+r)}</span>));c</span>onst r=<span class="cstat-no" title="statement not covered" >{x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}};<span class="cstat-no" title="statement not covered" ></span>ki(r,e,n.layoutBox);c</span>onst a=<span class="cstat-no" title="statement not covered" >{x:{translate:0,scale:1,origin:0,originPoint:0},y:{translate:0,scale:1,origin:0,originPoint:0}};<span class="cstat-no" title="statement not covered" ></span>o?ki(a,t.applyTransform(i,!0),n.measuredBox):ki(a,e,n.layoutBox);c</span>onst l=<span class="cstat-no" title="statement not covered" >!Rs(r);</span>let u=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if(!t.resumeFrom){const i=<span class="cstat-no" title="statement not covered" >t.getClosestProjectingParent();<span class="cstat-no" title="statement not covered" ></span>if(i&amp;&amp;!i.resumeFrom){const{snapshot:s,layout:o}=<span class="cstat-no" title="statement not covered" >i;<span class="cstat-no" title="statement not covered" ></span>if(s&amp;&amp;o){const r=<span class="cstat-no" title="statement not covered" >{x:{min:0,max:0},y:{min:0,max:0}};<span class="cstat-no" title="statement not covered" ></span>ji(r,n.layoutBox,s.layoutBox);c</span>onst a=<span class="cstat-no" title="statement not covered" >{x:{min:0,max:0},y:{min:0,max:0}};<span class="cstat-no" title="statement not covered" ></span>ji(a,e,o.layoutBox),Ls(r,a)||(u=!0),i.options.layoutRoot&amp;&amp;(t.relativeTarget=a,t.relativeTargetOrigin=r,t.relativeParent=i)}</span>}</span>}<span class="cstat-no" title="statement not covered" ></span>t</span>.notifyListeners("didUpdate",{layout:e,snapshot:n,delta:a,layoutDelta:r,hasLayoutChanged:l,hasRelativeTargetChanged:u})}</span>else <span class="cstat-no" title="statement not covered" >if(t.isLead()){const{onExitComplete:e}=<span class="cstat-no" title="statement not covered" >t.options;<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;e()}<span class="cstat-no" title="statement not covered" ></span>t</span></span>.options.transition=void 0}</span>function <span class="fstat-no" title="function not covered" >Ys(</span>t){<span class="cstat-no" title="statement not covered" >$s.totalNodes++,t.parent&amp;&amp;(t.isProjecting()||(t.isProjectionDirty=t.parent.isProjectionDirty),t.isSharedProjectionDirty||(t.isSharedProjectionDirty=Boolean(t.isProjectionDirty||t.parent.isProjectionDirty||t.parent.isSharedProjectionDirty)),t.isTransformDirty||(t.isTransformDirty=t.parent.isTransformDirty))}</span>function <span class="fstat-no" title="function not covered" >Xs(</span>t){<span class="cstat-no" title="statement not covered" >t.isProjectionDirty=t.isSharedProjectionDirty=t.isTransformDirty=!1}</span>function <span class="fstat-no" title="function not covered" >Gs(</span>t){<span class="cstat-no" title="statement not covered" >t.clearSnapshot()}</span>function <span class="fstat-no" title="function not covered" >qs(</span>t){<span class="cstat-no" title="statement not covered" >t.clearMeasurements()}</span>function <span class="fstat-no" title="function not covered" >Ks(</span>t){<span class="cstat-no" title="statement not covered" >t.isLayoutDirty=!1}</span>function <span class="fstat-no" title="function not covered" >_s(</span>t){const{visualElement:e}=<span class="cstat-no" title="statement not covered" >t.options;<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;e.getProps().onBeforeLayoutMeasure&amp;&amp;e.notify("BeforeLayoutMeasure"),t.resetTransform()}</span>function <span class="fstat-no" title="function not covered" >Js(</span>t){<span class="cstat-no" title="statement not covered" >t.finishAnimation(),t.targetDelta=t.relativeTarget=t.target=void 0,t.isProjectionDirty=!0}</span>function <span class="fstat-no" title="function not covered" >Qs(</span>t){<span class="cstat-no" title="statement not covered" >t.resolveTargetDelta()}</span>function <span class="fstat-no" title="function not covered" >to(</span>t){<span class="cstat-no" title="statement not covered" >t.calcProjection()}</span>function <span class="fstat-no" title="function not covered" >eo(</span>t){<span class="cstat-no" title="statement not covered" >t.resetRotation()}</span>function <span class="fstat-no" title="function not covered" >no(</span>t){<span class="cstat-no" title="statement not covered" >t.removeLeadSnapshot()}</span>function <span class="fstat-no" title="function not covered" >io(</span>t,e,n){<span class="cstat-no" title="statement not covered" >t.translate=Ue(e.translate,0,n),t.scale=Ue(e.scale,1,n),t.origin=e.origin,t.originPoint=e.originPoint}</span>function <span class="fstat-no" title="function not covered" >so(</span>t,e,n,i){<span class="cstat-no" title="statement not covered" >t.min=Ue(e.min,n.min,i),t.max=Ue(e.max,n.max,i)}</span>function <span class="fstat-no" title="function not covered" >oo(</span>t){<span class="cstat-no" title="statement not covered" >return t.animationValues&amp;&amp;void 0!==t.animationValues.opacityExit}</span>const ro=<span class="cstat-no" title="statement not covered" >{duration:.45,ease:[.4,0,.1,1]},</span>ao=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >"undefined"!==typeof navigator&amp;&amp;navigator.userAgent.toLowerCase().includes(t),</span></span>lo=<span class="cstat-no" title="statement not covered" >ao("applewebkit/")&amp;&amp;!ao("chrome/")?Math.round:_t.Z;</span>function <span class="fstat-no" title="function not covered" >uo(</span>t){<span class="cstat-no" title="statement not covered" >t.min=lo(t.min),t.max=lo(t.max)}</span>function <span class="fstat-no" title="function not covered" >co(</span>t,e,n){<span class="cstat-no" title="statement not covered" >return"position"===t||"preserve-aspect"===t&amp;&amp;!Di(js(e),js(n),.2)}</span>const ho=<span class="cstat-no" title="statement not covered" >Zs({attachResizeListener:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >Ot(t,"resize",e),</span>measureScroll:<span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >{x:document.documentElement.scrollLeft||document.body.scrollLeft,y:document.documentElement.scrollTop||document.body.scrollTop})</span>,checkIsScrollRoot:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >!0}</span>),</span>po=<span class="cstat-no" title="statement not covered" >{current:void 0},</span>mo=<span class="cstat-no" title="statement not covered" >Zs({measureScroll:<span class="fstat-no" title="function not covered" >t=</span>&gt;(<span class="cstat-no" title="statement not covered" >{x:t.scrollLeft,y:t.scrollTop})</span>,defaultParent:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(!po.current){const t=<span class="cstat-no" title="statement not covered" >new ho({});<span class="cstat-no" title="statement not covered" ></span>t.mount(window),t.setOptions({layoutScroll:!0}),po.current=t}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn po.current}</span>,resetTransform:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >t.style.transform=void 0!==e?e:"none"}</span>,checkIsScrollRoot:<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Boolean("fixed"===window.getComputedStyle(t).position)}</span>),</span>fo=<span class="cstat-no" title="statement not covered" >{pan:{Feature:class extends Gt{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(...arguments),this.removePointerDownListener=_t.Z}<span class="fstat-no" title="function not covered" ></span>on</span>PointerDown(t){<span class="cstat-no" title="statement not covered" >this.session=new bi(t,this.createPanHandlers(),{transformPagePoint:this.node.getTransformPagePoint(),contextWindow:ss(this.node)})}<span class="fstat-no" title="function not covered" ></span>cr</span>eatePanHandlers(){const{onPanSessionStart:t,onPanStart:e,onPan:n,onPanEnd:i}=<span class="cstat-no" title="statement not covered" >this.node.getProps();<span class="cstat-no" title="statement not covered" ></span>return{onSessionStart:ls(t),onStart:ls(e),onMove:n,onEnd:<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >delete this.session,i&amp;&amp;jt.Wi.update((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >i(t,e))</span>)}</span>}}<span class="fstat-no" title="function not covered" ></span>mo</span>unt(){<span class="cstat-no" title="statement not covered" >this.removePointerDownListener=Wt(this.node.current,"pointerdown",(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >this.onPointerDown(t))</span>)}<span class="fstat-no" title="function not covered" ></span>up</span>date(){<span class="cstat-no" title="statement not covered" >this.session&amp;&amp;this.session.updateHandlers(this.createPanHandlers())}<span class="fstat-no" title="function not covered" ></span>un</span>mount(){<span class="cstat-no" title="statement not covered" >this.removePointerDownListener(),this.session&amp;&amp;this.session.end()}</span>}},drag:{Feature:class extends Gt{<span class="fstat-no" title="function not covered" >co</span>nstructor(t){<span class="cstat-no" title="statement not covered" >super(t),this.removeGroupControls=_t.Z,this.removeListeners=_t.Z,this.controls=new rs(t)}<span class="fstat-no" title="function not covered" ></span>mo</span>unt(){const{dragControls:t}=<span class="cstat-no" title="statement not covered" >this.node.getProps();<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(this.removeGroupControls=t.subscribe(this.controls)),this.removeListeners=this.controls.addListeners()||_t.Z}<span class="fstat-no" title="function not covered" ></span>un</span>mount(){<span class="cstat-no" title="statement not covered" >this.removeGroupControls(),this.removeListeners()}</span>},ProjectionNode:mo,MeasureLayout:ms}},</span>go=<span class="cstat-no" title="statement not covered" >/var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;</span>function <span class="fstat-no" title="function not covered" >yo(</span>t,e,n=<span class="branch-0 cbranch-no" title="branch not covered" >1)</span>{<span class="cstat-no" title="statement not covered" >(0,le.k)(n&lt;=4,`Max CSS variable fallback depth detected in property "${t}". This may indicate a circular fallback dependency.`);c</span>onst[i,s]=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >go.exec(t);<span class="cstat-no" title="statement not covered" ></span>if(!e)<span class="cstat-no" title="statement not covered" >return[,];c</span></span>onst[,n,i]=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>return[n,i]}</span>(t);<span class="cstat-no" title="statement not covered" ></span>if(!i)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >window.getComputedStyle(e).getPropertyValue(i);<span class="cstat-no" title="statement not covered" ></span>if(o){const t=<span class="cstat-no" title="statement not covered" >o.trim();<span class="cstat-no" title="statement not covered" ></span>return Xn(t)?parseFloat(t):t}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn W(s)?yo(s,e,n+1):s}</span>const vo=<span class="cstat-no" title="statement not covered" >new Set(["width","height","top","left","right","bottom","x","y","translateX","translateY"]),</span>xo=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >vo.has(t),</span></span>Po=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t===Z||t===tt,</span></span>bo=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >parseFloat(t.split(", ")[e]),</span></span>To=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(n</span>,{transform:i})=&gt;{<span class="cstat-no" title="statement not covered" >if("none"===i||!i)<span class="cstat-no" title="statement not covered" >return 0;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >i.match(/^matrix3d\((.+)\)$/);<span class="cstat-no" title="statement not covered" ></span>if(s)<span class="cstat-no" title="statement not covered" >return bo(s[1],e);{</span></span>const e=<span class="cstat-no" title="statement not covered" >i.match(/^matrix\((.+)\)$/);<span class="cstat-no" title="statement not covered" ></span>return e?bo(e[1],t):0}</span>},</span></span>So=<span class="cstat-no" title="statement not covered" >new Set(["x","y","z"]),</span>wo=<span class="cstat-no" title="statement not covered" >R.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >!So.has(t))</span>);</span>const Ao=<span class="cstat-no" title="statement not covered" >{width:<span class="fstat-no" title="function not covered" >({</span>x:t},{paddingLeft:e=<span class="branch-0 cbranch-no" title="branch not covered" >"0",</span>paddingRight:n=<span class="branch-0 cbranch-no" title="branch not covered" >"0"}</span>)=&gt;<span class="cstat-no" title="statement not covered" >t.max-t.min-parseFloat(e)-parseFloat(n),</span>height:<span class="fstat-no" title="function not covered" >({</span>y:t},{paddingTop:e=<span class="branch-0 cbranch-no" title="branch not covered" >"0",</span>paddingBottom:n=<span class="branch-0 cbranch-no" title="branch not covered" >"0"}</span>)=&gt;<span class="cstat-no" title="statement not covered" >t.max-t.min-parseFloat(e)-parseFloat(n),</span>top:<span class="fstat-no" title="function not covered" >(t</span>,{top:e})=&gt;<span class="cstat-no" title="statement not covered" >parseFloat(e),</span>left:<span class="fstat-no" title="function not covered" >(t</span>,{left:e})=&gt;<span class="cstat-no" title="statement not covered" >parseFloat(e),</span>bottom:<span class="fstat-no" title="function not covered" >({</span>y:t},{top:e})=&gt;<span class="cstat-no" title="statement not covered" >parseFloat(e)+(t.max-t.min),</span>right:<span class="fstat-no" title="function not covered" >({</span>x:t},{left:e})=&gt;<span class="cstat-no" title="statement not covered" >parseFloat(e)+(t.max-t.min),</span>x:To(4,13),y:To(5,14)};<span class="cstat-no" title="statement not covered" ></span>Ao.translateX=Ao.x,Ao.translateY=Ao.y;c</span>onst Vo=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,n=<span class="branch-0 cbranch-no" title="branch not covered" >{},</span>i=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>=&gt;{<span class="cstat-no" title="statement not covered" >e={...e},i={...i};c</span>onst s=<span class="cstat-no" title="statement not covered" >Object.keys(e).filter(xo);</span>let o=<span class="cstat-no" title="statement not covered" >[],</span>r=<span class="cstat-no" title="statement not covered" >!1;</span>const a=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(s.forEach((<span class="fstat-no" title="function not covered" >s=</span>&gt;{const l=<span class="cstat-no" title="statement not covered" >t.getValue(s);<span class="cstat-no" title="statement not covered" ></span>if(!t.hasValue(s))<span class="cstat-no" title="statement not covered" >return;l</span></span>et u=<span class="cstat-no" title="statement not covered" >n[s],</span>c=<span class="cstat-no" title="statement not covered" >ni(u);</span>const h=<span class="cstat-no" title="statement not covered" >e[s];</span>let d;<span class="cstat-no" title="statement not covered" >if(Mt(h)){const t=<span class="cstat-no" title="statement not covered" >h.length,</span>e=<span class="cstat-no" title="statement not covered" >null===h[0]?1:0;<span class="cstat-no" title="statement not covered" ></span>u=h[e],c=ni(u);<span class="cstat-no" title="statement not covered" >f</span>or(let n=<span class="cstat-no" title="statement not covered" >e;</span>n&lt;t&amp;&amp;null!==h[n];n++)<span class="cstat-no" title="statement not covered" >d?(0,le.k)(ni(h[n])===d,"All keyframes must be of the same type"):(d=ni(h[n]),(0,le.k)(d===c||Po(c)&amp;&amp;Po(d),"Keyframes must be of the same dimension as the current value"))}</span></span>else <span class="cstat-no" title="statement not covered" >d=ni(h);<span class="cstat-no" title="statement not covered" >i</span></span>f(c!==d)<span class="cstat-no" title="statement not covered" >if(Po(c)&amp;&amp;Po(d)){const t=<span class="cstat-no" title="statement not covered" >l.get();<span class="cstat-no" title="statement not covered" ></span>"string"===typeof t&amp;&amp;l.set(parseFloat(t)),"string"===typeof h?e[s]=parseFloat(h):Array.isArray(h)&amp;&amp;d===tt&amp;&amp;(e[s]=h.map(parseFloat))}</span>else<span class="cstat-no" title="statement not covered" >(null===c||void 0===c?void 0:c.transform)&amp;&amp;(null===d||void 0===d?void 0:d.transform)&amp;&amp;(0===u||0===h)?0===u?l.set(d.transform(u)):e[s]=c.transform(h):(r||(o=<span class="fstat-no" title="function not covered" >fu</span>nction(t){const e=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>return wo.forEach((<span class="fstat-no" title="function not covered" >n=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >t.getValue(n);<span class="cstat-no" title="statement not covered" ></span>void 0!==i&amp;&amp;(e.push([n,i.get()]),i.set(n.startsWith("scale")?1:0))}</span>)),e.length&amp;&amp;t.render(),e}</span>(t),r=!0),a.push(s),i[s]=void 0!==i[s]?i[s]:e[s],l.jump(h))}</span></span></span>)),a.length){const n=<span class="cstat-no" title="statement not covered" >a.indexOf("height")&gt;=0?window.pageYOffset:null,</span>s=<span class="cstat-no" title="statement not covered" >(<span class="fstat-no" title="function not covered" >(t</span>,e,n)=&gt;{const i=<span class="cstat-no" title="statement not covered" >e.measureViewportBox(),</span>s=<span class="cstat-no" title="statement not covered" >e.current,</span>o=<span class="cstat-no" title="statement not covered" >getComputedStyle(s),</span>{display:r}=<span class="cstat-no" title="statement not covered" >o,</span>a=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>"none"===r&amp;&amp;e.setStaticValue("display",t.display||"block"),n.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >a[t]=Ao[t](i,o)}</span>)),e.render();c</span>onst l=<span class="cstat-no" title="statement not covered" >e.measureViewportBox();<span class="cstat-no" title="statement not covered" ></span>return n.forEach((<span class="fstat-no" title="function not covered" >n=</span>&gt;{const i=<span class="cstat-no" title="statement not covered" >e.getValue(n);<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;i.jump(a[n]),t[n]=Ao[n](l,o)}</span>)),t}</span>)(e,t,a);<span class="cstat-no" title="statement not covered" ></span>return o.length&amp;&amp;o.forEach((<span class="fstat-no" title="function not covered" >([</span>e,n])=&gt;{<span class="cstat-no" title="statement not covered" >t.getValue(e).set(n)}</span>)),t.render(),T.j&amp;&amp;null!==n&amp;&amp;window.scrollTo({top:n}),{target:s,transitionEnd:i}}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{target:e,transitionEnd:i}}</span>;</span>function <span class="fstat-no" title="function not covered" >Eo(</span>t,e,n,i){<span class="cstat-no" title="statement not covered" >return(<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >Object.keys(t).some(xo))</span>(e)?Vo(t,e,n,i):{target:e,transitionEnd:i}}</span>const Co=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e,n,i)=&gt;{const s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,{...e},n){const i=<span class="cstat-no" title="statement not covered" >t.current;<span class="cstat-no" title="statement not covered" ></span>if(!(i instanceof Element))<span class="cstat-no" title="statement not covered" >return{target:e,transitionEnd:n};<span class="cstat-no" title="statement not covered" >n</span></span>&amp;&amp;(n={...n}),t.values.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >t.get();<span class="cstat-no" title="statement not covered" ></span>if(!W(e))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >yo(e,i);<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;t.set(n)}</span>));<span class="cstat-no" title="statement not covered" >f</span>or(const s in e){const t=<span class="cstat-no" title="statement not covered" >e[s];<span class="cstat-no" title="statement not covered" ></span>if(!W(t))<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst o=<span class="cstat-no" title="statement not covered" >yo(t,i);<span class="cstat-no" title="statement not covered" ></span>o&amp;&amp;(e[s]=o,n||(n={}),void 0===n[s]&amp;&amp;(n[s]=t))}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{target:e,transitionEnd:n}}</span>(t,e,i);<span class="cstat-no" title="statement not covered" ></span>return Eo(t,e=s.target,n,i=s.transitionEnd)}</span>,</span>Do=<span class="cstat-no" title="statement not covered" >{current:null},</span>Mo=<span class="cstat-no" title="statement not covered" >{current:!1};</span>const ko=<span class="cstat-no" title="statement not covered" >new WeakMap,</span>Ro=<span class="cstat-no" title="statement not covered" >Object.keys(b),</span>Lo=<span class="cstat-no" title="statement not covered" >Ro.length,</span>jo=<span class="cstat-no" title="statement not covered" >["AnimationStart","AnimationComplete","Update","BeforeLayoutMeasure","LayoutMeasure","LayoutAnimationStart","LayoutAnimationComplete"],</span>Bo=<span class="cstat-no" title="statement not covered" >f.length;</span>class Fo extends class{<span class="fstat-no" title="function not covered" >co</span>nstructor({parent:t,props:e,presenceContext:n,reducedMotionConfig:i,visualState:s},o=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >this.current=null,this.children=new Set,this.isVariantNode=!1,this.isControllingVariants=!1,this.shouldReduceMotion=null,this.values=new Map,this.features={},this.valueSubscriptions=new Map,this.prevMotionValues={},this.events={},this.propEventSubscriptions={},this.notifyUpdate=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.notify("Update",this.latestValues),</span>this.render=<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.current&amp;&amp;(this.triggerBuild(),this.renderInstance(this.current,this.renderState,this.props.style,this.projection))}</span>,this.scheduleRender=<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >jt.Wi.render(this.render,!1,!0);</span>c</span>onst{latestValues:r,renderState:a}=<span class="cstat-no" title="statement not covered" >s;<span class="cstat-no" title="statement not covered" ></span>this.latestValues=r,this.baseTarget={...r},this.initialValues=e.initial?{...r}:{},this.renderState=a,this.parent=t,this.props=e,this.presenceContext=n,this.depth=t?t.depth+1:0,this.reducedMotionConfig=i,this.options=o,this.isControllingVariants=g(e),this.isVariantNode=y(e),this.isVariantNode&amp;&amp;(this.variantChildren=new Set),this.manuallyAnimateOnMount=Boolean(t&amp;&amp;t.current);c</span>onst{willChange:l,...u}=<span class="cstat-no" title="statement not covered" >this.scrapeMotionValuesFromProps(e,{});<span class="cstat-no" title="statement not covered" ></span>for(const c in u){const t=<span class="cstat-no" title="statement not covered" >u[c];<span class="cstat-no" title="statement not covered" ></span>void 0!==r[c]&amp;&amp;B(t)&amp;&amp;(t.set(r[c],!1),Yn(l)&amp;&amp;l.add(c))}</span>}<span class="fstat-no" title="function not covered" ></span>sc</span>rapeMotionValuesFromProps(t,e){<span class="cstat-no" title="statement not covered" >return{}}<span class="fstat-no" title="function not covered" ></span>mo</span>unt(t){<span class="cstat-no" title="statement not covered" >this.current=t,ko.set(t,this),this.projection&amp;&amp;!this.projection.instance&amp;&amp;this.projection.mount(t),this.parent&amp;&amp;this.isVariantNode&amp;&amp;!this.isControllingVariants&amp;&amp;(this.removeFromVariantTree=this.parent.addVariantChild(this)),this.values.forEach((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >this.bindToMotionValue(e,t))</span>),Mo.current||<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >if(Mo.current=!0,T.j)<span class="cstat-no" title="statement not covered" >if(window.matchMedia){const t=<span class="cstat-no" title="statement not covered" >window.matchMedia("(prefers-reduced-motion)"),</span>e=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Do.current=t.matches;<span class="cstat-no" title="statement not covered" ></span></span>t.addListener(e),e()}</span>else <span class="cstat-no" title="statement not covered" >Do.current=!1}</span></span></span>(),this.shouldReduceMotion="never"!==this.reducedMotionConfig&amp;&amp;("always"===this.reducedMotionConfig||Do.current),this.parent&amp;&amp;this.parent.children.add(this),this.update(this.props,this.presenceContext)}<span class="fstat-no" title="function not covered" ></span>un</span>mount(){<span class="cstat-no" title="statement not covered" >ko.delete(this.current),this.projection&amp;&amp;this.projection.unmount(),(0,jt.Pn)(this.notifyUpdate),(0,jt.Pn)(this.render),this.valueSubscriptions.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t())</span>),this.removeFromVariantTree&amp;&amp;this.removeFromVariantTree(),this.parent&amp;&amp;this.parent.children.delete(this);<span class="cstat-no" title="statement not covered" >f</span>or(const t in this.events)<span class="cstat-no" title="statement not covered" >this.events[t].clear();<span class="cstat-no" title="statement not covered" >f</span></span>or(const t in this.features)<span class="cstat-no" title="statement not covered" >this.features[t].unmount();<span class="cstat-no" title="statement not covered" >t</span></span>his.current=null}<span class="fstat-no" title="function not covered" ></span>bi</span>ndToMotionValue(t,e){const n=<span class="cstat-no" title="statement not covered" >L.has(t),</span>i=<span class="cstat-no" title="statement not covered" >e.on("change",(<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.latestValues[t]=e,this.props.onUpdate&amp;&amp;jt.Wi.update(this.notifyUpdate,!1,!0),n&amp;&amp;this.projection&amp;&amp;(this.projection.isTransformDirty=!0)}</span>)),</span>s=<span class="cstat-no" title="statement not covered" >e.on("renderRequest",this.scheduleRender);<span class="cstat-no" title="statement not covered" ></span>this.valueSubscriptions.set(t,(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >i(),s()}</span>))}<span class="fstat-no" title="function not covered" ></span>so</span>rtNodePosition(t){<span class="cstat-no" title="statement not covered" >return this.current&amp;&amp;this.sortInstanceNodePosition&amp;&amp;this.type===t.type?this.sortInstanceNodePosition(this.current,t.current):0}<span class="fstat-no" title="function not covered" ></span>lo</span>adFeatures({children:t,...e},n,i,s){let o,r;<span class="cstat-no" title="statement not covered" >for(let a=<span class="cstat-no" title="statement not covered" >0;</span>a&lt;Lo;a++){const t=<span class="cstat-no" title="statement not covered" >Ro[a],</span>{isEnabled:n,Feature:i,ProjectionNode:s,MeasureLayout:l}=<span class="cstat-no" title="statement not covered" >b[t];<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;(o=s),n(e)&amp;&amp;(!this.features[t]&amp;&amp;i&amp;&amp;(this.features[t]=new i(this)),l&amp;&amp;(r=l))}<span class="cstat-no" title="statement not covered" ></span>i</span>f(("html"===this.type||"svg"===this.type)&amp;&amp;!this.projection&amp;&amp;o){<span class="cstat-no" title="statement not covered" >this.projection=new o(this.latestValues,this.parent&amp;&amp;this.parent.projection);c</span>onst{layoutId:t,layout:n,drag:i,dragConstraints:r,layoutScroll:a,layoutRoot:l}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>this.projection.setOptions({layoutId:t,layout:n,alwaysMeasureLayout:Boolean(i)||r&amp;&amp;h(r),visualElement:this,scheduleRender:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.scheduleRender(),</span>animationType:"string"===typeof n?n:"both",initialPromotionConfig:s,layoutScroll:a,layoutRoot:l})}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn r}<span class="fstat-no" title="function not covered" ></span>up</span>dateFeatures(){<span class="cstat-no" title="statement not covered" >for(const t in this.features){const e=<span class="cstat-no" title="statement not covered" >this.features[t];<span class="cstat-no" title="statement not covered" ></span>e.isMounted?e.update():(e.mount(),e.isMounted=!0)}</span>}<span class="fstat-no" title="function not covered" ></span>tr</span>iggerBuild(){<span class="cstat-no" title="statement not covered" >this.build(this.renderState,this.latestValues,this.options,this.props)}<span class="fstat-no" title="function not covered" ></span>me</span>asureViewportBox(){<span class="cstat-no" title="statement not covered" >return this.current?this.measureInstanceViewportBox(this.current,this.props):{x:{min:0,max:0},y:{min:0,max:0}}}<span class="fstat-no" title="function not covered" ></span>ge</span>tStaticValue(t){<span class="cstat-no" title="statement not covered" >return this.latestValues[t]}<span class="fstat-no" title="function not covered" ></span>se</span>tStaticValue(t,e){<span class="cstat-no" title="statement not covered" >this.latestValues[t]=e}<span class="fstat-no" title="function not covered" ></span>ma</span>keTargetAnimatable(t,e=<span class="branch-0 cbranch-no" title="branch not covered" >!0)</span>{<span class="cstat-no" title="statement not covered" >return this.makeTargetAnimatableFromInstance(t,this.props,e)}<span class="fstat-no" title="function not covered" ></span>up</span>date(t,e){<span class="cstat-no" title="statement not covered" >(t.transformTemplate||this.props.transformTemplate)&amp;&amp;this.scheduleRender(),this.prevProps=this.props,this.props=t,this.prevPresenceContext=this.presenceContext,this.presenceContext=e;<span class="cstat-no" title="statement not covered" >f</span>or(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;jo.length;n++){const e=<span class="cstat-no" title="statement not covered" >jo[n];<span class="cstat-no" title="statement not covered" ></span>this.propEventSubscriptions[e]&amp;&amp;(this.propEventSubscriptions[e](),delete this.propEventSubscriptions[e]);c</span>onst i=<span class="cstat-no" title="statement not covered" >t["on"+e];<span class="cstat-no" title="statement not covered" ></span>i&amp;&amp;(this.propEventSubscriptions[e]=this.on(e,i))}<span class="cstat-no" title="statement not covered" ></span>t</span>his.prevMotionValues=<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){const{willChange:i}=<span class="cstat-no" title="statement not covered" >e;<span class="cstat-no" title="statement not covered" ></span>for(const s in e){const o=<span class="cstat-no" title="statement not covered" >e[s],</span>r=<span class="cstat-no" title="statement not covered" >n[s];<span class="cstat-no" title="statement not covered" ></span>if(B(o))<span class="cstat-no" title="statement not covered" >t.addValue(s,o),Yn(i)&amp;&amp;i.add(s);e</span>lse <span class="cstat-no" title="statement not covered" >if(B(r))<span class="cstat-no" title="statement not covered" >t.addValue(s,Qn(o,{owner:t})),Yn(i)&amp;&amp;i.remove(s);e</span>lse <span class="cstat-no" title="statement not covered" >if(r!==o)<span class="cstat-no" title="statement not covered" >if(t.hasValue(s)){const e=<span class="cstat-no" title="statement not covered" >t.getValue(s);<span class="cstat-no" title="statement not covered" ></span>!e.hasAnimated&amp;&amp;e.set(o)}</span>else{const e=<span class="cstat-no" title="statement not covered" >t.getStaticValue(s);<span class="cstat-no" title="statement not covered" ></span>t.addValue(s,Qn(void 0!==e?e:o,{owner:t}))}</span>}<span class="cstat-no" title="statement not covered" ></span></span></span></span>f</span>or(const s in n)<span class="cstat-no" title="statement not covered" >void 0===e[s]&amp;&amp;t.removeValue(s);<span class="cstat-no" title="statement not covered" >r</span></span>eturn e}</span>(this,this.scrapeMotionValuesFromProps(t,this.prevProps),this.prevMotionValues),this.handleChildMotionValue&amp;&amp;this.handleChildMotionValue()}<span class="fstat-no" title="function not covered" ></span>ge</span>tProps(){<span class="cstat-no" title="statement not covered" >return this.props}<span class="fstat-no" title="function not covered" ></span>ge</span>tVariant(t){<span class="cstat-no" title="statement not covered" >return this.props.variants?this.props.variants[t]:void 0}<span class="fstat-no" title="function not covered" ></span>ge</span>tDefaultTransition(){<span class="cstat-no" title="statement not covered" >return this.props.transition}<span class="fstat-no" title="function not covered" ></span>ge</span>tTransformPagePoint(){<span class="cstat-no" title="statement not covered" >return this.props.transformPagePoint}<span class="fstat-no" title="function not covered" ></span>ge</span>tClosestVariantNode(){<span class="cstat-no" title="statement not covered" >return this.isVariantNode?this:this.parent?this.parent.getClosestVariantNode():void 0}<span class="fstat-no" title="function not covered" ></span>ge</span>tVariantContext(t=<span class="branch-0 cbranch-no" title="branch not covered" >!1)</span>{<span class="cstat-no" title="statement not covered" >if(t)<span class="cstat-no" title="statement not covered" >return this.parent?this.parent.getVariantContext():void 0;<span class="cstat-no" title="statement not covered" >i</span></span>f(!this.isControllingVariants){const t=<span class="cstat-no" title="statement not covered" >this.parent&amp;&amp;this.parent.getVariantContext()||{};<span class="cstat-no" title="statement not covered" ></span>return void 0!==this.props.initial&amp;&amp;(t.initial=this.props.initial),t}</span>c</span>onst e=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(let n=<span class="cstat-no" title="statement not covered" >0;</span>n&lt;Bo;n++){const t=<span class="cstat-no" title="statement not covered" >f[n],</span>i=<span class="cstat-no" title="statement not covered" >this.props[t];<span class="cstat-no" title="statement not covered" ></span>(d(i)||!1===i)&amp;&amp;(e[t]=i)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e}<span class="fstat-no" title="function not covered" ></span>ad</span>dVariantChild(t){const e=<span class="cstat-no" title="statement not covered" >this.getClosestVariantNode();<span class="cstat-no" title="statement not covered" ></span>if(e)<span class="cstat-no" title="statement not covered" >return e.variantChildren&amp;&amp;e.variantChildren.add(t),<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >e.variantChildren.delete(t)}<span class="fstat-no" title="function not covered" ></span></span></span>ad</span>dValue(t,e){<span class="cstat-no" title="statement not covered" >e!==this.values.get(t)&amp;&amp;(this.removeValue(t),this.bindToMotionValue(t,e)),this.values.set(t,e),this.latestValues[t]=e.get()}<span class="fstat-no" title="function not covered" ></span>re</span>moveValue(t){<span class="cstat-no" title="statement not covered" >this.values.delete(t);c</span>onst e=<span class="cstat-no" title="statement not covered" >this.valueSubscriptions.get(t);<span class="cstat-no" title="statement not covered" ></span>e&amp;&amp;(e(),this.valueSubscriptions.delete(t)),delete this.latestValues[t],this.removeValueFromRenderState(t,this.renderState)}<span class="fstat-no" title="function not covered" ></span>ha</span>sValue(t){<span class="cstat-no" title="statement not covered" >return this.values.has(t)}<span class="fstat-no" title="function not covered" ></span>ge</span>tValue(t,e){<span class="cstat-no" title="statement not covered" >if(this.props.values&amp;&amp;this.props.values[t])<span class="cstat-no" title="statement not covered" >return this.props.values[t];l</span></span>et n=<span class="cstat-no" title="statement not covered" >this.values.get(t);<span class="cstat-no" title="statement not covered" ></span>return void 0===n&amp;&amp;void 0!==e&amp;&amp;(n=Qn(e,{owner:this}),this.addValue(t,n)),n}<span class="fstat-no" title="function not covered" ></span>re</span>adValue(t){var e;<span class="cstat-no" title="statement not covered" >return void 0===this.latestValues[t]&amp;&amp;this.current?null!==(e=this.getBaseTargetFromProps(this.props,t))&amp;&amp;void 0!==e?e:this.readValueFromInstance(this.current,t,this.options):this.latestValues[t]}<span class="fstat-no" title="function not covered" ></span>se</span>tBaseTarget(t,e){<span class="cstat-no" title="statement not covered" >this.baseTarget[t]=e}<span class="fstat-no" title="function not covered" ></span>ge</span>tBaseTarget(t){var e;const{initial:n}=<span class="cstat-no" title="statement not covered" >this.props,</span>i=<span class="cstat-no" title="statement not covered" >"string"===typeof n||"object"===typeof n?null===(e=Ct(this.props,n))||void 0===e?void 0:e[t]:void 0;<span class="cstat-no" title="statement not covered" ></span>if(n&amp;&amp;void 0!==i)<span class="cstat-no" title="statement not covered" >return i;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this.getBaseTargetFromProps(this.props,t);<span class="cstat-no" title="statement not covered" ></span>return void 0===s||B(s)?void 0!==this.initialValues[t]&amp;&amp;void 0===i?void 0:this.baseTarget[t]:s}<span class="fstat-no" title="function not covered" ></span>on</span>(t,e){<span class="cstat-no" title="statement not covered" >return this.events[t]||(this.events[t]=new Kn),this.events[t].add(e)}<span class="fstat-no" title="function not covered" ></span>no</span>tify(t,...e){<span class="cstat-no" title="statement not covered" >this.events[t]&amp;&amp;this.events[t].notify(...e)}</span>}{<span class="fstat-no" title="function not covered" >so</span>rtInstanceNodePosition(t,e){<span class="cstat-no" title="statement not covered" >return 2&amp;t.compareDocumentPosition(e)?1:-1}<span class="fstat-no" title="function not covered" ></span>ge</span>tBaseTargetFromProps(t,e){<span class="cstat-no" title="statement not covered" >return t.style?t.style[e]:void 0}<span class="fstat-no" title="function not covered" ></span>re</span>moveValueFromRenderState(t,{vars:e,style:n}){<span class="cstat-no" title="statement not covered" >delete e[t],delete n[t]}<span class="fstat-no" title="function not covered" ></span>ma</span>keTargetAnimatableFromInstance({transition:t,transitionEnd:e,...n},{transformValues:i},s){let o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){const i=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>for(const s in t){const t=<span class="cstat-no" title="statement not covered" >ri(s,e);<span class="cstat-no" title="statement not covered" ></span>if(void 0!==t)<span class="cstat-no" title="statement not covered" >i[s]=t;e</span>lse{const t=<span class="cstat-no" title="statement not covered" >n.getValue(s);<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;(i[s]=t.get())}</span>}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn i}</span>(n,t||{},this);<span class="cstat-no" title="statement not covered" ></span>if(i&amp;&amp;(e&amp;&amp;(e=i(e)),n&amp;&amp;(n=i(n)),o&amp;&amp;(o=i(o))),s){<span class="cstat-no" title="statement not covered" >!<span class="fstat-no" title="function not covered" >fu</span>nction(t,e,n){var i,s;const o=<span class="cstat-no" title="statement not covered" >Object.keys(e).filter((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >!t.hasValue(e))</span>),</span>r=<span class="cstat-no" title="statement not covered" >o.length;</span>var a;<span class="cstat-no" title="statement not covered" >if(r)<span class="cstat-no" title="statement not covered" >for(let l=<span class="cstat-no" title="statement not covered" >0;</span>l&lt;r;l++){const r=<span class="cstat-no" title="statement not covered" >o[l],</span>u=<span class="cstat-no" title="statement not covered" >e[r];</span>let c=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>Array.isArray(u)&amp;&amp;(c=u[0]),null===c&amp;&amp;(c=null!==(s=null!==(i=n[r])&amp;&amp;void 0!==i?i:t.readValue(r))&amp;&amp;void 0!==s?s:e[r]),void 0!==c&amp;&amp;null!==c&amp;&amp;("string"===typeof c&amp;&amp;(Xn(c)||Nn(c))?c=parseFloat(c):(a=c,!ii.find(ti(a))&amp;&amp;Qe.test(u)&amp;&amp;(c=Wn(r,u))),t.addValue(r,Qn(c,{owner:t})),void 0===n[r]&amp;&amp;(n[r]=c),null!==c&amp;&amp;t.setBaseTarget(r,c))}</span>}</span></span>(this,n,o);c</span>onst t=<span class="cstat-no" title="statement not covered" >Co(this,n,o,e);<span class="cstat-no" title="statement not covered" ></span>e=t.transitionEnd,n=t.target}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{transition:t,transitionEnd:e,...n}}</span>}class Oo extends Fo{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(...arguments),this.type="html"}<span class="fstat-no" title="function not covered" ></span>re</span>adValueFromInstance(t,e){<span class="cstat-no" title="statement not covered" >if(L.has(e)){const t=<span class="cstat-no" title="statement not covered" >Un(e);<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;t.default||0}</span>{</span>const i=(<span class="cstat-no" title="statement not covered" >n=t,window.getComputedStyle(n))</span>,s=<span class="cstat-no" title="statement not covered" >(U(e)?i.getPropertyValue(e):i[e])||0;<span class="cstat-no" title="statement not covered" ></span>return"string"===typeof s?s.trim():s}</span>var n}<span class="fstat-no" title="function not covered" >me</span>asureInstanceViewportBox(t,{transformPagePoint:e}){<span class="cstat-no" title="statement not covered" >return is(t,e)}<span class="fstat-no" title="function not covered" ></span>bu</span>ild(t,e,n,i){<span class="cstat-no" title="statement not covered" >rt(t,e,n,i.transformTemplate)}<span class="fstat-no" title="function not covered" ></span>sc</span>rapeMotionValuesFromProps(t,e){<span class="cstat-no" title="statement not covered" >return Vt(t,e)}<span class="fstat-no" title="function not covered" ></span>ha</span>ndleChildMotionValue(){<span class="cstat-no" title="statement not covered" >this.childSubscription&amp;&amp;(this.childSubscription(),delete this.childSubscription);c</span>onst{children:t}=<span class="cstat-no" title="statement not covered" >this.props;<span class="cstat-no" title="statement not covered" ></span>B(t)&amp;&amp;(this.childSubscription=t.on("change",(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >this.current&amp;&amp;(this.current.textContent=`${t}`)}</span>)))}<span class="fstat-no" title="function not covered" ></span>re</span>nderInstance(t,e,n,i){<span class="cstat-no" title="statement not covered" >St(t,e,n,i)}</span>}class Io extends Fo{<span class="fstat-no" title="function not covered" >co</span>nstructor(){<span class="cstat-no" title="statement not covered" >super(...arguments),this.type="svg",this.isSVGTag=!1}<span class="fstat-no" title="function not covered" ></span>ge</span>tBaseTargetFromProps(t,e){<span class="cstat-no" title="statement not covered" >return t[e]}<span class="fstat-no" title="function not covered" ></span>re</span>adValueFromInstance(t,e){<span class="cstat-no" title="statement not covered" >if(L.has(e)){const t=<span class="cstat-no" title="statement not covered" >Un(e);<span class="cstat-no" title="statement not covered" ></span>return t&amp;&amp;t.default||0}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn e=wt.has(e)?e:u(e),t.getAttribute(e)}<span class="fstat-no" title="function not covered" ></span>me</span>asureInstanceViewportBox(){<span class="cstat-no" title="statement not covered" >return{x:{min:0,max:0},y:{min:0,max:0}}}<span class="fstat-no" title="function not covered" ></span>sc</span>rapeMotionValuesFromProps(t,e){<span class="cstat-no" title="statement not covered" >return Et(t,e)}<span class="fstat-no" title="function not covered" ></span>bu</span>ild(t,e,n,i){<span class="cstat-no" title="statement not covered" >vt(t,e,n,this.isSVGTag,i.transformTemplate)}<span class="fstat-no" title="function not covered" ></span>re</span>nderInstance(t,e,n,i){<span class="cstat-no" title="statement not covered" >At(t,e,0,i)}<span class="fstat-no" title="function not covered" ></span>mo</span>unt(t){<span class="cstat-no" title="statement not covered" >this.isSVGTag=Pt(t.tagName),super.mount(t)}</span>}const Uo=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >M(t)?new Io(e,{enableHardwareAcceleration:!1}):new Oo(e,{enableHardwareAcceleration:!0}),</span></span>Wo=<span class="cstat-no" title="statement not covered" >{...xi,...oe,...fo,...{layout:{ProjectionNode:mo,MeasureLayout:ms}}},</span>No=<span class="cstat-no" title="statement not covered" >C((<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >fu</span>nction(t,{forwardMotionProps:e=<span class="branch-0 cbranch-no" title="branch not covered" >!1}</span>,n,i){<span class="cstat-no" title="statement not covered" >return{...M(t)?Bt:Ft,preloadedFeatures:n,useRender:Tt(e),createVisualElement:i,Component:t}}</span>(t,e,Wo,Uo))</span>)}</span>,47279:<span class="fstat-no" title="function not covered" >(t</span>,e,n)=&gt;{<span class="cstat-no" title="statement not covered" >n.d(e,{K:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >s,</span>k:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >o}</span>);v</span>ar i=<span class="cstat-no" title="statement not covered" >n(41279);</span>let s=<span class="cstat-no" title="statement not covered" >i.Z,</span>o=<span class="cstat-no" title="statement not covered" >i.Z}</span>,58066:<span class="fstat-no" title="function not covered" >(t</span>,e,n)=&gt;{<span class="cstat-no" title="statement not covered" >n.d(e,{j:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >i}</span>);c</span>onst i=<span class="cstat-no" title="statement not covered" >"undefined"!==typeof document}</span>,41279:<span class="fstat-no" title="function not covered" >(t</span>,e,n)=&gt;{<span class="cstat-no" title="statement not covered" >n.d(e,{Z:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >i}</span>);c</span>onst i=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t}</span></span>,34349:<span class="fstat-no" title="function not covered" >(t</span>,e,n)=&gt;{<span class="cstat-no" title="statement not covered" >n.d(e,{h:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >s}</span>);v</span>ar i=<span class="cstat-no" title="statement not covered" >n(9885);</span>function <span class="fstat-no" title="function not covered" >s(</span>t){const e=<span class="cstat-no" title="statement not covered" >(0,i.useRef)(null);<span class="cstat-no" title="statement not covered" ></span>return null===e.current&amp;&amp;(e.current=t()),e.current}</span>},60381:<span class="fstat-no" title="function not covered" >(t</span>,e,n)=&gt;{<span class="cstat-no" title="statement not covered" >n.d(e,{L:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >s}</span>);v</span>ar i=<span class="cstat-no" title="statement not covered" >n(9885);</span>const s=<span class="cstat-no" title="statement not covered" >n(58066).j?i.useLayoutEffect:i.useEffect}</span>};</span></pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2025-11-10T08:07:38.115Z
            </div>
        <script src="../../../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../../../sorter.js"></script>
        <script src="../../../../../block-navigation.js"></script>
    </body>
</html>
    