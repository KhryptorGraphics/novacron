
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for novacron/frontend/.next/server/chunks/3993.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../../../index.html">All files</a> / <a href="index.html">novacron/frontend/.next/server/chunks</a> 3993.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/187</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/258</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/73</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/1</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">"use strict";<span class="cstat-no" title="statement not covered" >exports.id=3993,exports.ids=[3993],exports.modules={53993:<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >s.d(e,{a:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Q}</span>);v</span>ar r=<span class="cstat-no" title="statement not covered" >s(29520),</span>i=<span class="cstat-no" title="statement not covered" >s(48818),</span>n=<span class="cstat-no" title="statement not covered" >s(236),</span>u=<span class="cstat-no" title="statement not covered" >s(80834),</span>o=<span class="cstat-no" title="statement not covered" >s(42306);</span>class a extends u.l{<span class="fstat-no" title="function not covered" >co</span>nstructor(t,e){<span class="cstat-no" title="statement not covered" >super(),this.client=t,this.options=e,this.trackedProps=new Set,this.selectError=null,this.bindMethods(),this.setOptions(e)}<span class="fstat-no" title="function not covered" ></span>bi</span>ndMethods(){<span class="cstat-no" title="statement not covered" >this.remove=this.remove.bind(this),this.refetch=this.refetch.bind(this)}<span class="fstat-no" title="function not covered" ></span>on</span>Subscribe(){<span class="cstat-no" title="statement not covered" >1===this.listeners.size&amp;&amp;(this.currentQuery.addObserver(this),c(this.currentQuery,this.options)&amp;&amp;this.executeFetch(),this.updateTimers())}<span class="fstat-no" title="function not covered" ></span>on</span>Unsubscribe(){<span class="cstat-no" title="statement not covered" >this.hasListeners()||this.destroy()}<span class="fstat-no" title="function not covered" ></span>sh</span>ouldFetchOnReconnect(){<span class="cstat-no" title="statement not covered" >return l(this.currentQuery,this.options,this.options.refetchOnReconnect)}<span class="fstat-no" title="function not covered" ></span>sh</span>ouldFetchOnWindowFocus(){<span class="cstat-no" title="statement not covered" >return l(this.currentQuery,this.options,this.options.refetchOnWindowFocus)}<span class="fstat-no" title="function not covered" ></span>de</span>stroy(){<span class="cstat-no" title="statement not covered" >this.listeners=new Set,this.clearStaleTimeout(),this.clearRefetchInterval(),this.currentQuery.removeObserver(this)}<span class="fstat-no" title="function not covered" ></span>se</span>tOptions(t,e){const s=<span class="cstat-no" title="statement not covered" >this.options,</span>i=<span class="cstat-no" title="statement not covered" >this.currentQuery;<span class="cstat-no" title="statement not covered" ></span>if(this.options=this.client.defaultQueryOptions(t),(0,r.VS)(s,this.options)||this.client.getQueryCache().notify({type:"observerOptionsUpdated",query:this.currentQuery,observer:this}),"undefined"!==typeof this.options.enabled&amp;&amp;"boolean"!==typeof this.options.enabled)<span class="cstat-no" title="statement not covered" >throw new Error("Expected enabled to be a boolean");<span class="cstat-no" title="statement not covered" >t</span></span>his.options.queryKey||(this.options.queryKey=s.queryKey),this.updateQuery();c</span>onst n=<span class="cstat-no" title="statement not covered" >this.hasListeners();<span class="cstat-no" title="statement not covered" ></span>n&amp;&amp;h(this.currentQuery,i,this.options,s)&amp;&amp;this.executeFetch(),this.updateResult(e),!n||this.currentQuery===i&amp;&amp;this.options.enabled===s.enabled&amp;&amp;this.options.staleTime===s.staleTime||this.updateStaleTimeout();c</span>onst u=<span class="cstat-no" title="statement not covered" >this.computeRefetchInterval();<span class="cstat-no" title="statement not covered" ></span>!n||this.currentQuery===i&amp;&amp;this.options.enabled===s.enabled&amp;&amp;u===this.currentRefetchInterval||this.updateRefetchInterval(u)}<span class="fstat-no" title="function not covered" ></span>ge</span>tOptimisticResult(t){const e=<span class="cstat-no" title="statement not covered" >this.client.getQueryCache().build(this.client,t),</span>s=<span class="cstat-no" title="statement not covered" >this.createResult(e,t);<span class="cstat-no" title="statement not covered" ></span>return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e,s){<span class="cstat-no" title="statement not covered" >if(s.keepPreviousData)<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(void 0!==s.placeholderData)<span class="cstat-no" title="statement not covered" >return e.isPlaceholderData;<span class="cstat-no" title="statement not covered" >i</span></span>f(!(0,r.VS)(t.getCurrentResult(),e))<span class="cstat-no" title="statement not covered" >return!0;<span class="cstat-no" title="statement not covered" >r</span></span>eturn!1}</span>(this,s,t)&amp;&amp;(this.currentResult=s,this.currentResultOptions=this.options,this.currentResultState=this.currentQuery.state),s}<span class="fstat-no" title="function not covered" ></span>ge</span>tCurrentResult(){<span class="cstat-no" title="statement not covered" >return this.currentResult}<span class="fstat-no" title="function not covered" ></span>tr</span>ackResult(t){const e=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>return Object.keys(t).forEach((<span class="fstat-no" title="function not covered" >s=</span>&gt;{<span class="cstat-no" title="statement not covered" >Object.defineProperty(e,s,{configurable:!1,enumerable:!0,get:<span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >this.trackedProps.add(s),t[s])</span>})}</span>)),e}<span class="fstat-no" title="function not covered" ></span>ge</span>tCurrentQuery(){<span class="cstat-no" title="statement not covered" >return this.currentQuery}<span class="fstat-no" title="function not covered" ></span>re</span>move(){<span class="cstat-no" title="statement not covered" >this.client.getQueryCache().remove(this.currentQuery)}<span class="fstat-no" title="function not covered" ></span>re</span>fetch({refetchPage:t,...e}=<span class="branch-0 cbranch-no" title="branch not covered" >{})</span>{<span class="cstat-no" title="statement not covered" >return this.fetch({...e,meta:{refetchPage:t}})}<span class="fstat-no" title="function not covered" ></span>fe</span>tchOptimistic(t){const e=<span class="cstat-no" title="statement not covered" >this.client.defaultQueryOptions(t),</span>s=<span class="cstat-no" title="statement not covered" >this.client.getQueryCache().build(this.client,e);<span class="cstat-no" title="statement not covered" ></span>return s.isFetchingOptimistic=!0,s.fetch().then((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >this.createResult(s,e))</span>)}<span class="fstat-no" title="function not covered" ></span>fe</span>tch(t){var e;<span class="cstat-no" title="statement not covered" >return this.executeFetch({...t,cancelRefetch:null==(e=t.cancelRefetch)||e}).then((<span class="fstat-no" title="function not covered" >()</span>=&gt;(<span class="cstat-no" title="statement not covered" >this.updateResult(),this.currentResult)</span>))}<span class="fstat-no" title="function not covered" ></span>ex</span>ecuteFetch(t){<span class="cstat-no" title="statement not covered" >this.updateQuery();l</span>et e=<span class="cstat-no" title="statement not covered" >this.currentQuery.fetch(this.options,t);<span class="cstat-no" title="statement not covered" ></span>return null!=t&amp;&amp;t.throwOnError||(e=e.catch(r.ZT)),e}<span class="fstat-no" title="function not covered" ></span>up</span>dateStaleTimeout(){<span class="cstat-no" title="statement not covered" >if(this.clearStaleTimeout(),r.sk||this.currentResult.isStale||!(0,r.PN)(this.options.staleTime))<span class="cstat-no" title="statement not covered" >return;c</span></span>onst t=<span class="cstat-no" title="statement not covered" >(0,r.Kp)(this.currentResult.dataUpdatedAt,this.options.staleTime)+1;<span class="cstat-no" title="statement not covered" ></span>this.staleTimeoutId=setTimeout((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >this.currentResult.isStale||this.updateResult()}</span>),t)}<span class="fstat-no" title="function not covered" ></span>co</span>mputeRefetchInterval(){var t;<span class="cstat-no" title="statement not covered" >return"function"===typeof this.options.refetchInterval?this.options.refetchInterval(this.currentResult.data,this.currentQuery):null!=(t=this.options.refetchInterval)&amp;&amp;t}<span class="fstat-no" title="function not covered" ></span>up</span>dateRefetchInterval(t){<span class="cstat-no" title="statement not covered" >this.clearRefetchInterval(),this.currentRefetchInterval=t,!r.sk&amp;&amp;!1!==this.options.enabled&amp;&amp;(0,r.PN)(this.currentRefetchInterval)&amp;&amp;0!==this.currentRefetchInterval&amp;&amp;(this.refetchIntervalId=setInterval((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >(this.options.refetchIntervalInBackground||n.j.isFocused())&amp;&amp;this.executeFetch()}</span>),this.currentRefetchInterval))}<span class="fstat-no" title="function not covered" ></span>up</span>dateTimers(){<span class="cstat-no" title="statement not covered" >this.updateStaleTimeout(),this.updateRefetchInterval(this.computeRefetchInterval())}<span class="fstat-no" title="function not covered" ></span>cl</span>earStaleTimeout(){<span class="cstat-no" title="statement not covered" >this.staleTimeoutId&amp;&amp;(clearTimeout(this.staleTimeoutId),this.staleTimeoutId=void 0)}<span class="fstat-no" title="function not covered" ></span>cl</span>earRefetchInterval(){<span class="cstat-no" title="statement not covered" >this.refetchIntervalId&amp;&amp;(clearInterval(this.refetchIntervalId),this.refetchIntervalId=void 0)}<span class="fstat-no" title="function not covered" ></span>cr</span>eateResult(t,e){const s=<span class="cstat-no" title="statement not covered" >this.currentQuery,</span>i=<span class="cstat-no" title="statement not covered" >this.options,</span>n=<span class="cstat-no" title="statement not covered" >this.currentResult,</span>u=<span class="cstat-no" title="statement not covered" >this.currentResultState,</span>a=<span class="cstat-no" title="statement not covered" >this.currentResultOptions,</span>l=<span class="cstat-no" title="statement not covered" >t!==s,</span>p=<span class="cstat-no" title="statement not covered" >l?t.state:this.currentQueryInitialState,</span>f=<span class="cstat-no" title="statement not covered" >l?this.currentResult:this.previousQueryResult,</span>{state:y}=<span class="cstat-no" title="statement not covered" >t;</span>let R,{dataUpdatedAt:v,error:m,errorUpdatedAt:b,fetchStatus:S,status:Q}=<span class="cstat-no" title="statement not covered" >y,</span>g=<span class="cstat-no" title="statement not covered" >!1,</span>I=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>if(e._optimisticResults){const r=<span class="cstat-no" title="statement not covered" >this.hasListeners(),</span>n=<span class="cstat-no" title="statement not covered" >!r&amp;&amp;c(t,e),</span>u=<span class="cstat-no" title="statement not covered" >r&amp;&amp;h(t,s,e,i);<span class="cstat-no" title="statement not covered" ></span>(n||u)&amp;&amp;(S=(0,o.Kw)(t.options.networkMode)?"fetching":"paused",v||(Q="loading")),"isRestoring"===e._optimisticResults&amp;&amp;(S="idle")}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e.keepPreviousData&amp;&amp;!y.dataUpdatedAt&amp;&amp;null!=f&amp;&amp;f.isSuccess&amp;&amp;"error"!==Q)<span class="cstat-no" title="statement not covered" >R=f.data,v=f.dataUpdatedAt,Q=f.status,g=!0;e</span>lse <span class="cstat-no" title="statement not covered" >if(e.select&amp;&amp;"undefined"!==typeof y.data)<span class="cstat-no" title="statement not covered" >if(n&amp;&amp;y.data===(null==u?void 0:u.data)&amp;&amp;e.select===this.selectFn)<span class="cstat-no" title="statement not covered" >R=this.selectResult;e</span>lse <span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >this.selectFn=e.select,R=e.select(y.data),R=(0,r.oE)(null==n?void 0:n.data,R,e),this.selectResult=R,this.selectError=null}</span>catch(T){<span class="cstat-no" title="statement not covered" >0,this.selectError=T}</span>e</span></span>lse <span class="cstat-no" title="statement not covered" >R=y.data;<span class="cstat-no" title="statement not covered" >i</span></span></span>f("undefined"!==typeof e.placeholderData&amp;&amp;"undefined"===typeof R&amp;&amp;"loading"===Q){let t;<span class="cstat-no" title="statement not covered" >if(null!=n&amp;&amp;n.isPlaceholderData&amp;&amp;e.placeholderData===(null==a?void 0:a.placeholderData))<span class="cstat-no" title="statement not covered" >t=n.data;e</span>lse <span class="cstat-no" title="statement not covered" >if(t="function"===typeof e.placeholderData?e.placeholderData():e.placeholderData,e.select&amp;&amp;"undefined"!==typeof t)<span class="cstat-no" title="statement not covered" >try{<span class="cstat-no" title="statement not covered" >t=e.select(t),this.selectError=null}</span>catch(T){<span class="cstat-no" title="statement not covered" >0,this.selectError=T}<span class="cstat-no" title="statement not covered" ></span>"</span></span></span>undefined"!==typeof t&amp;&amp;(Q="success",R=(0,r.oE)(null==n?void 0:n.data,t,e),I=!0)}<span class="cstat-no" title="statement not covered" ></span>t</span>his.selectError&amp;&amp;(m=this.selectError,R=this.selectResult,b=Date.now(),Q="error");c</span>onst E=<span class="cstat-no" title="statement not covered" >"fetching"===S,</span>C=<span class="cstat-no" title="statement not covered" >"loading"===Q,</span>O=<span class="cstat-no" title="statement not covered" >"error"===Q;<span class="cstat-no" title="statement not covered" ></span>return{status:Q,fetchStatus:S,isLoading:C,isSuccess:"success"===Q,isError:O,isInitialLoading:C&amp;&amp;E,data:R,dataUpdatedAt:v,error:m,errorUpdatedAt:b,failureCount:y.fetchFailureCount,failureReason:y.fetchFailureReason,errorUpdateCount:y.errorUpdateCount,isFetched:y.dataUpdateCount&gt;0||y.errorUpdateCount&gt;0,isFetchedAfterMount:y.dataUpdateCount&gt;p.dataUpdateCount||y.errorUpdateCount&gt;p.errorUpdateCount,isFetching:E,isRefetching:E&amp;&amp;!C,isLoadingError:O&amp;&amp;0===y.dataUpdatedAt,isPaused:"paused"===S,isPlaceholderData:I,isPreviousData:g,isRefetchError:O&amp;&amp;0!==y.dataUpdatedAt,isStale:d(t,e),refetch:this.refetch,remove:this.remove}}<span class="fstat-no" title="function not covered" ></span>up</span>dateResult(t){const e=<span class="cstat-no" title="statement not covered" >this.currentResult,</span>s=<span class="cstat-no" title="statement not covered" >this.createResult(this.currentQuery,this.options);<span class="cstat-no" title="statement not covered" ></span>if(this.currentResultState=this.currentQuery.state,this.currentResultOptions=this.options,(0,r.VS)(s,e))<span class="cstat-no" title="statement not covered" >return;<span class="cstat-no" title="statement not covered" >t</span></span>his.currentResult=s;c</span>onst i=<span class="cstat-no" title="statement not covered" >{cache:!0};<span class="cstat-no" title="statement not covered" ></span>!1!==(null==t?void 0:t.listeners)&amp;&amp;(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(!e)<span class="cstat-no" title="statement not covered" >return!0;c</span></span>onst{notifyOnChangeProps:t}=<span class="cstat-no" title="statement not covered" >this.options,</span>s=<span class="cstat-no" title="statement not covered" >"function"===typeof t?t():t;<span class="cstat-no" title="statement not covered" ></span>if("all"===s||!s&amp;&amp;!this.trackedProps.size)<span class="cstat-no" title="statement not covered" >return!0;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >new Set(null!=s?s:this.trackedProps);<span class="cstat-no" title="statement not covered" ></span>return this.options.useErrorBoundary&amp;&amp;r.add("error"),Object.keys(this.currentResult).some((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >t;<span class="cstat-no" title="statement not covered" ></span>return this.currentResult[s]!==e[s]&amp;&amp;r.has(s)}</span>))}</span>)()&amp;&amp;(i.listeners=!0),this.notify({...i,...t})}<span class="fstat-no" title="function not covered" ></span>up</span>dateQuery(){const t=<span class="cstat-no" title="statement not covered" >this.client.getQueryCache().build(this.client,this.options);<span class="cstat-no" title="statement not covered" ></span>if(t===this.currentQuery)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >this.currentQuery;<span class="cstat-no" title="statement not covered" ></span>this.currentQuery=t,this.currentQueryInitialState=t.state,this.previousQueryResult=this.currentResult,this.hasListeners()&amp;&amp;(null==e||e.removeObserver(this),t.addObserver(this))}<span class="fstat-no" title="function not covered" ></span>on</span>QueryUpdate(t){const e=<span class="cstat-no" title="statement not covered" >{};<span class="cstat-no" title="statement not covered" ></span>"success"===t.type?e.onSuccess=!t.manual:"error"!==t.type||(0,o.DV)(t.error)||(e.onError=!0),this.updateResult(e),this.hasListeners()&amp;&amp;this.updateTimers()}<span class="fstat-no" title="function not covered" ></span>no</span>tify(t){<span class="cstat-no" title="statement not covered" >i.V.batch((<span class="fstat-no" title="function not covered" >()</span>=&gt;{var e,s,r,i;<span class="cstat-no" title="statement not covered" >if(t.onSuccess)<span class="cstat-no" title="statement not covered" >null==(e=(s=this.options).onSuccess)||e.call(s,this.currentResult.data),null==(r=(i=this.options).onSettled)||r.call(i,this.currentResult.data,null);e</span>lse <span class="cstat-no" title="statement not covered" >if(t.onError){var n,u,o,a;<span class="cstat-no" title="statement not covered" >null==(n=(u=this.options).onError)||n.call(u,this.currentResult.error),null==(o=(a=this.options).onSettled)||o.call(a,void 0,this.currentResult.error)}<span class="cstat-no" title="statement not covered" ></span>t</span></span>.listeners&amp;&amp;this.listeners.forEach((<span class="fstat-no" title="function not covered" >({</span>listener:t})=&gt;{<span class="cstat-no" title="statement not covered" >t(this.currentResult)}</span>)),t.cache&amp;&amp;this.client.getQueryCache().notify({query:this.currentQuery,type:"observerResultsUpdated"})}</span>))}</span>}function <span class="fstat-no" title="function not covered" >c(</span>t,e){<span class="cstat-no" title="statement not covered" >return <span class="fstat-no" title="function not covered" >fu</span>nction(t,e){<span class="cstat-no" title="statement not covered" >return!1!==e.enabled&amp;&amp;!t.state.dataUpdatedAt&amp;&amp;!("error"===t.state.status&amp;&amp;!1===e.retryOnMount)}</span>(t,e)||t.state.dataUpdatedAt&gt;0&amp;&amp;l(t,e,e.refetchOnMount)}</span>function <span class="fstat-no" title="function not covered" >l(</span>t,e,s){<span class="cstat-no" title="statement not covered" >if(!1!==e.enabled){const r=<span class="cstat-no" title="statement not covered" >"function"===typeof s?s(t):s;<span class="cstat-no" title="statement not covered" ></span>return"always"===r||!1!==r&amp;&amp;d(t,e)}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn!1}</span>function <span class="fstat-no" title="function not covered" >h(</span>t,e,s,r){<span class="cstat-no" title="statement not covered" >return!1!==s.enabled&amp;&amp;(t!==e||!1===r.enabled)&amp;&amp;(!s.suspense||"error"!==t.state.status)&amp;&amp;d(t,s)}</span>function <span class="fstat-no" title="function not covered" >d(</span>t,e){<span class="cstat-no" title="statement not covered" >return t.isStaleByTime(e.staleTime)}</span>var p=<span class="cstat-no" title="statement not covered" >s(9885),</span>f=<span class="cstat-no" title="statement not covered" >s(51214);</span>function <span class="fstat-no" title="function not covered" >y(</span>){let t=<span class="cstat-no" title="statement not covered" >!1;<span class="cstat-no" title="statement not covered" ></span>return{clearReset:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t=!1}</span>,reset:<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t=!0}</span>,isReset:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >t}</span>}</span>const R=<span class="cstat-no" title="statement not covered" >p.createContext(y());</span>var v=<span class="cstat-no" title="statement not covered" >s(212);</span>const m=<span class="cstat-no" title="statement not covered" >p.createContext(!1);<span class="cstat-no" title="statement not covered" ></span>m.Provider;v</span>ar b=<span class="cstat-no" title="statement not covered" >s(94713);</span>function <span class="fstat-no" title="function not covered" >S(</span>t,e){const s=<span class="cstat-no" title="statement not covered" >(0,v.NL)({context:t.context}),</span>r=<span class="cstat-no" title="statement not covered" >p.useContext(m),</span>n=<span class="cstat-no" title="statement not covered" >p.useContext(R),</span>u=<span class="cstat-no" title="statement not covered" >s.defaultQueryOptions(t);<span class="cstat-no" title="statement not covered" ></span>u._optimisticResults=r?"isRestoring":"optimistic",u.onError&amp;&amp;(u.onError=i.V.batchCalls(u.onError)),u.onSuccess&amp;&amp;(u.onSuccess=i.V.batchCalls(u.onSuccess)),u.onSettled&amp;&amp;(u.onSettled=i.V.batchCalls(u.onSettled)),(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.suspense&amp;&amp;("number"!==typeof t.staleTime&amp;&amp;(t.staleTime=1e3),"number"===typeof t.cacheTime&amp;&amp;(t.cacheTime=Math.max(t.cacheTime,1e3)))}</span>)(u),(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;{<span class="cstat-no" title="statement not covered" >(t.suspense||t.useErrorBoundary)&amp;&amp;(e.isReset()||(t.retryOnMount=!1))}</span>)(u,n),(<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >p.useEffect((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.clearReset()}</span>),[t])}</span>)(n);c</span>onst[o]=<span class="cstat-no" title="statement not covered" >p.useState((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >new e(s,u))</span>),</span>a=<span class="cstat-no" title="statement not covered" >o.getOptimisticResult(u);<span class="cstat-no" title="statement not covered" ></span>if((0,f.$)(p.useCallback((<span class="fstat-no" title="function not covered" >t=</span>&gt;{const e=<span class="cstat-no" title="statement not covered" >r?<span class="fstat-no" title="function not covered" >()</span>=&gt;{}:o.subscribe(i.V.batchCalls(t));<span class="cstat-no" title="statement not covered" ></span>return o.updateResult(),e}</span>),[o,r]),(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >o.getCurrentResult())</span>,(<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >o.getCurrentResult())</span>),p.useEffect((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >o.setOptions(u,{listeners:!1})}</span>),[u,o]),(<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;<span class="cstat-no" title="statement not covered" >(null==t?void 0:t.suspense)&amp;&amp;(<span class="fstat-no" title="function not covered" >(t</span>,e)=&gt;<span class="cstat-no" title="statement not covered" >t.isLoading&amp;&amp;t.isFetching&amp;&amp;!e)</span>(e,s))</span>(u,a,r))<span class="cstat-no" title="statement not covered" >throw(<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;<span class="cstat-no" title="statement not covered" >e.fetchOptimistic(t).then((<span class="fstat-no" title="function not covered" >({</span>data:e})=&gt;{<span class="cstat-no" title="statement not covered" >null==t.onSuccess||t.onSuccess(e),null==t.onSettled||t.onSettled(e,null)}</span>)).catch((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >s.clearReset(),null==t.onError||t.onError(e),null==t.onSettled||t.onSettled(void 0,e)}</span>)))</span>(u,o,n);<span class="cstat-no" title="statement not covered" >i</span></span>f((<span class="fstat-no" title="function not covered" >({</span>result:t,errorResetBoundary:e,useErrorBoundary:s,query:r})=&gt;<span class="cstat-no" title="statement not covered" >t.isError&amp;&amp;!e.isReset()&amp;&amp;!t.isFetching&amp;&amp;(0,b.L)(s,[t.error,r]))</span>({result:a,errorResetBoundary:n,useErrorBoundary:u.useErrorBoundary,query:o.getCurrentQuery()}))<span class="cstat-no" title="statement not covered" >throw a.error;<span class="cstat-no" title="statement not covered" >r</span></span>eturn u.notifyOnChangeProps?a:o.trackResult(a)}</span>function <span class="fstat-no" title="function not covered" >Q(</span>t,e,s){<span class="cstat-no" title="statement not covered" >return S((0,r._v)(t,e,s),a)}</span>},51214:<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{<span class="cstat-no" title="statement not covered" >s.d(e,{$:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >r}</span>);c</span>onst r=<span class="cstat-no" title="statement not covered" >s(61928).useSyncExternalStore}</span>,94713:<span class="fstat-no" title="function not covered" >(t</span>,e,s)=&gt;{function <span class="fstat-no" title="function not covered" >r(</span>t,e){<span class="cstat-no" title="statement not covered" >return"function"===typeof t?t(...e):!!t}<span class="cstat-no" title="statement not covered" ></span>s.d(e,{L:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >r}</span>)}</span>};</span></pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2025-11-10T08:07:38.115Z
            </div>
        <script src="../../../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../../../sorter.js"></script>
        <script src="../../../../../block-navigation.js"></script>
    </body>
</html>
    