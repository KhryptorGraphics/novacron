
<!doctype html>
<html lang="en">

<head>
    <title>Code coverage report for novacron/frontend/.next/static/chunks/3787-a3537fe9bcd33bdb.js</title>
    <meta charset="utf-8" />
    <link rel="stylesheet" href="../../../../../prettify.css" />
    <link rel="stylesheet" href="../../../../../base.css" />
    <link rel="shortcut icon" type="image/x-icon" href="../../../../../favicon.png" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <style type='text/css'>
        .coverage-summary .sorter {
            background-image: url(../../../../../sort-arrow-sprite.png);
        }
    </style>
</head>
    
<body>
<div class='wrapper'>
    <div class='pad1'>
        <h1><a href="../../../../../index.html">All files</a> / <a href="index.html">novacron/frontend/.next/static/chunks</a> 3787-a3537fe9bcd33bdb.js</h1>
        <div class='clearfix'>
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Statements</span>
                <span class='fraction'>0/341</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Branches</span>
                <span class='fraction'>0/305</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Functions</span>
                <span class='fraction'>0/69</span>
            </div>
        
            
            <div class='fl pad1y space-right2'>
                <span class="strong">0% </span>
                <span class="quiet">Lines</span>
                <span class='fraction'>0/1</span>
            </div>
        
            
        </div>
        <p class="quiet">
            Press <em>n</em> or <em>j</em> to go to the next uncovered block, <em>b</em>, <em>p</em> or <em>k</em> for the previous block.
        </p>
        <template id="filterTemplate">
            <div class="quiet">
                Filter:
                <input type="search" id="fileSearch">
            </div>
        </template>
    </div>
    <div class='status-line low'></div>
    <pre><table class="coverage">
<tr><td class="line-count quiet"><a name='L1'></a><a href='#L1'>1</a></td><td class="line-coverage quiet"><span class="cline-any cline-no">&nbsp;</span></td><td class="text"><pre class="prettyprint lang-js">"use strict";<span class="cstat-no" title="statement not covered" >(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[3787],{33787:<span class="fstat-no" title="function not covered" >fu</span>nction(e,t,s){<span class="cstat-no" title="statement not covered" >s.r(t),s.d(t,{NetworkTopology:<span class="fstat-no" title="function not covered" >fu</span>nction(){<span class="cstat-no" title="statement not covered" >return f}</span>});v</span>ar i=<span class="cstat-no" title="statement not covered" >s(57437),</span>n=<span class="cstat-no" title="statement not covered" >s(2265),</span>a=<span class="cstat-no" title="statement not covered" >s(10609),</span>r=<span class="cstat-no" title="statement not covered" >s(41735),</span>l=<span class="cstat-no" title="statement not covered" >s(40150),</span>c=<span class="cstat-no" title="statement not covered" >s(3089),</span>o=<span class="cstat-no" title="statement not covered" >s(8031),</span>h=<span class="cstat-no" title="statement not covered" >s(28956),</span>d=<span class="cstat-no" title="statement not covered" >s(90998),</span>u=<span class="cstat-no" title="statement not covered" >s(26714);</span>const f=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{let{data:t,title:s=<span class="branch-0 cbranch-no" title="branch not covered" >"Network Topology",</span>description:f,height:x=<span class="branch-0 cbranch-no" title="branch not covered" >400,</span>showDistributed:m=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>showBandwidth:g=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>showPerformanceMetrics:y=<span class="branch-0 cbranch-no" title="branch not covered" >!1,</span>autoRefresh:v=<span class="branch-0 cbranch-no" title="branch not covered" >!0,</span>refreshInterval:p=<span class="branch-0 cbranch-no" title="branch not covered" >5e3,</span>onNodeClick:w,onEdgeClick:M,onClusterClick:b}=<span class="cstat-no" title="statement not covered" >e;</span>const j=<span class="cstat-no" title="statement not covered" >(0,n.useRef)(null),</span>k=<span class="cstat-no" title="statement not covered" >(0,n.useRef)(),</span>[N,E]=<span class="cstat-no" title="statement not covered" >n.useState("force"),</span>[S,C]=<span class="cstat-no" title="statement not covered" >n.useState(null),</span>[P,I]=<span class="cstat-no" title="statement not covered" >n.useState(null),</span>[L,z]=<span class="cstat-no" title="statement not covered" >n.useState(!0),</span>[W,D]=<span class="cstat-no" title="statement not covered" >n.useState("medium"),</span>[H,O]=<span class="cstat-no" title="statement not covered" >n.useState(new Set),</span>[T,A]=<span class="cstat-no" title="statement not covered" >n.useState(m),</span>[B,F]=<span class="cstat-no" title="statement not covered" >n.useState(g),</span>[R,q]=<span class="cstat-no" title="statement not covered" >n.useState(y);<span class="cstat-no" title="statement not covered" ></span>(0,n.useEffect)((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >A(m))</span>,[m]),(0,n.useEffect)((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >F(g))</span>,[g]),(0,n.useEffect)((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >q(y))</span>,[y]);c</span>onst{data:Q,isConnected:U}=<span class="cstat-no" title="statement not covered" >T?(0,o.lt)():{data:null,isConnected:!1},</span>V=<span class="cstat-no" title="statement not covered" >n.useMemo((<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >Q&amp;&amp;T?Q:t||{nodes:[],edges:[],clusters:[]})</span>,[Q,t,T]);<span class="cstat-no" title="statement not covered" ></span>return(0,n.useEffect)((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(!j.current||!V.nodes.length)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst e=<span class="cstat-no" title="statement not covered" >j.current,</span>t=<span class="cstat-no" title="statement not covered" >e.getContext("2d");<span class="cstat-no" title="statement not covered" ></span>if(!t)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst s=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{const s=<span class="cstat-no" title="statement not covered" >window.devicePixelRatio||1;<span class="cstat-no" title="statement not covered" ></span>e.width=Math.floor(e.clientWidth*s),e.height=Math.floor(e.clientHeight*s),e.style.width=e.clientWidth+"px",e.style.height=e.clientHeight+"px",t.scale(s,s)}</span>;<span class="cstat-no" title="statement not covered" ></span>window.addEventListener("resize",s),s();c</span>onst i=<span class="cstat-no" title="statement not covered" >new Map;<span class="cstat-no" title="statement not covered" ></span>(<span class="fstat-no" title="function not covered" >()</span>=&gt;{const t=<span class="cstat-no" title="statement not covered" >e.clientWidth,</span>s=<span class="cstat-no" title="statement not covered" >e.clientHeight;<span class="cstat-no" title="statement not covered" ></span>V.nodes.forEach((<span class="fstat-no" title="function not covered" >(e</span>,n)=&gt;{let a,r;<span class="cstat-no" title="statement not covered" >switch(N){case"circular":const i=<span class="cstat-no" title="statement not covered" >n/V.nodes.length*2*Math.PI,</span>l=<span class="cstat-no" title="statement not covered" >.3*Math.min(t,s);<span class="cstat-no" title="statement not covered" ></span>a=t/2+Math.cos(i)*l,r=s/2+Math.sin(i)*l;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"hierarchical":<span class="cstat-no" title="statement not covered" >new Map;l</span>et c=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>c="cluster"===e.type?0:"host"===e.type?1:"vm"===e.type?2:3;c</span>onst o=<span class="cstat-no" title="statement not covered" >V.nodes.filter((<span class="fstat-no" title="function not covered" >e=</span>&gt;{let t=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>return t="cluster"===e.type?0:"host"===e.type?1:"vm"===e.type?2:3,t===c}</span>)),</span>h=<span class="cstat-no" title="statement not covered" >o.findIndex((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.id===e.id)</span>);<span class="cstat-no" title="statement not covered" ></span>a=t/(o.length+1)*(h+1),r=s/5*(c+1);<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"geographic":const d=<span class="cstat-no" title="statement not covered" >{"us-east-1":{x:.8*t,y:.3*s},"us-west-2":{x:.2*t,y:.4*s},"eu-west-1":{x:.6*t,y:.2*s},"ap-southeast-1":{x:.9*t,y:.7*s}}[e.region];<span class="cstat-no" title="statement not covered" ></span>a=(null===d||void 0===d?void 0:d.x)||Math.random()*t,r=(null===d||void 0===d?void 0:d.y)||Math.random()*s;<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"clustered":<span class="cstat-no" title="statement not covered" >if(e.clusterId&amp;&amp;V.clusters){const i=<span class="cstat-no" title="statement not covered" >V.clusters.find((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.id===e.clusterId)</span>);<span class="cstat-no" title="statement not covered" ></span>(null===i||void 0===i?void 0:i.bounds)?(a=i.bounds.x+Math.random()*i.bounds.width,r=i.bounds.y+Math.random()*i.bounds.height):(a=Math.random()*t,r=Math.random()*s)}</span>else <span class="cstat-no" title="statement not covered" >a=Math.random()*t,r=Math.random()*s;<span class="cstat-no" title="statement not covered" >b</span></span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >a=Math.random()*t,r=Math.random()*s}<span class="cstat-no" title="statement not covered" ></span>i</span>.set(e.id,{x:a,y:r,vx:0,vy:0})}</span>))}</span>)();c</span>onst n=<span class="cstat-no" title="statement not covered" >{vm:"#4f46e5",host:"#0891b2",storage:"#7c3aed",network:"#2563eb",service:"#059669",cluster:"#f59e0b",federation:"#ec4899"},</span>a=<span class="cstat-no" title="statement not covered" >{healthy:"#10b981",warning:"#f59e0b",error:"#ef4444",unknown:"#6b7280"},</span>r=<span class="cstat-no" title="statement not covered" >{network:"rgba(37, 99, 235, 0.5)",storage:"rgba(124, 58, 237, 0.5)",dependency:"rgba(156, 163, 175, 0.5)",cluster:"rgba(245, 158, 11, 0.5)",federation:"rgba(236, 72, 153, 0.5)",migration:"rgba(34, 197, 94, 0.5)"},</span>l=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{var t;<span class="cstat-no" title="statement not covered" >if(!B||!(null===(t=e.metrics)||void 0===t?void 0:t.bandwidth))<span class="cstat-no" title="statement not covered" >return 1;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >Math.max(1,Math.min(8,e.metrics.bandwidth/10));<span class="cstat-no" title="statement not covered" ></span>return e.metrics.utilization?s*(e.metrics.utilization/100):s}</span>,</span>c=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(!e.bounds||!T)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst{x:s,y:i,width:n,height:a}=<span class="cstat-no" title="statement not covered" >e.bounds;<span class="cstat-no" title="statement not covered" ></span>t.strokeStyle="rgba(245, 158, 11, 0.3)",t.lineWidth=2,t.setLineDash([5,5]),t.strokeRect(s,i,n,a),t.setLineDash([]),t.font="12px sans-serif",t.fillStyle="#f59e0b",t.textAlign="left",t.fillText("".concat(e.name," (").concat(e.region,")"),s+5,i-5);c</span>onst r=<span class="cstat-no" title="statement not covered" >{healthy:"#10b981",degraded:"#f59e0b",error:"#ef4444"}[e.status];<span class="cstat-no" title="statement not covered" ></span>t.fillStyle=r,t.beginPath(),t.arc(s+n-10,i+10,5,0,2*Math.PI),t.fill()}</span>,</span>o=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,s)=&gt;{const i=<span class="cstat-no" title="statement not covered" >"host"===e.type||"cluster"===e.type?15:10;<span class="cstat-no" title="statement not covered" ></span>t.beginPath(),t.arc(s.x,s.y,i,0,2*Math.PI),t.fillStyle=n[e.type],t.fill(),t.beginPath(),t.arc(s.x,s.y,i+3,0,2*Math.PI),t.strokeStyle=a[e.status],t.lineWidth=2,t.stroke(),L&amp;&amp;(t.font="10px sans-serif",t.fillStyle="#ffffff",t.textAlign="center",t.textBaseline="middle",t.fillText(e.name.substring(0,2),s.x,s.y),t.font="10px sans-serif",t.fillStyle="#374151",t.textAlign="center",t.textBaseline="top",t.fillText(e.name,s.x,s.y+i+5)),R&amp;&amp;e.metrics&amp;&amp;"low"!==W&amp;&amp;(t.font="9px sans-serif",t.fillStyle="#6b7280",t.textAlign="center",void 0!==e.metrics.cpuUsage&amp;&amp;t.fillText("CPU: ".concat(e.metrics.cpuUsage,"%"),s.x,s.y+i+18),void 0!==e.metrics.memoryUsage&amp;&amp;"high"===W&amp;&amp;t.fillText("Mem: ".concat(e.metrics.memoryUsage,"%"),s.x,s.y+i+28)),"migrating"===e.status&amp;&amp;(t.strokeStyle="rgba(34, 197, 94, 0.8)",t.lineWidth=3,t.setLineDash([2,2]),t.beginPath(),t.arc(s.x,s.y,i+6,0,2*Math.PI),t.stroke(),t.setLineDash([]))}</span>,</span>h=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >(e</span>,s,i)=&gt;{var n;const a=<span class="cstat-no" title="statement not covered" >B&amp;&amp;(null===(n=e.metrics)||void 0===n?void 0:n.utilization)?(c=e.metrics.utilization)?c&gt;80?"rgba(239, 68, 68, 0.7)":c&gt;60?"rgba(245, 158, 11, 0.7)":"rgba(34, 197, 94, 0.7)":r.network:r[e.type];</span>var c;<span class="cstat-no" title="statement not covered" >if(t.beginPath(),t.moveTo(s.x,s.y),t.lineTo(i.x,i.y),t.strokeStyle=a,t.lineWidth=l(e),"dependency"===e.type?t.setLineDash([5,3]):t.setLineDash([]),t.stroke(),t.setLineDash([]),R&amp;&amp;e.metrics&amp;&amp;"low"!==W){const n=<span class="cstat-no" title="statement not covered" >(s.x+i.x)/2,</span>a=<span class="cstat-no" title="statement not covered" >(s.y+i.y)/2;<span class="cstat-no" title="statement not covered" ></span>t.font="9px sans-serif",t.fillStyle="#6b7280",t.textAlign="center",t.textBaseline="middle";c</span>onst r=<span class="cstat-no" title="statement not covered" >[];<span class="cstat-no" title="statement not covered" ></span>if(e.metrics.latency&amp;&amp;r.push("".concat(e.metrics.latency.toFixed(1),"ms")),B&amp;&amp;e.metrics.bandwidth&amp;&amp;r.push("".concat(e.metrics.bandwidth,"Mbps")),e.metrics.utilization&amp;&amp;"high"===W&amp;&amp;r.push("".concat(e.metrics.utilization,"%")),r.length&gt;0&amp;&amp;t.fillText(r.join(" | "),n,a-8),e.metrics.qos){const s=<span class="cstat-no" title="statement not covered" >{high:"#10b981",medium:"#f59e0b",low:"#ef4444"}[e.metrics.qos];<span class="cstat-no" title="statement not covered" ></span>t.fillStyle=s,t.beginPath(),t.arc(n,a+8,3,0,2*Math.PI),t.fill()}</span>}<span class="cstat-no" title="statement not covered" ></span>i</span>f(e.animated||"migration"===e.type){const e=<span class="cstat-no" title="statement not covered" >t.createLinearGradient(s.x,s.y,i.x,i.y);<span class="cstat-no" title="statement not covered" ></span>e.addColorStop(0,"rgba(34, 197, 94, 0)"),e.addColorStop(.5,"rgba(34, 197, 94, 0.8)"),e.addColorStop(1,"rgba(34, 197, 94, 0)"),t.strokeStyle=e,t.lineWidth=2,t.stroke()}</span>}</span>;</span>class d{<span class="fstat-no" title="function not covered" >in</span>sert(e,t){<span class="cstat-no" title="statement not covered" >if(!this.contains(t.x,t.y))<span class="cstat-no" title="statement not covered" >return!1;<span class="cstat-no" title="statement not covered" >i</span></span>f(0===this.nodes.length&amp;&amp;0===this.children.length)<span class="cstat-no" title="statement not covered" >return this.nodes.push({node:e,position:t}),this.updateCenterOfMass(),!0;<span class="cstat-no" title="statement not covered" >i</span></span>f(0===this.children.length){<span class="cstat-no" title="statement not covered" >this.subdivide();<span class="cstat-no" title="statement not covered" >f</span>or(const e of this.nodes)<span class="cstat-no" title="statement not covered" >for(const t of this.children)<span class="cstat-no" title="statement not covered" >if(t.insert(e.node,e.position))<span class="cstat-no" title="statement not covered" >break;<span class="cstat-no" title="statement not covered" >t</span></span></span></span>his.nodes=[]}<span class="cstat-no" title="statement not covered" ></span>f</span>or(const s of this.children)<span class="cstat-no" title="statement not covered" >if(s.insert(e,t))<span class="cstat-no" title="statement not covered" >return this.updateCenterOfMass(),!0;<span class="cstat-no" title="statement not covered" >r</span></span></span>eturn!1}<span class="fstat-no" title="function not covered" ></span>co</span>ntains(e,t){<span class="cstat-no" title="statement not covered" >return e&gt;=this.x&amp;&amp;e&lt;this.x+this.width&amp;&amp;t&gt;=this.y&amp;&amp;t&lt;this.y+this.height}<span class="fstat-no" title="function not covered" ></span>su</span>bdivide(){const e=<span class="cstat-no" title="statement not covered" >this.width/2,</span>t=<span class="cstat-no" title="statement not covered" >this.height/2;<span class="cstat-no" title="statement not covered" ></span>this.children.push(new d(this.x,this.y,e,t),new d(this.x+e,this.y,e,t),new d(this.x,this.y+t,e,t),new d(this.x+e,this.y+t,e,t))}<span class="fstat-no" title="function not covered" ></span>up</span>dateCenterOfMass(){let e=<span class="cstat-no" title="statement not covered" >0,</span>t=<span class="cstat-no" title="statement not covered" >0,</span>s=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(const{position:i}of this.nodes)<span class="cstat-no" title="statement not covered" >e+=i.x,t+=i.y,s+=1;<span class="cstat-no" title="statement not covered" >f</span></span>or(const i of this.children)<span class="cstat-no" title="statement not covered" >e+=i.centerOfMass.x*i.totalMass,t+=i.centerOfMass.y*i.totalMass,s+=i.totalMass;<span class="cstat-no" title="statement not covered" >s</span></span>&gt;0&amp;&amp;(this.centerOfMass.x=e/s,this.centerOfMass.y=t/s),this.totalMass=s}<span class="fstat-no" title="function not covered" ></span>ca</span>lculateForce(e){let t=<span class="cstat-no" title="statement not covered" >arguments.length&gt;1&amp;&amp;void 0!==arguments[1]?arguments[1]:.5;<span class="cstat-no" title="statement not covered" ></span>if(0===this.totalMass)<span class="cstat-no" title="statement not covered" >return{fx:0,fy:0};c</span></span>onst s=<span class="cstat-no" title="statement not covered" >this.centerOfMass.x-e.x,</span>i=<span class="cstat-no" title="statement not covered" >this.centerOfMass.y-e.y,</span>n=<span class="cstat-no" title="statement not covered" >Math.sqrt(s*s+i*i);<span class="cstat-no" title="statement not covered" ></span>if(0===n)<span class="cstat-no" title="statement not covered" >return{fx:0,fy:0};c</span></span>onst a=<span class="cstat-no" title="statement not covered" >Math.max(this.width,this.height);<span class="cstat-no" title="statement not covered" ></span>if(0===this.children.length||a/n&lt;t){const e=<span class="cstat-no" title="statement not covered" >1e3/(n*n);<span class="cstat-no" title="statement not covered" ></span>return{fx:s/n*e,fy:i/n*e}}</span>l</span>et r=<span class="cstat-no" title="statement not covered" >0,</span>l=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>for(const c of this.children){const s=<span class="cstat-no" title="statement not covered" >c.calculateForce(e,t);<span class="cstat-no" title="statement not covered" ></span>r+=s.fx,l+=s.fy}<span class="cstat-no" title="statement not covered" ></span>r</span>eturn{fx:r,fy:l}}<span class="fstat-no" title="function not covered" ></span>co</span>nstructor(e,t,s,i){<span class="cstat-no" title="statement not covered" >this.x=e,this.y=t,this.width=s,this.height=i,this.nodes=[],this.centerOfMass={x:0,y:0},this.totalMass=0,this.children=[]}</span>}const u=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >t.clearRect(0,0,e.width,e.height),V.clusters&amp;&amp;T&amp;&amp;V.clusters.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const t=<span class="cstat-no" title="statement not covered" >V.nodes.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.clusterId===e.id)</span>);<span class="cstat-no" title="statement not covered" ></span>if(t.length&gt;0){const s=<span class="cstat-no" title="statement not covered" >t.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >i.get(e.id))</span>).filter(Boolean);<span class="cstat-no" title="statement not covered" ></span>if(s.length&gt;0){const t=<span class="cstat-no" title="statement not covered" >Math.min(...s.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.x)</span>))-50,</span>i=<span class="cstat-no" title="statement not covered" >Math.max(...s.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.x)</span>))+50,</span>n=<span class="cstat-no" title="statement not covered" >Math.min(...s.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.y)</span>))-50,</span>a=<span class="cstat-no" title="statement not covered" >Math.max(...s.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.y)</span>))+50;<span class="cstat-no" title="statement not covered" ></span>e.bounds={x:t,y:n,width:i-t,height:a-n}}</span>}<span class="cstat-no" title="statement not covered" ></span>c</span>(e)}</span>));c</span>onst s=<span class="cstat-no" title="statement not covered" >V.nodes.length&gt;100?3:10,</span>n=<span class="cstat-no" title="statement not covered" >V.nodes.length&gt;100;<span class="cstat-no" title="statement not covered" ></span>for(let t=<span class="cstat-no" title="statement not covered" >0;</span>t&lt;s;t++){<span class="cstat-no" title="statement not covered" >if(n){const t=<span class="cstat-no" title="statement not covered" >new d(0,0,e.clientWidth,e.clientHeight);<span class="cstat-no" title="statement not covered" ></span>V.nodes.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >i.get(e.id);<span class="cstat-no" title="statement not covered" ></span>s&amp;&amp;t.insert(e,s)}</span>)),V.nodes.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >i.get(e.id);<span class="cstat-no" title="statement not covered" ></span>if(s){const e=<span class="cstat-no" title="statement not covered" >t.calculateForce(s);<span class="cstat-no" title="statement not covered" ></span>s.vx-=e.fx,s.vy-=e.fy}</span>}</span>))}</span>else <span class="cstat-no" title="statement not covered" >V.nodes.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{<span class="cstat-no" title="statement not covered" >V.nodes.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >if(e.id===t.id)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >i.get(e.id),</span>n=<span class="cstat-no" title="statement not covered" >i.get(t.id),</span>a=<span class="cstat-no" title="statement not covered" >n.x-s.x,</span>r=<span class="cstat-no" title="statement not covered" >n.y-s.y,</span>l=<span class="cstat-no" title="statement not covered" >Math.sqrt(a*a+r*r);<span class="cstat-no" title="statement not covered" ></span>if(0===l)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst c=<span class="cstat-no" title="statement not covered" >1e3/(l*l),</span>o=<span class="cstat-no" title="statement not covered" >a/l*c,</span>h=<span class="cstat-no" title="statement not covered" >r/l*c;<span class="cstat-no" title="statement not covered" ></span>s.vx-=o,s.vy-=h,n.vx+=o,n.vy+=h}</span>))}</span>));<span class="cstat-no" title="statement not covered" >V</span></span>.edges.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const t=<span class="cstat-no" title="statement not covered" >i.get(e.source),</span>s=<span class="cstat-no" title="statement not covered" >i.get(e.target);<span class="cstat-no" title="statement not covered" ></span>if(!t||!s)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst n=<span class="cstat-no" title="statement not covered" >s.x-t.x,</span>a=<span class="cstat-no" title="statement not covered" >s.y-t.y,</span>r=<span class="cstat-no" title="statement not covered" >Math.sqrt(n*n+a*a);<span class="cstat-no" title="statement not covered" ></span>if(0===r)<span class="cstat-no" title="statement not covered" >return;c</span></span>onst l=<span class="cstat-no" title="statement not covered" >.01*(r-100),</span>c=<span class="cstat-no" title="statement not covered" >n/r*l,</span>o=<span class="cstat-no" title="statement not covered" >a/r*l;<span class="cstat-no" title="statement not covered" ></span>t.vx+=c,t.vy+=o,s.vx-=c,s.vy-=o}</span>)),i.forEach((<span class="fstat-no" title="function not covered" >t=</span>&gt;{<span class="cstat-no" title="statement not covered" >t.x+=.1*t.vx,t.y+=.1*t.vy,t.vx*=.9,t.vy*=.9,t.x=Math.max(50,Math.min(e.clientWidth-50,t.x)),t.y=Math.max(50,Math.min(e.clientHeight-50,t.y))}</span>))}<span class="cstat-no" title="statement not covered" ></span>V</span>.edges.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const t=<span class="cstat-no" title="statement not covered" >i.get(e.source),</span>s=<span class="cstat-no" title="statement not covered" >i.get(e.target);<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;s&amp;&amp;h(e,t,s)}</span>)),V.nodes.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const t=<span class="cstat-no" title="statement not covered" >i.get(e.id);<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;o(e,t)}</span>)),"force"===N&amp;&amp;(k.current=requestAnimationFrame(u))}</span>;<span class="cstat-no" title="statement not covered" ></span>(<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >if(k.current&amp;&amp;cancelAnimationFrame(k.current),"force"===N)<span class="cstat-no" title="statement not covered" >u();e</span>lse{let s;<span class="cstat-no" title="statement not covered" >switch(N){case"circular":<span class="cstat-no" title="statement not covered" >s=(<span class="fstat-no" title="function not covered" >()</span>=&gt;{const t=<span class="cstat-no" title="statement not covered" >e.clientWidth,</span>s=<span class="cstat-no" title="statement not covered" >e.clientHeight,</span>i=<span class="cstat-no" title="statement not covered" >.3*Math.min(t,s),</span>n=<span class="cstat-no" title="statement not covered" >new Map;<span class="cstat-no" title="statement not covered" ></span>return V.nodes.forEach((<span class="fstat-no" title="function not covered" >(e</span>,a)=&gt;{const r=<span class="cstat-no" title="statement not covered" >a/V.nodes.length*2*Math.PI,</span>l=<span class="cstat-no" title="statement not covered" >t/2+Math.cos(r)*i,</span>c=<span class="cstat-no" title="statement not covered" >s/2+Math.sin(r)*i;<span class="cstat-no" title="statement not covered" ></span>n.set(e.id,{x:l,y:c,vx:0,vy:0})}</span>)),n}</span>)();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"hierarchical":<span class="cstat-no" title="statement not covered" >s=(<span class="fstat-no" title="function not covered" >()</span>=&gt;{const t=<span class="cstat-no" title="statement not covered" >e.clientWidth,</span>s=<span class="cstat-no" title="statement not covered" >e.clientHeight,</span>i=<span class="cstat-no" title="statement not covered" >new Map,</span>n=<span class="cstat-no" title="statement not covered" >new Map;<span class="cstat-no" title="statement not covered" ></span>return V.nodes.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{let t=<span class="cstat-no" title="statement not covered" >0;<span class="cstat-no" title="statement not covered" ></span>t="cluster"===e.type?0:"host"===e.type?1:"vm"===e.type?2:3,n.has(t)||n.set(t,[]),n.get(t).push(e)}</span>)),Array.from(n.entries()).forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{let[n,a]=<span class="cstat-no" title="statement not covered" >e;</span>const r=<span class="cstat-no" title="statement not covered" >s/5*(n+1);<span class="cstat-no" title="statement not covered" ></span>a.forEach((<span class="fstat-no" title="function not covered" >(e</span>,s)=&gt;{const n=<span class="cstat-no" title="statement not covered" >t/(a.length+1)*(s+1);<span class="cstat-no" title="statement not covered" ></span>i.set(e.id,{x:n,y:r,vx:0,vy:0})}</span>))}</span>)),i}</span>)();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"geographic":<span class="cstat-no" title="statement not covered" >s=(<span class="fstat-no" title="function not covered" >()</span>=&gt;{const t=<span class="cstat-no" title="statement not covered" >e.clientWidth,</span>s=<span class="cstat-no" title="statement not covered" >e.clientHeight,</span>i=<span class="cstat-no" title="statement not covered" >new Map,</span>n=<span class="cstat-no" title="statement not covered" >{"us-east-1":{x:.8*t,y:.3*s},"us-west-2":{x:.2*t,y:.4*s},"eu-west-1":{x:.6*t,y:.2*s},"ap-southeast-1":{x:.9*t,y:.7*s}};<span class="cstat-no" title="statement not covered" ></span>return V.nodes.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const a=<span class="cstat-no" title="statement not covered" >n[e.region],</span>r=<span class="cstat-no" title="statement not covered" >(null===a||void 0===a?void 0:a.x)||Math.random()*t,</span>l=<span class="cstat-no" title="statement not covered" >(null===a||void 0===a?void 0:a.y)||Math.random()*s;<span class="cstat-no" title="statement not covered" ></span>i.set(e.id,{x:r,y:l,vx:0,vy:0})}</span>)),i}</span>)();<span class="cstat-no" title="statement not covered" >b</span>reak;c</span>ase"clustered":<span class="cstat-no" title="statement not covered" >s=(<span class="fstat-no" title="function not covered" >()</span>=&gt;{const t=<span class="cstat-no" title="statement not covered" >e.clientWidth,</span>s=<span class="cstat-no" title="statement not covered" >e.clientHeight,</span>i=<span class="cstat-no" title="statement not covered" >new Map;<span class="cstat-no" title="statement not covered" ></span>return V.nodes.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{let n,a;<span class="cstat-no" title="statement not covered" >if(e.clusterId&amp;&amp;V.clusters){const i=<span class="cstat-no" title="statement not covered" >V.clusters.find((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.id===e.clusterId)</span>);<span class="cstat-no" title="statement not covered" ></span>(null===i||void 0===i?void 0:i.bounds)?(n=i.bounds.x+Math.random()*i.bounds.width,a=i.bounds.y+Math.random()*i.bounds.height):(n=Math.random()*t,a=Math.random()*s)}</span>else <span class="cstat-no" title="statement not covered" >n=Math.random()*t,a=Math.random()*s;<span class="cstat-no" title="statement not covered" >i</span></span>.set(e.id,{x:n,y:a,vx:0,vy:0})}</span>)),i}</span>)();<span class="cstat-no" title="statement not covered" >b</span>reak;d</span>efault:<span class="cstat-no" title="statement not covered" >s=new Map}<span class="cstat-no" title="statement not covered" ></span>s</span>.forEach((<span class="fstat-no" title="function not covered" >(e</span>,t)=&gt;{<span class="cstat-no" title="statement not covered" >i.set(t,e)}</span>)),t.clearRect(0,0,e.width,e.height),V.clusters&amp;&amp;T&amp;&amp;V.clusters.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const t=<span class="cstat-no" title="statement not covered" >V.nodes.filter((<span class="fstat-no" title="function not covered" >t=</span>&gt;<span class="cstat-no" title="statement not covered" >t.clusterId===e.id)</span>);<span class="cstat-no" title="statement not covered" ></span>if(t.length&gt;0){const s=<span class="cstat-no" title="statement not covered" >t.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >i.get(e.id))</span>).filter(Boolean);<span class="cstat-no" title="statement not covered" ></span>if(s.length&gt;0){const t=<span class="cstat-no" title="statement not covered" >Math.min(...s.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.x)</span>))-50,</span>i=<span class="cstat-no" title="statement not covered" >Math.max(...s.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.x)</span>))+50,</span>n=<span class="cstat-no" title="statement not covered" >Math.min(...s.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.y)</span>))-50,</span>a=<span class="cstat-no" title="statement not covered" >Math.max(...s.map((<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >e.y)</span>))+50;<span class="cstat-no" title="statement not covered" ></span>e.bounds={x:t,y:n,width:i-t,height:a-n}}</span>}<span class="cstat-no" title="statement not covered" ></span>c</span>(e)}</span>)),V.edges.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const t=<span class="cstat-no" title="statement not covered" >i.get(e.source),</span>s=<span class="cstat-no" title="statement not covered" >i.get(e.target);<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;s&amp;&amp;h(e,t,s)}</span>)),V.nodes.forEach((<span class="fstat-no" title="function not covered" >e=</span>&gt;{const t=<span class="cstat-no" title="statement not covered" >i.get(e.id);<span class="cstat-no" title="statement not covered" ></span>t&amp;&amp;o(e,t)}</span>))}</span>}</span>)();l</span>et f=<span class="cstat-no" title="statement not covered" >null;<span class="cstat-no" title="statement not covered" ></span>v&amp;&amp;p&gt;0&amp;&amp;(f=setInterval((<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >console.log("Refreshing network topology data...")}</span>),p));c</span>onst x=<span class="cstat-no" title="statement not covered" ><span class="fstat-no" title="function not covered" >t=</span>&gt;{const s=<span class="cstat-no" title="statement not covered" >e.getBoundingClientRect(),</span>n=<span class="cstat-no" title="statement not covered" >t.clientX-s.left,</span>a=<span class="cstat-no" title="statement not covered" >t.clientY-s.top;<span class="cstat-no" title="statement not covered" ></span>for(const e of V.nodes){const t=<span class="cstat-no" title="statement not covered" >i.get(e.id);<span class="cstat-no" title="statement not covered" ></span>if(!t)<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst s=<span class="cstat-no" title="statement not covered" >"host"===e.type||"cluster"===e.type?15:10;<span class="cstat-no" title="statement not covered" ></span>if(Math.sqrt(Math.pow(t.x-n,2)+Math.pow(t.y-a,2))&lt;=s+3)<span class="cstat-no" title="statement not covered" >return void(w&amp;&amp;w(e))}<span class="cstat-no" title="statement not covered" ></span></span>i</span>f(V.clusters&amp;&amp;T)<span class="cstat-no" title="statement not covered" >for(const e of V.clusters)<span class="cstat-no" title="statement not covered" >if(e.bounds){const{x:t,y:s,width:i,height:r}=<span class="cstat-no" title="statement not covered" >e.bounds;<span class="cstat-no" title="statement not covered" ></span>if(n&gt;=t&amp;&amp;n&lt;=t+i&amp;&amp;a&gt;=s&amp;&amp;a&lt;=s+r){<span class="cstat-no" title="statement not covered" >b&amp;&amp;b(e);c</span>onst t=<span class="cstat-no" title="statement not covered" >H.has(e.id),</span>s=<span class="cstat-no" title="statement not covered" >new Set(H);<span class="cstat-no" title="statement not covered" ></span>return t?s.delete(e.id):s.add(e.id),void O(s)}</span>}<span class="cstat-no" title="statement not covered" ></span>f</span></span></span>or(const e of V.edges){const t=<span class="cstat-no" title="statement not covered" >i.get(e.source),</span>s=<span class="cstat-no" title="statement not covered" >i.get(e.target);<span class="cstat-no" title="statement not covered" ></span>if(!t||!s)<span class="cstat-no" title="statement not covered" >continue;c</span></span>onst r=<span class="cstat-no" title="statement not covered" >n-t.x,</span>c=<span class="cstat-no" title="statement not covered" >a-t.y,</span>o=<span class="cstat-no" title="statement not covered" >s.x-t.x,</span>h=<span class="cstat-no" title="statement not covered" >s.y-t.y,</span>d=<span class="cstat-no" title="statement not covered" >r*o+c*h,</span>u=<span class="cstat-no" title="statement not covered" >o*o+h*h;</span>let f,x,m=<span class="cstat-no" title="statement not covered" >-1;<span class="cstat-no" title="statement not covered" ></span>0!==u&amp;&amp;(m=d/u),m&lt;0?(f=t.x,x=t.y):m&gt;1?(f=s.x,x=s.y):(f=t.x+m*o,x=t.y+m*h);c</span>onst g=<span class="cstat-no" title="statement not covered" >n-f,</span>y=<span class="cstat-no" title="statement not covered" >a-x;<span class="cstat-no" title="statement not covered" ></span>if(Math.sqrt(g*g+y*y)&lt;=l(e)+2)<span class="cstat-no" title="statement not covered" >return void(M&amp;&amp;M(e))}</span></span>}</span>;<span class="cstat-no" title="statement not covered" ></span>return e.addEventListener("click",x),<span class="fstat-no" title="function not covered" >()</span>=&gt;{<span class="cstat-no" title="statement not covered" >e.removeEventListener("click",x),window.removeEventListener("resize",s),k.current&amp;&amp;cancelAnimationFrame(k.current),f&amp;&amp;clearInterval(f)}</span>}</span>),[V,N,T,B,R,L,W,v,p,w,M,b,H]),(0,i.jsxs)(a.Zb,{children:[(0,i.jsxs)(a.Ol,{className:"flex flex-row items-center justify-between space-y-0 pb-2",children:[(0,i.jsxs)("div",{children:[(0,i.jsx)(a.ll,{children:s}),f&amp;&amp;(0,i.jsx)("p",{className:"text-sm text-muted-foreground",children:f})]}),(0,i.jsxs)(r.Ph,{value:N,onValueChange:E,children:[(0,i.jsx)(r.i4,{className:"w-[180px]",children:(0,i.jsx)(r.ki,{placeholder:"Layout Type"})}),(0,i.jsxs)(r.Bw,{children:[(0,i.jsx)(r.Ql,{value:"force",children:"Force-Directed"}),(0,i.jsx)(r.Ql,{value:"circular",children:"Circular"}),(0,i.jsx)(r.Ql,{value:"hierarchical",children:"Hierarchical"}),(0,i.jsx)(r.Ql,{value:"geographic",children:"Geographic"}),(0,i.jsx)(r.Ql,{value:"clustered",children:"Clustered"})]})]})]}),(0,i.jsxs)(a.aY,{children:[(0,i.jsxs)("div",{className:"flex flex-wrap gap-2 mb-4",children:[(0,i.jsxs)(c.z,{size:"sm",variant:T?"default":"outline",onClick:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >A(!T),</span>children:[(0,i.jsx)(h.Z,{className:"h-4 w-4 mr-1"}),"Distributed View"]}),(0,i.jsxs)(c.z,{size:"sm",variant:B?"default":"outline",onClick:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >F(!B),</span>children:[(0,i.jsx)(d.Z,{className:"h-4 w-4 mr-1"}),"Bandwidth"]}),(0,i.jsxs)(c.z,{size:"sm",variant:R?"default":"outline",onClick:<span class="fstat-no" title="function not covered" >()</span>=&gt;<span class="cstat-no" title="statement not covered" >q(!R),</span>children:[(0,i.jsx)(u.Z,{className:"h-4 w-4 mr-1"}),"Metrics"]}),(0,i.jsxs)(r.Ph,{value:W,onValueChange:<span class="fstat-no" title="function not covered" >e=</span>&gt;<span class="cstat-no" title="statement not covered" >D(e),</span>children:[(0,i.jsx)(r.i4,{className:"w-[120px] h-8",children:(0,i.jsx)(r.ki,{})}),(0,i.jsxs)(r.Bw,{children:[(0,i.jsx)(r.Ql,{value:"low",children:"Low Detail"}),(0,i.jsx)(r.Ql,{value:"medium",children:"Medium Detail"}),(0,i.jsx)(r.Ql,{value:"high",children:"High Detail"})]})]}),T&amp;&amp;U&amp;&amp;(0,i.jsxs)(l.C,{variant:"outline",className:"ml-auto",children:[(0,i.jsx)("div",{className:"w-2 h-2 bg-green-500 rounded-full mr-2 animate-pulse"}),"Live Updates"]})]}),(0,i.jsx)("div",{className:"relative",style:{height:"".concat(x,"px")},children:(0,i.jsx)("canvas",{ref:j,className:"w-full h-full",style:{touchAction:"none"}})}),(0,i.jsxs)("div",{className:"flex justify-center mt-4 space-x-4",children:[(0,i.jsxs)("div",{className:"flex items-center",children:[(0,i.jsx)("div",{className:"w-3 h-3 rounded-full bg-[#4f46e5] mr-2"}),(0,i.jsx)("span",{className:"text-xs",children:"VM"})]}),(0,i.jsxs)("div",{className:"flex items-center",children:[(0,i.jsx)("div",{className:"w-3 h-3 rounded-full bg-[#0891b2] mr-2"}),(0,i.jsx)("span",{className:"text-xs",children:"Host"})]}),(0,i.jsxs)("div",{className:"flex items-center",children:[(0,i.jsx)("div",{className:"w-3 h-3 rounded-full bg-[#7c3aed] mr-2"}),(0,i.jsx)("span",{className:"text-xs",children:"Storage"})]}),(0,i.jsxs)("div",{className:"flex items-center",children:[(0,i.jsx)("div",{className:"w-3 h-3 rounded-full bg-[#2563eb] mr-2"}),(0,i.jsx)("span",{className:"text-xs",children:"Network"})]}),(0,i.jsxs)("div",{className:"flex items-center",children:[(0,i.jsx)("div",{className:"w-3 h-3 rounded-full bg-[#059669] mr-2"}),(0,i.jsx)("span",{className:"text-xs",children:"Service"})]}),T&amp;&amp;(0,i.jsxs)(i.Fragment,{children:[(0,i.jsxs)("div",{className:"flex items-center",children:[(0,i.jsx)("div",{className:"w-3 h-3 rounded-full bg-[#f59e0b] mr-2"}),(0,i.jsx)("span",{className:"text-xs",children:"Cluster"})]}),(0,i.jsxs)("div",{className:"flex items-center",children:[(0,i.jsx)("div",{className:"w-3 h-3 rounded-full bg-[#ec4899] mr-2"}),(0,i.jsx)("span",{className:"text-xs",children:"Federation"})]})]})]})]})]})}</span>}</span>}]);</span></pre></td></tr></table></pre>

                <div class='push'></div><!-- for sticky footer -->
            </div><!-- /wrapper -->
            <div class='footer quiet pad2 space-top1 center small'>
                Code coverage generated by
                <a href="https://istanbul.js.org/" target="_blank" rel="noopener noreferrer">istanbul</a>
                at 2025-11-10T08:07:38.115Z
            </div>
        <script src="../../../../../prettify.js"></script>
        <script>
            window.onload = function () {
                prettyPrint();
            };
        </script>
        <script src="../../../../../sorter.js"></script>
        <script src="../../../../../block-navigation.js"></script>
    </body>
</html>
    